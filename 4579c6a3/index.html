
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1" theme-name="Stellar" theme-version="1.28.1">
  
  <meta name="generator" content="Hexo 7.2.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f9fafb">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  
  <title>Understanding LSTM Networks - Sun Yan</title>

  
    <meta name="description" content="Understanding LSTM Networks Recurrent Neural Networks递归神经网络Humans don’t start their thinking from scratch every second. As you read this essay, you understand each word based on your understanding of">
<meta property="og:type" content="article">
<meta property="og:title" content="Understanding LSTM Networks">
<meta property="og:url" content="http://example.com/4579c6a3/index.html">
<meta property="og:site_name" content="Sun Yan">
<meta property="og:description" content="Understanding LSTM Networks Recurrent Neural Networks递归神经网络Humans don’t start their thinking from scratch every second. As you read this essay, you understand each word based on your understanding of">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/4579c6a3/1.png">
<meta property="og:image" content="http://example.com/4579c6a3/2.png">
<meta property="og:image" content="http://example.com/4579c6a3/3.png">
<meta property="og:image" content="http://example.com/4579c6a3/4.png">
<meta property="og:image" content="http://example.com/4579c6a3/5.png">
<meta property="og:image" content="http://example.com/4579c6a3/6.png">
<meta property="og:image" content="http://example.com/4579c6a3/7.png">
<meta property="og:image" content="http://example.com/4579c6a3/8.png">
<meta property="og:image" content="http://example.com/4579c6a3/9.png">
<meta property="og:image" content="http://example.com/4579c6a3/10.png">
<meta property="og:image" content="http://example.com/4579c6a3/11.png">
<meta property="og:image" content="http://example.com/4579c6a3/12.png">
<meta property="og:image" content="http://example.com/4579c6a3/13.png">
<meta property="og:image" content="http://example.com/4579c6a3/14.png">
<meta property="og:image" content="http://example.com/4579c6a3/15.png">
<meta property="og:image" content="http://example.com/4579c6a3/16.png">
<meta property="article:published_time" content="2024-06-16T10:07:01.000Z">
<meta property="article:modified_time" content="2024-06-16T14:23:22.633Z">
<meta property="article:author" content="Sun Yan">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="神经网络">
<meta property="article:tag" content="Ilya sutskever‘s 30  papers">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/4579c6a3/1.png">
  
  
  
  <meta name="keywords" content="AI,神经网络,Ilya sutskever‘s 30  papers">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="Sun Yan" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.28.1">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Sun Yan</div><div class="sub cap">Backend Developer</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/bccbdfb8/"><span class="title">Spring中三级缓存无法解决的循环依赖</span></a><a class="item title" href="/a10675df/"><span class="title">Spring AOP XML配置方式原理详解</span></a><a class="item title" href="/4316da89/"><span class="title">Spring AOP  注解方式原理详解</span></a><a class="item title" href="/678b23b2/"><span class="title">Spring bean 实例化过程</span></a><a class="item title" href="/b4b9d0ea/"><span class="title">理解 Spring FacrotyBean</span></a><a class="item title" href="/114991e5/"><span class="title">Spring 启动过程 拓展点</span></a><a class="item title" href="/50be4554/"><span class="title">Spring IOC容器 和 Spring bean</span></a><a class="item title" href="/62ebaa0e/"><span class="title">Spring AOP  实践</span></a><a class="item title" href="/abd111cb/"><span class="title">Java动态代理</span></a><a class="item title" href="/f27811be/"><span class="title">神经网络（Neural Networks）</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/sysunyan1699" target="_blank" rel="external nofollow noopener noreferrer"><img no-lazy src="/images/github.png" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="social" href="https://www.linkedin.com/in/yansun1699/" target="_blank" rel="external nofollow noopener noreferrer"><img no-lazy src="/images/LinkedIn.png" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="social" href="/sysunyan1699@gmail.com" rel="noopener noreferrer"><img no-lazy src="/images/gmail.png" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-06-16T10:07:01.000Z">2024-06-16</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-06-16T14:23:22.633Z">2024-06-16</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>Understanding LSTM Networks</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p><a target="_blank" rel="noopener" href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a></p>
<h1 id="recurrent-neural-networks"><a href="#Recurrent-Neural-Networks" class="headerlink" title="Recurrent Neural Networks"></a>Recurrent Neural Networks</h1><p>递归神经网络<br>Humans don’t start their thinking from scratch every second. As you read this essay, you understand each word based on your understanding of previous words. You don’t throw everything away and start thinking from scratch again. Your thoughts have persistence.<br>人类不会每秒都从头开始思考。当你阅读这篇文章时，你会基于对之前词语的理解来理解每个词。你不会把所有东西都丢掉然后重新开始思考。你的思维是有连续性的。</p>
<p>Traditional neural networks can’t do this, and it seems like a major shortcoming. For example, imagine you want to classify what kind of event is happening at every point in a movie. It’s unclear how a traditional neural network could use its reasoning about previous events in the film to inform later ones.<br>传统的神经网络做不到这一点，这似乎是一个主要的缺陷。比如，想象一下你想对电影中每个时刻发生的事件类型进行分类。目前尚不清楚传统的神经网络如何利用其对电影中先前事件的推理来为后来的事件提供信息。</p>
<p>Recurrent neural networks address this issue. They are networks with loops in them, allowing information to persist.<br>循环神经网络解决了这个问题。它们是内部带有循环的网络，允许信息持续存在。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/1.png" class>
<p><strong>Recurrent Neural Networks have loops.  递归神经网络有循环。</strong></p>
<p>In the above diagram, a chunk of neural network, 𝐴, looks at some input $𝑥_𝑡$ and outputs a value $ℎ_𝑡$. A loop allows information to be passed from one step of the network to the next.<br>在上图中，神经网络的一部分 $A$ ,查看一些输入$x_t​$ 并输出一个值 $h_t$。一个循环允许信息从网络的一个步骤传递到下一个步骤。</p>
<p>These loops make recurrent neural networks seem kind of mysterious. However, if you think a bit more, it turns out that they aren’t all that different than a normal neural network. A recurrent neural network can be thought of as multiple copies of the same network, each passing a message to a successor. Consider what happens if we unroll the loop:<br>这些循环使循环神经网络看起来有点神秘。然而，如果你多想一点，就会发现它们与普通的神经网络并没有太大的不同。递归神经网络可以被认为是同一网络的多个副本，每个副本将消息传递给继任者。考虑一下如果我们展开循环会发生什么：<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/2.png" class><br><strong>An unrolled recurrent neural network.  展开的循环神经网络。</strong></p>
<p>This chain-like nature reveals that recurrent neural networks are intimately related to sequences and lists. They’re the natural architecture of neural network to use for such data.<br>这种链式结构表明，递归神经网络与序列和列表密切相关。它们是处理此类数据的自然神经网络架构。</p>
<p>And they certainly are used! In the last few years, there have been incredible success applying RNNs to a variety of problems: speech recognition, language modeling, translation, image captioning… The list goes on. I’ll leave discussion of the amazing feats one can achieve with RNNs to Andrej Karpathy’s excellent blog post, <a target="_blank" rel="noopener" href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">The Unreasonable Effectiveness of Recurrent Neural Networks</a>. But they really are pretty amazing.<br>他们当然被使用了！在过去的几年里，将RNN应用于各种问题取得了令人难以置信的成功：语音识别、语言建模、翻译、图像字幕……这样的例子不胜枚举。我将把关于RNN可以实现的惊人壮举的讨论留给Andrej Karpathy的优秀博客文章，递归神经网络的不合理有效性。但他们真的非常了不起。</p>
<p>Essential to these successes is the use of “LSTMs,” a very special kind of recurrent neural network which works, for many tasks, much much better than the standard version. Almost all exciting results based on recurrent neural networks are achieved with them. It’s these LSTMs that this essay will explore.<br>这些成功的关键是“LSTM”的使用，这是一种非常特殊的递归神经网络，对于许多任务，它比标准版本要好得多。几乎所有基于递归神经网络的令人兴奋的结果都是通过它们实现的。本文将探讨的正是这些 LSTM。</p>
<h1 id="the-problem-of-long-term-dependencies"><a href="#The-Problem-of-Long-Term-Dependencies" class="headerlink" title="The Problem of Long-Term Dependencies"></a>The Problem of Long-Term Dependencies</h1><p>长期依赖性问题</p>
<p>One of the appeals of RNNs is the idea that they might be able to connect previous information to the present task, such as using previous video frames might inform the understanding of the present frame. If RNNs could do this, they’d be extremely useful. But can they? It depends.<br>RNN的吸引力之一是，它们可能能够将先前的信息与当前任务联系起来，例如使用以前的视频帧可能会为理解当前帧提供信息。如果RNN可以做到这一点，它们将非常有用。但是他们能做到吗？这要视情况而定。</p>
<p>Sometimes, we only need to look at recent information to perform the present task. For example, consider a language model trying to predict the next word based on the previous ones. If we are trying to predict the last word in “the clouds are in the _sky_,” we don’t need any further context – it’s pretty obvious the next word is going to be sky. In such cases, where the gap between the relevant information and the place that it’s needed is small, RNNs can learn to use the past information.<br>有时候，我们只需要查看最近的信息就可以完成当前的任务。例如，考虑一个语言模型,它尝试基于前面的单词来预测下一个单词。如果我们试图预测“the clouds are in the sky”中的最后一个单词，我们不需要任何进一步的上下文——很明显下一个单词将是sky。在这种情况下，相关信息和所需位置之间的间隔较小，RNNs可以学习使用过去的信息。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/3.png" class></p>
<p>But there are also cases where we need more context. Consider trying to predict the last word in the text “I grew up in France… I speak fluent _French_.” Recent information suggests that the next word is probably the name of a language, but if we want to narrow down which language, we need the context of France, from further back. It’s entirely possible for the gap between the relevant information and the point where it is needed to become very large.<br>但在某些情况下，我们需要更多的背景信息。考虑试图预测文本“I grew up in France… I speak fluent French.”中的最后一个单词。最近的信息表明下一个单词可能是某种语言的名称，但如果我们想缩小语言范围，我们需要更早的法国这一背景信息。相关信息和需要使用该信息的点之间的间隔完全有可能变得非常大。</p>
<p>Unfortunately, as that gap grows, RNNs become unable to learn to connect the information.<br>不幸的是，随着这种间隔的扩大，RNN变得无法学习去连接信息。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/4.png" class>
<p>In theory, RNNs are absolutely capable of handling such “long-term dependencies.” A human could carefully pick parameters for them to solve toy problems of this form. Sadly, in practice, RNNs don’t seem to be able to learn them. The problem was explored in depth by <a target="_blank" rel="noopener" href="http://people.idsia.ch/~juergen/SeppHochreiter1991ThesisAdvisorSchmidhuber.pdf">Hochreiter (1991) [German]</a> and <a target="_blank" rel="noopener" href="http://www-dsi.ing.unifi.it/~paolo/ps/tnn-94-gradient.pdf">Bengio, et al. (1994)</a>, who found some pretty fundamental reasons why it might be difficult.<br>理论上，RNNs完全有能力处理这种“长期依赖”。人类可以仔细挑选参数，使它们解决这种形式的玩具问题。遗憾的是，在实际应用中，RNNs似乎无法学会它们。这个问题在Hochreiter（1991）和Bengio等人（1994）的研究中得到了深入探讨，他们发现了一些可能导致这一困难的基本原因。</p>
<p>Thankfully, LSTMs don’t have this problem!<br>值得庆幸的是，LSTM 没有这个问题！</p>
<h1 id="lstm-networks"><a href="#LSTM-Networks" class="headerlink" title="LSTM Networks"></a>LSTM Networks</h1><p>Long Short Term Memory networks – usually just called “LSTMs” – are a special kind of RNN, capable of learning long-term dependencies. They were introduced by <a target="_blank" rel="noopener" href="http://www.bioinf.jku.at/publications/older/2604.pdf">Hochreiter &amp; Schmidhuber (1997)</a>, and were refined and popularized by many people in following work.<a target="_blank" rel="noopener" href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/#fn1">1</a> They work tremendously well on a large variety of problems, and are now widely used.<br>长短期记忆网络——通常简称为“LSTMs”——是一种特殊的RNN，能够学习长期依赖。它们由Hochreiter和Schmidhuber（1997）引入，并在随后的工作中被许多人改进和推广。LSTMs在大量不同的问题上表现出色，现在被广泛使用。</p>
<p>LSTMs are explicitly designed to avoid the long-term dependency problem. Remembering information for long periods of time is practically their default behavior, not something they struggle to learn!<br>LSTMs被明确设计用于避免长期依赖问题。记住长时间的信息几乎是它们的默认行为，而不是它们需要努力学习的东西！</p>
<p>All recurrent neural networks have the form of a chain of repeating modules of neural network. In standard RNNs, this repeating module will have a very simple structure, such as a single tanh layer.<br>所有递归神经网络都具有神经网络重复模块链的形式。在标准 RNN 中，该重复模块将具有非常简单的结构，例如单个 tanh 层。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/5.png" class>
<p><strong>The repeating module in a standard RNN contains a single layer.<br>标准 RNN 中的重复模块包含单层。</strong></p>
<p>LSTMs also have this chain like structure, but the repeating module has a different structure. Instead of having a single neural network layer, there are four, interacting in a very special way.<br>LSTM 也具有这种链状结构，但重复模块具有不同的结构。不是只有一个神经网络层，而是有四个，以一种非常特殊的方式进行交互。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/6.png" class>
<p><strong>The repeating module in an LSTM contains four interacting layers.<br>LSTM 中的重复模块包含四个交互层。</strong></p>
<p>Don’t worry about the details of what’s going on. We’ll walk through the LSTM diagram step by step later. For now, let’s just try to get comfortable with the notation we’ll be using.<br>不用担心具体的细节。我们稍后会一步步讲解LSTM的图表。现在，让我们先熟悉一下我们将要使用的符号。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/7.png" class><br>In the above diagram, each line carries an entire vector, from the output of one node to the inputs of others. The pink circles represent pointwise operations, like vector addition, while the yellow boxes are learned neural network layers. Lines merging denote concatenation, while a line forking denote its content being copied and the copies going to different locations.<br>在上图中，每条线都带有一个完整的向量，从一个节点的输出到其他节点的输入。粉红色的圆圈代表逐点运算，如向量加法，而黄色框是学习的神经网络层。合并的行表示串联，而分叉的行表示正在复制其内容并将副本发送到不同的位置。</p>
<h1 id="the-core-idea-behind-lstms"><a href="#The-Core-Idea-Behind-LSTMs" class="headerlink" title="The Core Idea Behind LSTMs"></a>The Core Idea Behind LSTMs</h1><p>LSTM 背后的核心思想</p>
<p>The key to LSTMs is the cell state, the horizontal line running through the top of the diagram.<br>LSTMs的关键是单元状态，这条横线贯穿了图表的顶部。</p>
<p>The cell state is kind of like a conveyor belt. It runs straight down the entire chain, with only some minor linear interactions. It’s very easy for information to just flow along it unchanged.<br>单元状态有点像传送带。它直接沿着整个链条运行，只有一些小的线性交互。信息可以非常容易地沿着它不变地流动。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/8.png" class>
<p>The LSTM does have the ability to remove or add information to the cell state, carefully regulated by structures called gates.<br>LSTM确实具有从单元状态中移除或添加信息的能力，这些操作由称为门控的结构严格调控。</p>
<p>Gates are a way to optionally let information through. They are composed out of a sigmoid neural net layer and a pointwise multiplication operation.<br>门控是一种选择性地让信息通过的方式。它们由一个sigmoid神经网络层和一个逐点乘法操作组成。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/9.png" class><br>The sigmoid layer outputs numbers between zero and one, describing how much of each component should be let through. A value of zero means “let nothing through,” while a value of one means “let everything through!”<br>sigmoid 层输出介于 0 和 1 之间的数字，描述每个组件应通过多少。值为零表示“什么都不让通过”，而值为 1 表示“让所有东西都通过！”</p>
<p>An LSTM has three of these gates, to protect and control the cell state.<br>LSTM 有三个这样的门，用于保护和控制单元状态。</p>
<h1 id="step-by-step-lstm-walk-through"><a href="#Step-by-Step-LSTM-Walk-Through" class="headerlink" title="Step-by-Step LSTM Walk Through"></a>Step-by-Step LSTM Walk Through</h1><p>循序渐进的 LSTM 演练</p>
<h2 id="forget-gate-layer"><a href="#forget-gate-layer" class="headerlink" title="forget gate layer"></a>forget gate layer</h2><p>The first step in our LSTM is to decide what information we’re going to throw away from the cell state. This decision is made by a sigmoid layer called the “forget gate layer.” It looks at $h_{t−1}$ and $x_t$, and outputs a number between 00 and 11 for each number in the cell state $C_{t−1}$. A 1 represents “completely keep this” while a 0 represents “completely get rid of this.”<br>LSTM的第一步是决定要从单元状态中丢弃哪些信息。这个决策是由一个名为“遗忘门层”的sigmoid层做出的。它查看 $h_{t-1}​$ 和 $x_t$，并为单元状态 $C_{t-1}$ 中的每个数字输出一个介于0和1之间的数值。1表示“完全保留这个”，而0表示“完全丢弃这个”。</p>
<p>Let’s go back to our example of a language model trying to predict the next word based on all the previous ones. In such a problem, the cell state might include the gender of the present subject, so that the correct pronouns can be used. When we see a new subject, we want to forget the gender of the old subject.<br>让我们回到我们的例子，一个语言模型试图基于所有前面的单词来预测下一个单词。在这样的问题中，单元状态可能包含当前主语的性别，以便使用正确的代词。当我们看到一个新的主语时，我们想忘记旧主语的性别。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/10.png" class></p>
<h2 id="input-gate-layer"><a href="#input-gate-layer" class="headerlink" title="input gate layer"></a>input gate layer</h2><p>The next step is to decide what new information we’re going to store in the cell state. This has two parts. First, a sigmoid layer called the “input gate layer” decides which values we’ll update. Next, a tanh layer creates a vector of new candidate values, $\tilde{C}_t$, that could be added to the state. In the next step, we’ll combine these two to create an update to the state.<br>下一步是决定要在单元状态中存储哪些新信息。这包括两个部分。首先，一个名为“输入门层”的sigmoid层决定我们将更新哪些值。接下来，一个tanh层创建一个新的候选值向量$\tilde{C}_t$，这些候选值可以被添加到状态中。在下一步中，我们将结合这两部分来更新状态。</p>
<p>In the example of our language model, we’d want to add the gender of the new subject to the cell state, to replace the old one we’re forgetting.<br>在我们的语言模型示例中，我们希望将新主语的性别添加到单元格状态中，以替换我们忘记的旧主语。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/11.png" class>
<p>It’s now time to update the old cell state$C_{t-1}$, into the new cell state $C_t$​. The previous steps already decided what to do, we just need to actually do it.<br>现在是时候将旧的单元格状态$C_{t-1}$更新为新的单元格状态 $C_t$​了。前面的步骤已经决定了要做什么，我们只需要实际去执行它。</p>
<p>We multiply the old state by $𝑓_𝑡$, forgetting the things we decided to forget earlier. Then we add $i_t \ast \tilde{C}_t$. This is the new candidate values, scaled by how much we decided to update each state value.<br>我们将旧状态乘以 $f_t$，忘记我们之前决定忘记的内容。然后我们加上 $i_t \ast \tilde{C}_t$。这些是新的候选值，按我们决定更新每个状态值的程度进行缩放。</p>
<p>In the case of the language model, this is where we’d actually drop the information about the old subject’s gender and add the new information, as we decided in the previous steps.<br>在语言模型的情况下，正如我们在前面的步骤中决定的那样，我们实际上会删除有关旧主题性别的信息并添加新信息。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/12.png" class>
<h2 id="output-layer"><a href="#output-layer" class="headerlink" title="output  layer"></a>output  layer</h2><p>Finally, we need to decide what we’re going to output. This output will be based on our cell state, but will be a filtered version. First, we run a sigmoid layer which decides what parts of the cell state we’re going to output. Then, we put the cell state through tanh (to push the values to be between −1 and 1) and multiply it by the output of the sigmoid gate, so that we only output the parts we decided to.<br>最后，我们需要决定输出什么。这个输出将基于我们的单元状态，但会是一个过滤后的版本。首先，我们运行一个sigmoid层来决定要输出单元状态的哪些部分。然后，我们将单元状态通过tanh（将值压缩到-1到1之间），并将其与sigmoid门的输出相乘，这样我们只输出我们决定输出的部分。</p>
<p>For the language model example, since it just saw a subject, it might want to output information relevant to a verb, in case that’s what is coming next. For example, it might output whether the subject is singular or plural, so that we know what form a verb should be conjugated into if that’s what follows next.<br>对于语言模型的例子，由于它刚刚看到一个主语，它可能想输出与动词相关的信息，以防接下来需要动词。例如，它可能会输出主语是单数还是复数，这样我们就知道如果接下来是动词，该动词应该变成什么形式。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/13.png" class>
<h1 id="variants-on-long-short-term-memory"><a href="#Variants-on-Long-Short-Term-Memory" class="headerlink" title="Variants on Long Short Term Memory"></a>Variants on Long Short Term Memory</h1><p>长短期记忆的变体</p>
<p>What I’ve described so far is a pretty normal LSTM. But not all LSTMs are the same as the above. In fact, it seems like almost every paper involving LSTMs uses a slightly different version. The differences are minor, but it’s worth mentioning some of them.<br>我到目前为止描述的是一个相当普通的LSTM。但并不是所有的LSTM都与上述相同。实际上，几乎每篇涉及LSTM的论文都使用了稍微不同的版本。这些差异很小，但值得一提。</p>
<p>One popular LSTM variant, introduced by <a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf">Gers &amp; Schmidhuber (2000)</a>, is adding “peephole connections.” This means that we let the gate layers look at the cell state.<br>一个由Gers和Schmidhuber（2000）引入的流行LSTM变体是添加“窥视连接”。这意味着我们让门控层查看单元状态。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/14.png" class>
<p>The above diagram adds peepholes to all the gates, but many papers will give some peepholes and not others.<br>上图为所有门控添加了窥视连接，但许多论文会只为部分门控添加窥视连接，而不是全部。</p>
<p>Another variation is to use coupled forget and input gates. Instead of separately deciding what to forget and what we should add new information to, we make those decisions together. We only forget when we’re going to input something in its place. We only input new values to the state when we forget something older.<br>另一种变体是使用耦合的遗忘门和输入门。我们不是分别决定要忘记什么以及要添加什么新信息，而是将这些决策结合在一起。我们只有在要输入新信息时才会忘记某些内容。只有在忘记旧信息时，我们才会将新值输入到状态中。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/15.png" class>
<p>A slightly more dramatic variation on the LSTM is the Gated Recurrent Unit, or GRU, introduced by <a target="_blank" rel="noopener" href="http://arxiv.org/pdf/1406.1078v3.pdf">Cho, et al. (2014)</a>. It combines the forget and input gates into a single “update gate.” It also merges the cell state and hidden state, and makes some other changes. The resulting model is simpler than standard LSTM models, and has been growing increasingly popular.<br>LSTM的一个稍微更显著的变体是门控循环单元（GRU），由Cho等人（2014）引入。它将遗忘门和输入门组合成一个“更新门”。它还合并了单元状态和隐藏状态，并做了一些其他的改变。最终的模型比标准的LSTM模型更简单，并且越来越受欢迎。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/4579c6a3/16.png" class>
<p>These are only a few of the most notable LSTM variants. There are lots of others, like Depth Gated RNNs by <a target="_blank" rel="noopener" href="http://arxiv.org/pdf/1508.03790v2.pdf">Yao, et al. (2015)</a>. There’s also some completely different approach to tackling long-term dependencies, like Clockwork RNNs by <a target="_blank" rel="noopener" href="http://arxiv.org/pdf/1402.3511v1.pdf">Koutnik, et al. (2014)</a>.<br>这些只是一些最著名的LSTM变体。还有许多其他变体，例如Yao等人（2015）提出的深度门控RNN。此外，还有一些完全不同的方法来解决长期依赖问题，例如Koutnik等人（2014）提出的时钟式RNN。</p>
<p>Which of these variants is best? Do the differences matter? <a target="_blank" rel="noopener" href="http://arxiv.org/pdf/1503.04069.pdf">Greff, et al. (2015)</a> do a nice comparison of popular variants, finding that they’re all about the same. <a target="_blank" rel="noopener" href="http://jmlr.org/proceedings/papers/v37/jozefowicz15.pdf">Jozefowicz, et al. (2015)</a> tested more than ten thousand RNN architectures, finding some that worked better than LSTMs on certain tasks.<br>这些变体中哪一个最好？差异重要吗？Greff等人（2015）对流行变体进行了很好的比较，发现它们的表现几乎相同。Jozefowicz等人（2015）测试了超过一万种RNN架构，发现其中一些在某些任务上的表现比LSTMs更好。</p>
<h1 id="conclusion-结论"><a href="#Conclusion-结论" class="headerlink" title="Conclusion 结论"></a>Conclusion 结论</h1><p>Earlier, I mentioned the remarkable results people are achieving with RNNs. Essentially all of these are achieved using LSTMs. They really work a lot better for most tasks!<br>前面，我提到了人们用递归神经网络（RNNs）取得的显著成果。基本上所有这些成果都是使用LSTMs实现的。对于大多数任务，LSTMs的效果确实要好得多！</p>
<p>Written down as a set of equations, LSTMs look pretty intimidating. Hopefully, walking through them step by step in this essay has made them a bit more approachable.<br>作为一组方程写下来，LSTMs看起来相当令人生畏。希望通过在本文中一步一步地讲解它们，使它们变得更容易理解。</p>
<p>LSTMs were a big step in what we can accomplish with RNNs. It’s natural to wonder: is there another big step? A common opinion among researchers is: “Yes! There is a next step and it’s attention!” The idea is to let every step of an RNN pick information to look at from some larger collection of information. For example, if you are using an RNN to create a caption describing an image, it might pick a part of the image to look at for every word it outputs. In fact, <a target="_blank" rel="noopener" href="http://arxiv.org/pdf/1502.03044v2.pdf">Xu, _et al._ (2015)</a> do exactly this – it might be a fun starting point if you want to explore attention! There’s been a number of really exciting results using attention, and it seems like a lot more are around the corner…<br>LSTMs是我们用RNNs能实现的一个大进步。很自然地会有人问：还有另一个大进步吗？研究人员的一个普遍看法是：“是的！下一个进步是注意力机制！”这个想法是让RNN的每一步都从一些更大的信息集合中选择要看的信息。例如，如果你使用RNN来创建描述图像的标题，它可能会为它输出的每个单词选择图像的一部分。事实上，Xu等人（2015）正是这样做的——如果你想探索注意力机制，这可能是一个有趣的起点！使用注意力机制已经取得了许多非常令人兴奋的成果，似乎还会有更多的成果即将到来……</p>
<p>Attention isn’t the only exciting thread in RNN research. For example, Grid LSTMs by <a target="_blank" rel="noopener" href="http://arxiv.org/pdf/1507.01526v1.pdf">Kalchbrenner, _et al._ (2015)</a> seem extremely promising. Work using RNNs in generative models – such as <a target="_blank" rel="noopener" href="http://arxiv.org/pdf/1502.04623.pdf">Gregor, _et al._ (2015)</a>, <a target="_blank" rel="noopener" href="http://arxiv.org/pdf/1506.02216v3.pdf">Chung, _et al._ (2015)</a>, or <a target="_blank" rel="noopener" href="http://arxiv.org/pdf/1411.7610v3.pdf">Bayer &amp; Osendorfer (2015)</a> – also seems very interesting. The last few years have been an exciting time for recurrent neural networks, and the coming ones promise to only be more so!<br>注意力机制并不是RNN研究中唯一令人兴奋的方向。例如，Kalchbrenner等人（2015）的Grid LSTMs看起来非常有前途。在生成模型中使用RNN的工作——例如Gregor等人（2015）、Chung等人（2015）或Bayer和Osendorfer（2015）的工作——也非常有趣。过去几年是递归神经网络的激动人心的时期，未来几年只会更加激动人心！</p>
<h1 id="acknowledgments-确认"><a href="#Acknowledgments-确认" class="headerlink" title="Acknowledgments 确认"></a>Acknowledgments 确认</h1><p>I’m grateful to a number of people for helping me better understand LSTMs, commenting on the visualizations, and providing feedback on this post.<br>我感谢许多人帮助我更好地理解 LSTM，对可视化进行评论，并对这篇文章提供反馈。</p>
<p>I’m very grateful to my colleagues at Google for their helpful feedback, especially <a target="_blank" rel="noopener" href="http://research.google.com/pubs/OriolVinyals.html">Oriol Vinyals</a>, <a target="_blank" rel="noopener" href="http://research.google.com/pubs/GregCorrado.html">Greg Corrado</a>, <a target="_blank" rel="noopener" href="http://research.google.com/pubs/JonathonShlens.html">Jon Shlens</a>, <a target="_blank" rel="noopener" href="http://people.cs.umass.edu/~luke/">Luke Vilnis</a>, and <a target="_blank" rel="noopener" href="http://www.cs.toronto.edu/~ilya/">Ilya Sutskever</a>. I’m also thankful to many other friends and colleagues for taking the time to help me, including <a target="_blank" rel="noopener" href="https://www.linkedin.com/pub/dario-amodei/4/493/393">Dario Amodei</a>, and <a target="_blank" rel="noopener" href="http://cs.stanford.edu/~jsteinhardt/">Jacob Steinhardt</a>. I’m especially thankful to <a target="_blank" rel="noopener" href="http://www.kyunghyuncho.me/">Kyunghyun Cho</a> for extremely thoughtful correspondence about my diagrams.<br>我非常感谢 Google 同事提供的有益反馈，尤其是 Oriol Vinyals、Greg Corrado、Jon Shlens、Luke Villnis 和 Ilya Sutskever。我还要感谢许多其他朋友和同事抽出时间帮助我，包括 Dario Amodei 和 Jacob Steinhardt。我特别感谢 Kyunghyun Cho 对我的图表进行了非常周到的通信。</p>
<p>Before this post, I practiced explaining LSTMs during two seminar series I taught on neural networks. Thanks to everyone who participated in those for their patience with me, and for their feedback.<br>在这篇文章之前，我在我教授的关于神经网络的两个系列研讨会上练习了解释 LSTM。感谢所有参与活动的人对我的耐心和反馈。</p>
<h1 id="注释-如何理解门控结构的计算"><a href="#注释-如何理解门控结构的计算" class="headerlink" title="注释-如何理解门控结构的计算"></a>注释-如何理解门控结构的计算</h1><p>根据前面的文章， 我们已经知道基础 神经网络和 基础RNN 中，数据从输入层到隐藏层到输出层的计算，这里再复习一下</p>
<h2 id="基础神经网络"><a href="#基础神经网络" class="headerlink" title="基础神经网络"></a>基础神经网络</h2><p><strong>隐藏层</strong><br>$h_t​=f(W_{xh​}x_t​+b_h​)$</p>
<ul>
<li>$x_t$​：当前输入</li>
<li>$W_{xh}$：输入层到隐藏层的权重矩阵</li>
<li>$b_h$​：偏置</li>
<li>$f$：激活函数（如tanh或ReLU）</li>
</ul>
<p>计算隐藏状态分为2个步骤</p>
<ol>
<li>计算隐藏层的输入加权和：</li>
<li>应用激活函数，计算隐藏层的输出<h2 id="基础rnn"><a href="#基础RNN" class="headerlink" title="基础RNN"></a>基础RNN</h2></li>
</ol>
<p>RNN的隐藏层具有循环连接，即多了一个隐藏层到隐藏层的权重矩阵参与计算 ，使得每个隐藏状态依赖于前一时间步的隐藏状态和当前时间步的输入。公式如下：<br>$h_t​=f(W_{hh}​h_{t−1}​+W_{xh​}x_t​+b_h​)$</p>
<ul>
<li>$h_t​$：当前时间步的隐藏状态</li>
<li>$h_{t-1}$：前一时间步的隐藏状态</li>
<li>$x_t$​：当前时间步的输入</li>
<li>$W_{hh}$​：隐藏状态到隐藏状态的权重矩阵</li>
<li>$W_{xh}$：输入到隐藏状态的权重矩阵</li>
<li>$b_h$​：偏置</li>
<li>$f$：激活函数（如tanh或ReLU）</li>
</ul>
<p>从上面文章中可以看到， 不论计算过程在复杂，都是要根据输入求输出。。 而在LSTM 中， 复杂的点在于。隐藏层的计算由简单的隐藏层-隐藏层权重矩阵参与计算 拆分成了多个步骤</p>
<h2 id="lstm"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><h3 id="1-遗忘门forget-gate"><a href="#1-遗忘门（Forget-Gate）" class="headerlink" title="1. 遗忘门（Forget Gate）"></a>1. 遗忘门（Forget Gate）</h3><p>遗忘门控制单元状态中哪些信息需要被保留或丢弃。遗忘门接收当前时间步的输入 $x_t$和前一时间步的隐藏状态 $h_{t-1}$，通过一个$Sigmoid$函数计算得到一个介于0和1之间的标量（或向量），用于缩放前一时间步的细胞状态。</p>
<p>公式如下： $f_t = \sigma(W_f \cdot [h_{t-1}, x_t] + b_f)$<br>如果把层级关系也在公式中体现出来，该公式可以细化成如下格式：<br>$f_t^l = \sigma(W_f \cdot [h_{t-1}^l, x_t^{l-1}] + b_f)$</p>
<p>其中 $x$  也可以替换成其他变量，只要是代表当前时间步的输入即可。<br>例如在 <a target="_blank" rel="noopener" href="https://arxiv.org/pdf/1409.2329">RECURRENT NEURAL NETWORK REGULARIZATION</a>   该公式就表示成了 $f_t^l = \sigma(W_f \cdot [h_{t-1}^l, h_t^{l-1}] + b_f)$</p>
<ul>
<li>$[h_t, x_{t-1}]$或者$[h_t^{l-1}, h_{t-1}^l]$表示将当前输入和前一时间步的隐藏状态向量拼接成一个向量。</li>
<li>$W_f​$ 是该遗忘门的权重矩阵。</li>
<li>$b_f$​ 是偏置向量。</li>
<li>$\sigma$ 是$sigmoid$ 非线性激活函数，输出范围在0到1之间。</li>
</ul>
<h3 id="2-输入门input-gate"><a href="#2-输入门（Input-Gate）" class="headerlink" title="2. 输入门（Input Gate）"></a>2. 输入门（Input Gate）</h3><p>输入门控制新信息写入单元状态的过程。输入门同样接收当前时间步的输入 $x_t$和前一时间步的隐藏状态 $h_{t-1}$，并通过Sigmoid函数生成一个介于0和1之间的标量，表示允许多少新信息进入细胞状态。0表示完全不允许新信息进入，1表示完全允许新信息进入。<br>$tanh$层生成候选单元状态。</p>
<p>公式如下：<br>$i_t = \sigma(W_i \cdot [h_{t-1}, x_t] + b_i)$</p>
<p>$\tilde{C}_t = \tanh(W_C \cdot [h_{t-1}, x_t] + b_C)$</p>
<p>$W_i​$：输入门的权重矩阵，用于将前一时间步的隐藏状态和当前时间步的输入进行线性变换。<br>$W_C​$：候选细胞状态的权重矩阵，用于将前一时间步的隐藏状态和当前时间步的输入进行线性变换。</p>
<h3 id="3-单元状态cell-state"><a href="#3-单元状态（Cell-State）" class="headerlink" title="3. 单元状态（Cell State）"></a>3. 单元状态（Cell State）</h3><p>单元状态 $C_t$​ 是LSTM单元内部的长期记忆，它在时间步之间几乎直接传递，通过遗忘门和输入门的调节进行更新。新的单元状态由前一时间步的单元状态乘以遗忘门的输出加上输入门输出和候选值的乘积得到。</p>
<p>公式如下：$C_t = f_t \cdot C_{t-1} + i_t \cdot \tilde{C}_t$</p>
<h3 id="4-输出门output-gate-得到隐藏状态"><a href="#4-输出门（Output-Gate）-得到隐藏状态" class="headerlink" title="4. 输出门（Output Gate）- 得到隐藏状态"></a>4. 输出门（Output Gate）- 得到隐藏状态</h3><p>输出门决定哪些信息从细胞状态传递到隐藏状态（LSTM单元的输出）。输出门通过Sigmoid函数决定哪些信息将被输出，并将细胞状态通过Tanh层处理后乘以该输出。</p>
<p>公式如下：<br>$o_t = \sigma(W_o \cdot [h_{t-1}, x_t] + b_o)$<br>$h_t = o_t \cdot \tanh(C_t)$</p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/114991e5/">Spring 启动过程 拓展点</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/7057a5e3/">RECURRENT NEURAL NETWORK REGULARIZATION</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">Sun Yan</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1">Stellar 1.28.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#recurrent-neural-networks"><span class="toc-text">Recurrent Neural Networks</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#the-problem-of-long-term-dependencies"><span class="toc-text">The Problem of Long-Term Dependencies</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#lstm-networks"><span class="toc-text">LSTM Networks</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#the-core-idea-behind-lstms"><span class="toc-text">The Core Idea Behind LSTMs</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#step-by-step-lstm-walk-through"><span class="toc-text">Step-by-Step LSTM Walk Through</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#forget-gate-layer"><span class="toc-text">forget gate layer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#input-gate-layer"><span class="toc-text">input gate layer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#output-layer"><span class="toc-text">output  layer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#variants-on-long-short-term-memory"><span class="toc-text">Variants on Long Short Term Memory</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#conclusion-%E7%BB%93%E8%AE%BA"><span class="toc-text">Conclusion 结论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#acknowledgments-%E7%A1%AE%E8%AE%A4"><span class="toc-text">Acknowledgments 确认</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E9%97%A8%E6%8E%A7%E7%BB%93%E6%9E%84%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-text">注释-如何理解门控结构的计算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-text">基础神经网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80rnn"><span class="toc-text">基础RNN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lstm"><span class="toc-text">LSTM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%81%97%E5%BF%98%E9%97%A8forget-gate"><span class="toc-text">1. 遗忘门（Forget Gate）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%BE%93%E5%85%A5%E9%97%A8input-gate"><span class="toc-text">2. 输入门（Input Gate）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E5%85%83%E7%8A%B6%E6%80%81cell-state"><span class="toc-text">3. 单元状态（Cell State）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BE%93%E5%87%BA%E9%97%A8output-gate-%E5%BE%97%E5%88%B0%E9%9A%90%E8%97%8F%E7%8A%B6%E6%80%81"><span class="toc-text">4. 输出门（Output Gate）- 得到隐藏状态</span></a></li></ol></li></ol></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.28.1" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\(","\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body></html>
