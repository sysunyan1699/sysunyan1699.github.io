[{"title":"Understanding LSTM Networks","path":"/4579c6a3/","content":"Understanding LSTM Networks Recurrent Neural Networks递归神经网络Humans don’t start their thinking from scratch every second. As you read this essay, you understand each word based on your understanding of previous words. You don’t throw everything away and start thinking from scratch again. Your thoughts have persistence.人类不会每秒都从头开始思考。当你阅读这篇文章时，你会基于对之前词语的理解来理解每个词。你不会把所有东西都丢掉然后重新开始思考。你的思维是有连续性的。 Traditional neural networks can’t do this, and it seems like a major shortcoming. For example, imagine you want to classify what kind of event is happening at every point in a movie. It’s unclear how a traditional neural network could use its reasoning about previous events in the film to inform later ones.传统的神经网络做不到这一点，这似乎是一个主要的缺陷。比如，想象一下你想对电影中每个时刻发生的事件类型进行分类。目前尚不清楚传统的神经网络如何利用其对电影中先前事件的推理来为后来的事件提供信息。 Recurrent neural networks address this issue. They are networks with loops in them, allowing information to persist.循环神经网络解决了这个问题。它们是内部带有循环的网络，允许信息持续存在。 Recurrent Neural Networks have loops. 递归神经网络有循环。 In the above diagram, a chunk of neural network, 𝐴, looks at some input $𝑥_𝑡$ and outputs a value $ℎ_𝑡$. A loop allows information to be passed from one step of the network to the next.在上图中，神经网络的一部分 $A$ ,查看一些输入$x_t​$ 并输出一个值 $h_t$。一个循环允许信息从网络的一个步骤传递到下一个步骤。 These loops make recurrent neural networks seem kind of mysterious. However, if you think a bit more, it turns out that they aren’t all that different than a normal neural network. A recurrent neural network can be thought of as multiple copies of the same network, each passing a message to a successor. Consider what happens if we unroll the loop:这些循环使循环神经网络看起来有点神秘。然而，如果你多想一点，就会发现它们与普通的神经网络并没有太大的不同。递归神经网络可以被认为是同一网络的多个副本，每个副本将消息传递给继任者。考虑一下如果我们展开循环会发生什么：An unrolled recurrent neural network. 展开的循环神经网络。 This chain-like nature reveals that recurrent neural networks are intimately related to sequences and lists. They’re the natural architecture of neural network to use for such data.这种链式结构表明，递归神经网络与序列和列表密切相关。它们是处理此类数据的自然神经网络架构。 And they certainly are used! In the last few years, there have been incredible success applying RNNs to a variety of problems: speech recognition, language modeling, translation, image captioning… The list goes on. I’ll leave discussion of the amazing feats one can achieve with RNNs to Andrej Karpathy’s excellent blog post, The Unreasonable Effectiveness of Recurrent Neural Networks. But they really are pretty amazing.他们当然被使用了！在过去的几年里，将RNN应用于各种问题取得了令人难以置信的成功：语音识别、语言建模、翻译、图像字幕……这样的例子不胜枚举。我将把关于RNN可以实现的惊人壮举的讨论留给Andrej Karpathy的优秀博客文章，递归神经网络的不合理有效性。但他们真的非常了不起。 Essential to these successes is the use of “LSTMs,” a very special kind of recurrent neural network which works, for many tasks, much much better than the standard version. Almost all exciting results based on recurrent neural networks are achieved with them. It’s these LSTMs that this essay will explore.这些成功的关键是“LSTM”的使用，这是一种非常特殊的递归神经网络，对于许多任务，它比标准版本要好得多。几乎所有基于递归神经网络的令人兴奋的结果都是通过它们实现的。本文将探讨的正是这些 LSTM。 The Problem of Long-Term Dependencies长期依赖性问题 One of the appeals of RNNs is the idea that they might be able to connect previous information to the present task, such as using previous video frames might inform the understanding of the present frame. If RNNs could do this, they’d be extremely useful. But can they? It depends.RNN的吸引力之一是，它们可能能够将先前的信息与当前任务联系起来，例如使用以前的视频帧可能会为理解当前帧提供信息。如果RNN可以做到这一点，它们将非常有用。但是他们能做到吗？这要视情况而定。 Sometimes, we only need to look at recent information to perform the present task. For example, consider a language model trying to predict the next word based on the previous ones. If we are trying to predict the last word in “the clouds are in the _sky_,” we don’t need any further context – it’s pretty obvious the next word is going to be sky. In such cases, where the gap between the relevant information and the place that it’s needed is small, RNNs can learn to use the past information.有时候，我们只需要查看最近的信息就可以完成当前的任务。例如，考虑一个语言模型,它尝试基于前面的单词来预测下一个单词。如果我们试图预测“the clouds are in the sky”中的最后一个单词，我们不需要任何进一步的上下文——很明显下一个单词将是sky。在这种情况下，相关信息和所需位置之间的间隔较小，RNNs可以学习使用过去的信息。 But there are also cases where we need more context. Consider trying to predict the last word in the text “I grew up in France… I speak fluent _French_.” Recent information suggests that the next word is probably the name of a language, but if we want to narrow down which language, we need the context of France, from further back. It’s entirely possible for the gap between the relevant information and the point where it is needed to become very large.但在某些情况下，我们需要更多的背景信息。考虑试图预测文本“I grew up in France… I speak fluent French.”中的最后一个单词。最近的信息表明下一个单词可能是某种语言的名称，但如果我们想缩小语言范围，我们需要更早的法国这一背景信息。相关信息和需要使用该信息的点之间的间隔完全有可能变得非常大。 Unfortunately, as that gap grows, RNNs become unable to learn to connect the information.不幸的是，随着这种间隔的扩大，RNN变得无法学习去连接信息。 In theory, RNNs are absolutely capable of handling such “long-term dependencies.” A human could carefully pick parameters for them to solve toy problems of this form. Sadly, in practice, RNNs don’t seem to be able to learn them. The problem was explored in depth by Hochreiter (1991) [German] and Bengio, et al. (1994), who found some pretty fundamental reasons why it might be difficult.理论上，RNNs完全有能力处理这种“长期依赖”。人类可以仔细挑选参数，使它们解决这种形式的玩具问题。遗憾的是，在实际应用中，RNNs似乎无法学会它们。这个问题在Hochreiter（1991）和Bengio等人（1994）的研究中得到了深入探讨，他们发现了一些可能导致这一困难的基本原因。 Thankfully, LSTMs don’t have this problem!值得庆幸的是，LSTM 没有这个问题！ LSTM NetworksLong Short Term Memory networks – usually just called “LSTMs” – are a special kind of RNN, capable of learning long-term dependencies. They were introduced by Hochreiter &amp; Schmidhuber (1997), and were refined and popularized by many people in following work.1 They work tremendously well on a large variety of problems, and are now widely used.长短期记忆网络——通常简称为“LSTMs”——是一种特殊的RNN，能够学习长期依赖。它们由Hochreiter和Schmidhuber（1997）引入，并在随后的工作中被许多人改进和推广。LSTMs在大量不同的问题上表现出色，现在被广泛使用。 LSTMs are explicitly designed to avoid the long-term dependency problem. Remembering information for long periods of time is practically their default behavior, not something they struggle to learn!LSTMs被明确设计用于避免长期依赖问题。记住长时间的信息几乎是它们的默认行为，而不是它们需要努力学习的东西！ All recurrent neural networks have the form of a chain of repeating modules of neural network. In standard RNNs, this repeating module will have a very simple structure, such as a single tanh layer.所有递归神经网络都具有神经网络重复模块链的形式。在标准 RNN 中，该重复模块将具有非常简单的结构，例如单个 tanh 层。 The repeating module in a standard RNN contains a single layer.标准 RNN 中的重复模块包含单层。 LSTMs also have this chain like structure, but the repeating module has a different structure. Instead of having a single neural network layer, there are four, interacting in a very special way.LSTM 也具有这种链状结构，但重复模块具有不同的结构。不是只有一个神经网络层，而是有四个，以一种非常特殊的方式进行交互。 The repeating module in an LSTM contains four interacting layers.LSTM 中的重复模块包含四个交互层。 Don’t worry about the details of what’s going on. We’ll walk through the LSTM diagram step by step later. For now, let’s just try to get comfortable with the notation we’ll be using.不用担心具体的细节。我们稍后会一步步讲解LSTM的图表。现在，让我们先熟悉一下我们将要使用的符号。In the above diagram, each line carries an entire vector, from the output of one node to the inputs of others. The pink circles represent pointwise operations, like vector addition, while the yellow boxes are learned neural network layers. Lines merging denote concatenation, while a line forking denote its content being copied and the copies going to different locations.在上图中，每条线都带有一个完整的向量，从一个节点的输出到其他节点的输入。粉红色的圆圈代表逐点运算，如向量加法，而黄色框是学习的神经网络层。合并的行表示串联，而分叉的行表示正在复制其内容并将副本发送到不同的位置。 The Core Idea Behind LSTMsLSTM 背后的核心思想 The key to LSTMs is the cell state, the horizontal line running through the top of the diagram.LSTMs的关键是单元状态，这条横线贯穿了图表的顶部。 The cell state is kind of like a conveyor belt. It runs straight down the entire chain, with only some minor linear interactions. It’s very easy for information to just flow along it unchanged.单元状态有点像传送带。它直接沿着整个链条运行，只有一些小的线性交互。信息可以非常容易地沿着它不变地流动。 The LSTM does have the ability to remove or add information to the cell state, carefully regulated by structures called gates.LSTM确实具有从单元状态中移除或添加信息的能力，这些操作由称为门控的结构严格调控。 Gates are a way to optionally let information through. They are composed out of a sigmoid neural net layer and a pointwise multiplication operation.门控是一种选择性地让信息通过的方式。它们由一个sigmoid神经网络层和一个逐点乘法操作组成。The sigmoid layer outputs numbers between zero and one, describing how much of each component should be let through. A value of zero means “let nothing through,” while a value of one means “let everything through!”sigmoid 层输出介于 0 和 1 之间的数字，描述每个组件应通过多少。值为零表示“什么都不让通过”，而值为 1 表示“让所有东西都通过！” An LSTM has three of these gates, to protect and control the cell state.LSTM 有三个这样的门，用于保护和控制单元状态。 Step-by-Step LSTM Walk Through循序渐进的 LSTM 演练 forget gate layerThe first step in our LSTM is to decide what information we’re going to throw away from the cell state. This decision is made by a sigmoid layer called the “forget gate layer.” It looks at $h_{t−1}$ and $x_t$, and outputs a number between 00 and 11 for each number in the cell state $C_{t−1}$. A 1 represents “completely keep this” while a 0 represents “completely get rid of this.”LSTM的第一步是决定要从单元状态中丢弃哪些信息。这个决策是由一个名为“遗忘门层”的sigmoid层做出的。它查看 $h_{t-1}​$ 和 $x_t$，并为单元状态 $C_{t-1}$ 中的每个数字输出一个介于0和1之间的数值。1表示“完全保留这个”，而0表示“完全丢弃这个”。 Let’s go back to our example of a language model trying to predict the next word based on all the previous ones. In such a problem, the cell state might include the gender of the present subject, so that the correct pronouns can be used. When we see a new subject, we want to forget the gender of the old subject.让我们回到我们的例子，一个语言模型试图基于所有前面的单词来预测下一个单词。在这样的问题中，单元状态可能包含当前主语的性别，以便使用正确的代词。当我们看到一个新的主语时，我们想忘记旧主语的性别。 input gate layerThe next step is to decide what new information we’re going to store in the cell state. This has two parts. First, a sigmoid layer called the “input gate layer” decides which values we’ll update. Next, a tanh layer creates a vector of new candidate values, $\\tilde{C}_t$, that could be added to the state. In the next step, we’ll combine these two to create an update to the state.下一步是决定要在单元状态中存储哪些新信息。这包括两个部分。首先，一个名为“输入门层”的sigmoid层决定我们将更新哪些值。接下来，一个tanh层创建一个新的候选值向量$\\tilde{C}_t$，这些候选值可以被添加到状态中。在下一步中，我们将结合这两部分来更新状态。 In the example of our language model, we’d want to add the gender of the new subject to the cell state, to replace the old one we’re forgetting.在我们的语言模型示例中，我们希望将新主语的性别添加到单元格状态中，以替换我们忘记的旧主语。 It’s now time to update the old cell state$C_{t-1}$, into the new cell state $C_t$​. The previous steps already decided what to do, we just need to actually do it.现在是时候将旧的单元格状态$C_{t-1}$更新为新的单元格状态 $C_t$​了。前面的步骤已经决定了要做什么，我们只需要实际去执行它。 We multiply the old state by $𝑓_𝑡$, forgetting the things we decided to forget earlier. Then we add $i_t \\ast \\tilde{C}_t$. This is the new candidate values, scaled by how much we decided to update each state value.我们将旧状态乘以 $f_t$，忘记我们之前决定忘记的内容。然后我们加上 $i_t \\ast \\tilde{C}_t$。这些是新的候选值，按我们决定更新每个状态值的程度进行缩放。 In the case of the language model, this is where we’d actually drop the information about the old subject’s gender and add the new information, as we decided in the previous steps.在语言模型的情况下，正如我们在前面的步骤中决定的那样，我们实际上会删除有关旧主题性别的信息并添加新信息。 output layerFinally, we need to decide what we’re going to output. This output will be based on our cell state, but will be a filtered version. First, we run a sigmoid layer which decides what parts of the cell state we’re going to output. Then, we put the cell state through tanh (to push the values to be between −1 and 1) and multiply it by the output of the sigmoid gate, so that we only output the parts we decided to.最后，我们需要决定输出什么。这个输出将基于我们的单元状态，但会是一个过滤后的版本。首先，我们运行一个sigmoid层来决定要输出单元状态的哪些部分。然后，我们将单元状态通过tanh（将值压缩到-1到1之间），并将其与sigmoid门的输出相乘，这样我们只输出我们决定输出的部分。 For the language model example, since it just saw a subject, it might want to output information relevant to a verb, in case that’s what is coming next. For example, it might output whether the subject is singular or plural, so that we know what form a verb should be conjugated into if that’s what follows next.对于语言模型的例子，由于它刚刚看到一个主语，它可能想输出与动词相关的信息，以防接下来需要动词。例如，它可能会输出主语是单数还是复数，这样我们就知道如果接下来是动词，该动词应该变成什么形式。 Variants on Long Short Term Memory长短期记忆的变体 What I’ve described so far is a pretty normal LSTM. But not all LSTMs are the same as the above. In fact, it seems like almost every paper involving LSTMs uses a slightly different version. The differences are minor, but it’s worth mentioning some of them.我到目前为止描述的是一个相当普通的LSTM。但并不是所有的LSTM都与上述相同。实际上，几乎每篇涉及LSTM的论文都使用了稍微不同的版本。这些差异很小，但值得一提。 One popular LSTM variant, introduced by Gers &amp; Schmidhuber (2000), is adding “peephole connections.” This means that we let the gate layers look at the cell state.一个由Gers和Schmidhuber（2000）引入的流行LSTM变体是添加“窥视连接”。这意味着我们让门控层查看单元状态。 The above diagram adds peepholes to all the gates, but many papers will give some peepholes and not others.上图为所有门控添加了窥视连接，但许多论文会只为部分门控添加窥视连接，而不是全部。 Another variation is to use coupled forget and input gates. Instead of separately deciding what to forget and what we should add new information to, we make those decisions together. We only forget when we’re going to input something in its place. We only input new values to the state when we forget something older.另一种变体是使用耦合的遗忘门和输入门。我们不是分别决定要忘记什么以及要添加什么新信息，而是将这些决策结合在一起。我们只有在要输入新信息时才会忘记某些内容。只有在忘记旧信息时，我们才会将新值输入到状态中。 A slightly more dramatic variation on the LSTM is the Gated Recurrent Unit, or GRU, introduced by Cho, et al. (2014). It combines the forget and input gates into a single “update gate.” It also merges the cell state and hidden state, and makes some other changes. The resulting model is simpler than standard LSTM models, and has been growing increasingly popular.LSTM的一个稍微更显著的变体是门控循环单元（GRU），由Cho等人（2014）引入。它将遗忘门和输入门组合成一个“更新门”。它还合并了单元状态和隐藏状态，并做了一些其他的改变。最终的模型比标准的LSTM模型更简单，并且越来越受欢迎。 These are only a few of the most notable LSTM variants. There are lots of others, like Depth Gated RNNs by Yao, et al. (2015). There’s also some completely different approach to tackling long-term dependencies, like Clockwork RNNs by Koutnik, et al. (2014).这些只是一些最著名的LSTM变体。还有许多其他变体，例如Yao等人（2015）提出的深度门控RNN。此外，还有一些完全不同的方法来解决长期依赖问题，例如Koutnik等人（2014）提出的时钟式RNN。 Which of these variants is best? Do the differences matter? Greff, et al. (2015) do a nice comparison of popular variants, finding that they’re all about the same. Jozefowicz, et al. (2015) tested more than ten thousand RNN architectures, finding some that worked better than LSTMs on certain tasks.这些变体中哪一个最好？差异重要吗？Greff等人（2015）对流行变体进行了很好的比较，发现它们的表现几乎相同。Jozefowicz等人（2015）测试了超过一万种RNN架构，发现其中一些在某些任务上的表现比LSTMs更好。 Conclusion 结论Earlier, I mentioned the remarkable results people are achieving with RNNs. Essentially all of these are achieved using LSTMs. They really work a lot better for most tasks!前面，我提到了人们用递归神经网络（RNNs）取得的显著成果。基本上所有这些成果都是使用LSTMs实现的。对于大多数任务，LSTMs的效果确实要好得多！ Written down as a set of equations, LSTMs look pretty intimidating. Hopefully, walking through them step by step in this essay has made them a bit more approachable.作为一组方程写下来，LSTMs看起来相当令人生畏。希望通过在本文中一步一步地讲解它们，使它们变得更容易理解。 LSTMs were a big step in what we can accomplish with RNNs. It’s natural to wonder: is there another big step? A common opinion among researchers is: “Yes! There is a next step and it’s attention!” The idea is to let every step of an RNN pick information to look at from some larger collection of information. For example, if you are using an RNN to create a caption describing an image, it might pick a part of the image to look at for every word it outputs. In fact, Xu, _et al._ (2015) do exactly this – it might be a fun starting point if you want to explore attention! There’s been a number of really exciting results using attention, and it seems like a lot more are around the corner…LSTMs是我们用RNNs能实现的一个大进步。很自然地会有人问：还有另一个大进步吗？研究人员的一个普遍看法是：“是的！下一个进步是注意力机制！”这个想法是让RNN的每一步都从一些更大的信息集合中选择要看的信息。例如，如果你使用RNN来创建描述图像的标题，它可能会为它输出的每个单词选择图像的一部分。事实上，Xu等人（2015）正是这样做的——如果你想探索注意力机制，这可能是一个有趣的起点！使用注意力机制已经取得了许多非常令人兴奋的成果，似乎还会有更多的成果即将到来…… Attention isn’t the only exciting thread in RNN research. For example, Grid LSTMs by Kalchbrenner, _et al._ (2015) seem extremely promising. Work using RNNs in generative models – such as Gregor, _et al._ (2015), Chung, _et al._ (2015), or Bayer &amp; Osendorfer (2015) – also seems very interesting. The last few years have been an exciting time for recurrent neural networks, and the coming ones promise to only be more so!注意力机制并不是RNN研究中唯一令人兴奋的方向。例如，Kalchbrenner等人（2015）的Grid LSTMs看起来非常有前途。在生成模型中使用RNN的工作——例如Gregor等人（2015）、Chung等人（2015）或Bayer和Osendorfer（2015）的工作——也非常有趣。过去几年是递归神经网络的激动人心的时期，未来几年只会更加激动人心！ Acknowledgments 确认I’m grateful to a number of people for helping me better understand LSTMs, commenting on the visualizations, and providing feedback on this post.我感谢许多人帮助我更好地理解 LSTM，对可视化进行评论，并对这篇文章提供反馈。 I’m very grateful to my colleagues at Google for their helpful feedback, especially Oriol Vinyals, Greg Corrado, Jon Shlens, Luke Vilnis, and Ilya Sutskever. I’m also thankful to many other friends and colleagues for taking the time to help me, including Dario Amodei, and Jacob Steinhardt. I’m especially thankful to Kyunghyun Cho for extremely thoughtful correspondence about my diagrams.我非常感谢 Google 同事提供的有益反馈，尤其是 Oriol Vinyals、Greg Corrado、Jon Shlens、Luke Villnis 和 Ilya Sutskever。我还要感谢许多其他朋友和同事抽出时间帮助我，包括 Dario Amodei 和 Jacob Steinhardt。我特别感谢 Kyunghyun Cho 对我的图表进行了非常周到的通信。 Before this post, I practiced explaining LSTMs during two seminar series I taught on neural networks. Thanks to everyone who participated in those for their patience with me, and for their feedback.在这篇文章之前，我在我教授的关于神经网络的两个系列研讨会上练习了解释 LSTM。感谢所有参与活动的人对我的耐心和反馈。 注释-如何理解门控结构的计算根据前面的文章， 我们已经知道基础 神经网络和 基础RNN 中，数据从输入层到隐藏层到输出层的计算，这里再复习一下 基础神经网络隐藏层$h_t​=f(W_{xh​}x_t​+b_h​)$ $x_t$​：当前输入 $W_{xh}$：输入层到隐藏层的权重矩阵 $b_h$​：偏置 $f$：激活函数（如tanh或ReLU） 计算隐藏状态分为2个步骤 计算隐藏层的输入加权和： 应用激活函数，计算隐藏层的输出基础RNN RNN的隐藏层具有循环连接，即多了一个隐藏层到隐藏层的权重矩阵参与计算 ，使得每个隐藏状态依赖于前一时间步的隐藏状态和当前时间步的输入。公式如下：$h_t​=f(W_{hh}​h_{t−1}​+W_{xh​}x_t​+b_h​)$ $h_t​$：当前时间步的隐藏状态 $h_{t-1}$：前一时间步的隐藏状态 $x_t$​：当前时间步的输入 $W_{hh}$​：隐藏状态到隐藏状态的权重矩阵 $W_{xh}$：输入到隐藏状态的权重矩阵 $b_h$​：偏置 $f$：激活函数（如tanh或ReLU） 从上面文章中可以看到， 不论计算过程在复杂，都是要根据输入求输出。。 而在LSTM 中， 复杂的点在于。隐藏层的计算由简单的隐藏层-隐藏层权重矩阵参与计算 拆分成了多个步骤 LSTM1. 遗忘门（Forget Gate）遗忘门控制单元状态中哪些信息需要被保留或丢弃。遗忘门接收当前时间步的输入 $x_t$和前一时间步的隐藏状态 $h_{t-1}$，通过一个$Sigmoid$函数计算得到一个介于0和1之间的标量（或向量），用于缩放前一时间步的细胞状态。 公式如下： $f_t = \\sigma(W_f \\cdot [h_{t-1}, x_t] + b_f)$如果把层级关系也在公式中体现出来，该公式可以细化成如下格式：$f_t^l = \\sigma(W_f \\cdot [h_{t-1}^l, x_t^{l-1}] + b_f)$ 其中 $x$ 也可以替换成其他变量，只要是代表当前时间步的输入即可。例如在 RECURRENT NEURAL NETWORK REGULARIZATION 该公式就表示成了 $f_t^l = \\sigma(W_f \\cdot [h_{t-1}^l, h_t^{l-1}] + b_f)$ $[h_t, x_{t-1}]$或者$[h_t^{l-1}, h_{t-1}^l]$表示将当前输入和前一时间步的隐藏状态向量拼接成一个向量。 $W_f​$ 是该遗忘门的权重矩阵。 $b_f$​ 是偏置向量。 $\\sigma$ 是$sigmoid$ 非线性激活函数，输出范围在0到1之间。 2. 输入门（Input Gate）输入门控制新信息写入单元状态的过程。输入门同样接收当前时间步的输入 $x_t$和前一时间步的隐藏状态 $h_{t-1}$，并通过Sigmoid函数生成一个介于0和1之间的标量，表示允许多少新信息进入细胞状态。0表示完全不允许新信息进入，1表示完全允许新信息进入。$tanh$层生成候选单元状态。 公式如下：$i_t = \\sigma(W_i \\cdot [h_{t-1}, x_t] + b_i)$ $\\tilde{C}_t = \\tanh(W_C \\cdot [h_{t-1}, x_t] + b_C)$ $W_i​$：输入门的权重矩阵，用于将前一时间步的隐藏状态和当前时间步的输入进行线性变换。$W_C​$：候选细胞状态的权重矩阵，用于将前一时间步的隐藏状态和当前时间步的输入进行线性变换。 3. 单元状态（Cell State）单元状态 $C_t$​ 是LSTM单元内部的长期记忆，它在时间步之间几乎直接传递，通过遗忘门和输入门的调节进行更新。新的单元状态由前一时间步的单元状态乘以遗忘门的输出加上输入门输出和候选值的乘积得到。 公式如下：$C_t = f_t \\cdot C_{t-1} + i_t \\cdot \\tilde{C}_t$ 4. 输出门（Output Gate）- 得到隐藏状态输出门决定哪些信息从细胞状态传递到隐藏状态（LSTM单元的输出）。输出门通过Sigmoid函数决定哪些信息将被输出，并将细胞状态通过Tanh层处理后乘以该输出。 公式如下：$o_t = \\sigma(W_o \\cdot [h_{t-1}, x_t] + b_o)$$h_t = o_t \\cdot \\tanh(C_t)$","tags":["AI","神经网络","Ilya sutskever‘s 30  papers"]},{"title":"RECURRENT NEURAL NETWORK REGULARIZATION","path":"/7057a5e3/","content":"RECURRENT NEURAL NETWORK REGULARIZATION ABSTRACT 摘要We present a simple regularization technique for Recurrent Neural Networks (RNNs) with Long Short-Term Memory (LSTM) units. Dropout, the most suc- cessful technique for regularizing neural networks, does not work well with RNNs and LSTMs. In this paper, we show how to correctly apply dropout to LSTMs, and show that it substantially reduces overfitting on a variety of tasks. These tasks include language modeling, speech recognition, image caption generation, and machine translation.我们提出了一种用于长短期记忆（LSTM）单元的循环神经网络（RNN）的简单正则化技术。最成功的正则化神经网络技术——Dropout，在RNN和LSTM上效果不好。在本文中，我们展示了如何正确地将Dropout应用于LSTM，并证明它在各种任务上显著减少了过拟合。这些任务包括语言建模、语音识别、图像描述生成和机器翻译。 1 INTRODUCTION 引言The Recurrent Neural Network (RNN) is neural sequence model that achieves state of the art per- formance on important tasks that include language modeling Mikolov (2012), speech recognition Graves et al. (2013), and machine translation Kalchbrenner &amp; Blunsom (2013). It is known that successful applications of neural networks require good regularization. Unfortunately, dropout Srivastava (2013), the most powerful regularization method for feedforward neural networks, does not work well with RNNs. As a result, practical applications of RNNs often use models that are too small because large RNNs tend to overfit. Existing regularization methods give relatively small improvements for RNNs Graves (2013). In this work, we show that dropout, when correctly used, greatly reduces overfitting in LSTMs, and evaluate it on three different problems. The code for this work can be found in https://github.com/wojzaremba/lstm. 递归神经网络（RNN）是一种神经序列模型，可在重要任务上实现最先进的性能，包括语言建模Mikolov（2012），语音识别Graves等人（2013）和机器翻译Kalchbrenner&amp;Blunsom（2013）。众所周知，神经网络的成功应用需要良好的正则化。不幸的是，dropout Srivastava （2013） 是前馈神经网络最强大的正则化方法，但不能很好地用于 RNN。因此，RNN 的实际应用通常使用太小的模型，因为大型 RNN 往往会过度拟合。现有的正则化方法对RNNs Graves（2013）进行了相对较小的改进。在这项工作中，我们表明，如果正确使用，压差可以大大减少LSTM中的过拟合，并在三个不同的问题上对其进行评估。 此工作的代码可以在https://github.com/wojzaremba/lstm找到。 2 RELATED WORKDropout Srivastava (2013) is a recently introduced regularization method that has been very suc- cessful with feed-forward neural networks. While much work has extended dropout in various ways Wang &amp; Manning (2013); Wan et al. (2013), there has been relatively little research in applying it to RNNs. The only paper on this topic is by Bayer et al. (2013), who focuses on “marginalized dropout” Wang &amp; Manning (2013), a noiseless deterministic approximation to standard dropout. Bayer et al. (2013) claim that conventional dropout does not work well with RNNs because the re- currence amplifies noise, which in turn hurts learning. In this work, we show that this problem can be fixed by applying dropout to a certain subset of the RNNs’ connections. As a result, RNNs can now also benefit from dropout.Dropout Srivastava（2013）是一种最近引入的正则化方法，在前馈神经网络中非常成功。尽管很多工作以各种方式扩展了Dropout Wang &amp; Manning（2013）；Wan等（2013），但在RNN上应用它的研究相对较少。关于这个主题的唯一论文是Bayer等人（2013）的，他们专注于“边缘化Dropout” Wang &amp; Manning（2013），这是标准Dropout的一种无噪声确定性近似。Bayer等人（2013）认为传统的Dropout在RNN上效果不好，因为递归放大了噪声，进而影响了学习。在这项工作中，我们展示了通过将Dropout应用于RNN连接的某个子集可以解决这个问题。因此，RNN现在也可以受益于Dropout。 Independently of our work, Pham et al. (2013) developed the very same RNN regularization method and applied it to handwriting recognition. We rediscovered this method and demonstrated strong empirical results over a wide range of problems. Other work that applied dropout to LSTMs is Pachitariu &amp; Sahani (2013).独立于我们的工作，Pham等人（2013）开发了完全相同的RNN正则化方法并将其应用于手写识别。我们重新发现了这种方法，并在广泛的问题上展示了强大的实证结果。其他将Dropout应用于LSTM的工作包括Pachitariu &amp; Sahani（2013）。 There have been a number of architectural variants of the RNN that perform better on problems with long term dependencies Hochreiter &amp; Schmidhuber (1997); Graves et al. (2009); Cho et al. (2014); Jaeger et al. (2007); Koutník et al. (2014); Sundermeyer et al. (2012). In this work, we show how to correctly apply dropout to LSTMs, the most commonly-used RNN variant; this way of applying dropout is likely to work well with other RNN architectures as well. In this paper, we consider the following tasks: language modeling, speech recognition, and machine translation. Language modeling is the first task where RNNs have achieved substantial success Mikolov et al. (2010; 2011); Pascanu et al. (2013). RNNs have also been successfully used for speech recognition Robinson et al. (1996); Graves et al. (2013) and have recently been applied to machine translation, where they are used for language modeling, re-ranking, or phrase modeling Devlin et al. (2014); Kalchbrenner &amp; Blunsom (2013); Cho et al. (2014); Chow et al. (1987); Mikolov et al. (2013).已经有许多RNN的架构变体在处理长期依赖问题上表现更好： Hochreiter &amp; Schmidhuber (1997); Graves等（2009）；Cho等（2014）；Jaeger等（2007）；Koutník等（2014）；Sundermeyer等（2012）。在这项工作中，我们展示了如何正确地将dropout应用于LSTM，这是最常用的RNN变体；这种应用dropout的方法也可能适用于其他RNN架构。在本文中，我们考虑了以下任务：语言建模、语音识别和机器翻译。语言建模是RNN首次取得显著成功的任务 Mikolov等（2010；2011）；Pascanu等（2013）。RNN也已成功应用于语音识别 Robinson等（1996）；Graves等（2013），并且最近被应用于机器翻译，在那里它们被用于语言建模、重排序或短语建模 Devlin等（2014）；Kalchbrenner &amp; Blunsom（2013）；Cho等（2014）；Chow等（1987）；Mikolov等（2013）。 3 REGULARIZING RNNS WITH LSTM CELLS 使用LSTM单元对RNN进行正则化In this section we describe the deep LSTM (Section 3.1). Next, we show how to regularize them (Section 3.2), and explain why our regularization scheme works.在本节中，我们描述了深度LSTM（3.1节）。接下来，我们展示如何对它们进行正则化（3.2节），并解释我们的正则化方案为何有效。 We let subscripts denote timesteps and superscripts denote layers. All our states are n-dimensional. Let $h_t^l \\in \\mathbb{R}^n$ be a hidden state in layer$l$ in timestep $t$. Moreover, let $T_{n,m} : \\mathbb{R}^n \\to \\mathbb{R}^m$be an affine transform ($Wx + b$ for some $W$ and $b$). Let $\\odot$ be element-wise multiplication and let $h_t^0​$ be an input word vector at timestep $k$. We use the activations $h_t^L$​ to predict $y_t$​, since $L$ is the number of layers in our deep LSTM.我们用下标表示时间步长，用上标表示层次。我们所有的状态都是n维的。令$h_t^l \\in \\mathbb{R}^n$ 为时间步$t$中层$l$的隐藏状态。此外，令$T_{n,m} : \\mathbb{R}^n \\to \\mathbb{R}^m$为仿射变换（某些$W$和$b$,$Wx + b$）。令$\\odot$为逐元素乘法，并令$h_t^0$​为时间步$k$的输入词向量。我们使用激活值$h_t^L$​来预测$y_t​$，因为$L$是我们深度LSTM的层数。 3.1 LONG-SHORT TERM MEMORY UNITS 长短期记忆单元The RNN dynamics can be described using deterministic transitions from previous to current hidden states. The deterministic state transition is a functionRNN的动态可以用从先前隐藏状态到当前隐藏状态的确定性转换来描述。确定性状态转换是一个函数 RNN : $h_t^{l-1}​$, $h_{t-1}^l \\rightarrow h_t^l$ For classical RNNs, this function is given by$h_t^l = f(T_{n,n} h_t^{l-1} + T_{n,n} h_{t-1}^l), where f \\in \\{\\text{sigm, tanh}\\}$ The LSTM has complicated dynamics that allow it to easily “memorize” information for an extended number of timesteps. The “long term” memory is stored in a vector of memory cells $c_t^l \\in \\mathbb{R}^n$. Although many LSTM architectures that differ in their connectivity structure and activation functions, all LSTM architectures have explicit memory cells for storing information for long periods of time. The LSTM can decide to overwrite the memory cell, retrieve it, or keep it for the next time step. The LSTM architecture used in our experiments is given by the following equations Graves et al. (2013):LSTM具有复杂的动态，允许它轻松地“记住”多个时间步长的信息。“长期”记忆存储在记忆单元向量$c_t^l \\in \\mathbb{R}^n$中。尽管许多LSTM架构在连接结构和激活函数上有所不同，但所有LSTM架构都有明确的记忆单元用于长时间存储信息。LSTM可以决定覆盖记忆单元、检索或者在下一个时间步中保留它。我们实验中使用的LSTM架构由以下方程给出 Graves等（2013）： LSTM : $h_t^{l-1}$, $h_{t-1}^l$, $c_{t-1}^l \\rightarrow h_t^l$​, $c_t^l$ $\\left( \\begin{array}{c} i \\ f \\ o \\ g \\end{array} \\right) = \\left( \\begin{array}{c} \\text{sigm} \\ \\text{sigm} \\ \\text{sigm} \\ \\text{tanh} \\end{array} \\right) T_{2n,4n} \\left( \\begin{array}{c} h_{t}^{l-1} \\ h_{t-1}^{l} \\end{array} \\right)​$ $c_t^l = f \\odot c_{t-1}^l + i \\odot g$ $h_t^l = o \\odot \\text{tanh}(c_t^l)$In these equations, sigm and tanh are applied element-wise. Figure 1 illustrates the LSTM equations.在这些方程中，sigm和tanh逐元素应用。图1展示了LSTM方程 3.2 REGULARIZATION WITH DROPOUTThe main contribution of this paper is a recipe for applying dropout to LSTMs in a way that success-fully reduces overfitting. The main idea is to apply the dropout operator only to the non-recurrent本文的主要贡献是提供了一种将dropout应用于LSTM的方法，从而成功地减少了过拟合。主要思想是仅将dropout操作符应用于非递归连接。Figure 1: A graphical representation of LSTM memory cells used in this paper (there are minor differences in comparison to Graves (2013)).图1：本文中使用的LSTM记忆单元的图形表示（与Graves（2013）相比有细微差别）。 Figure 2: Regularized multilayer RNN. The dashed arrows indicate connections where dropout is applied, and the solid lines indicate connections where dropout is not applied.图2：正则化的多层RNN。虚线箭头表示应用了dropout的连接，实线表示未应用dropout的连接。⚠️： x 表示输入层， y 表示输出层 connections (Figure 2). The following equation describes it more precisely, where D is the dropoutoperator that sets a random subset of its argument to zero:连接（图2）。以下方程更准确地描述了这一点，其中 $D$ 是将其参数的随机子集设置为零的dropout操作符： $\\left( \\begin{array}{c} i \\ f \\ o \\ g \\end{array} \\right) = \\left( \\begin{array}{c} \\text{sigm} \\ \\text{sigm} \\ \\text{sigm} \\ \\text{tanh} \\end{array} \\right) T_{2n,4n} \\left( \\begin{array}{c} {D}(h_{t}^{l-1}) \\ h_{t-1}^{l} \\end{array} \\right)​$ $c_t^l = f \\odot c_{t-1}^l + i \\odot g$ $h_t^l = o \\odot \\text{tanh}(c_t^l)$ Our method works as follows. The dropout operator corrupts the information carried by the units,forcing them to perform their intermediate computations more robustly. At the same time, we do not want to erase all the information from the units. It is especially important that the units rememberevents that occurred many timesteps in the past. Figure 3 shows how information could flow from an event that occurred at timestep t − 2 to the prediction in timestep t + 2 in our implementation of dropout. We can see that the information is corrupted by the dropout operator exactly L + 1 times,我们的方法如下。dropout 运算符会破坏单元携带的信息，迫使它们更稳健地执行中间计算。同时，我们不想抹去单元的所有信息。特别重要的是，单元需要记住许多时间步长之前发生的事件。图3显示了在我们实现的dropout中，信息如何从时间步 $t-2$ 传递到时间步 $t+2$ 的预测。我们可以看到，信息恰好被dropout操作符破坏了 $L+1$ 次。 Figure 3: The thick line shows a typical path of information flow in the LSTM. The information is affected by dropout L + 1 times, where L is depth of network.图 3：粗线显示了 LSTM 中信息流的典型路径。信息受 L + 1 次的dropout影响，其中 L 是网络深度。 Figure 4: Some interesting samples drawn from a large regularized model conditioned on “The meaning of life is”. We have removed “unk”, “N”, “$” from the set of permissible words.图4：从一个以“The meaning of life is”为条件的大型正则化模型中抽取的一些有趣样本。我们已经从允许的单词集中移除了“unk”、“N”、“$”。 and this number is independent of the number of timesteps traversed by the information. Standard dropout perturbs the recurrent connections, which makes it difficult for the LSTM to learn to store information for long periods of time. By not using dropout on the recurrent connections, the LSTM can benefit from dropout regularization without sacrificing its valuable memorization ability.这个数字与信息经过的时间步数无关。标准的dropout会扰乱递归连接，这使得LSTM难以学习长时间存储信息。通过不在递归连接上使用dropout，LSTM可以从dropout正则化中受益，而不牺牲其宝贵的记忆能力。 4 EXPERIMENTS 实验We present results in three domains: language modeling (Section 4.1), speech recognition (Section 4.2), machine translation (Section 4.3), and image caption generation (Section 4.4).我们在三个领域中展示了结果：语言建模（第4.1节）、语音识别（第4.2节）、机器翻译（第4.3节）和图像描述生成（第4.4节）。 4.1 LANGUAGE MODELING 语言建模We conducted word-level prediction experiments on the Penn Tree Bank (PTB) dataset Marcus et al. (1993), which consists of 929k training words, 73k validation words, and 82k test words. It has 10k words in its vocabulary. We downloaded it from Tomas Mikolov’s webpage†. We trained regularized LSTMs of two sizes; these are denoted the medium LSTM and large LSTM. Both LSTMs have two layers and are unrolled for 35 steps. We initialize the hidden states to zero. We then use the final hidden states of the current minibatch as the initial hidden state of the subsequent minibatch (successive minibatches sequentially traverse the training set). The size of each minibatch is 20.我们在Penn Tree Bank (PTB)数据集上进行了词级预测实验，该数据集包括92.9万个训练词、7.3万个验证词和8.2万个测试词。其词汇表有1万个单词。我们从Tomas Mikolov的网页下载了该数据集。我们训练了两种规模的正则化LSTM；它们分别被称为中型LSTM和大型LSTM。两个LSTM都有两层，展开35步。我们将隐藏状态初始化为零。然后我们使用当前小批量的最终隐藏状态作为后续小批量的初始隐藏状态（连续的小批量依次遍历训练集）。每个小批量的大小为20。 The medium LSTM has 650 units per layer and its parameters are initialized uniformly in [−0.05, 0.05]. As described earlier, we apply 50% dropout on the non-recurrent connections. We train the LSTM for 39 epochs with a learning rate of 1, and after 6 epochs we decrease it by a factor of 1.2 after each epoch. We clip the norm of the gradients (normalized by minibatch size) at 5. Training this network takes about half a day on an NVIDIA K20 GPU.中型LSTM每层有650个单元，其参数在[−0.05, 0.05]范围内均匀初始化。如前所述，我们在非递归连接上应用50%的dropout。我们用学习率为1训练LSTM共39个周期，在第6个周期后，每个周期将学习率按1.2的因子递减。我们将梯度的范数（按小批量大小归一化）剪裁到5。训练该网络在NVIDIA K20 GPU上大约需要半天时间。 The large LSTM has 1500 units per layer and its parameters are initialized uniformly in [−0.04, 0.04]. We apply 65% dropout on the non-recurrent connections. We train the model for 55 epochs with a learning rate of 1; after 14 epochs we start to reduce the learning rate by a factor of 1.15 after each epoch. We clip the norm of the gradients (normalized by minibatch size) at 10 Mikolov et al. (2010). Training this network takes an entire day on an NVIDIA K20 GPU.大型LSTM每层有1500个单元，其参数在[−0.04, 0.04]范围内均匀初始化。我们在非递归连接上应用65%的dropout。我们用学习率为1训练模型共55个周期；在第14个周期后，每个周期开始按1.15的因子递减学习率。我们将梯度的范数（按小批量大小归一化）剪裁到10 Mikolov等（2010）。训练该网络在NVIDIA K20 GPU上需要整整一天时间。 For comparison, we trained a non-regularized network. We optimized its parameters to get the best validation performance. The lack of regularization effectively constrains size of the network, forcing us to use small network because larger networks overfit. Our best performing non-regularized LSTM has two hidden layers with 200 units per layer, and its weights are initialized uniformly in [−0.1, 0.1]. We train it for 4 epochs with a learning rate of 1 and then we decrease the learning rate by a factor of 2 after each epoch, for a total of 13 training epochs. The size of each minibatch is 20, and we unroll the network for 20 steps. Training this network takes 2-3 hours on an NVIDIA K20 GPU.为了比较，我们训练了一个未正则化的网络。我们优化其参数以获得最佳验证性能。缺乏正则化有效地限制了网络的大小，迫使我们使用小型网络，因为较大的网络会过拟合。我们表现最好的未正则化LSTM有两层隐藏层，每层200个单元，其权重在[−0.1, 0.1]范围内均匀初始化。我们用学习率为1训练了4个周期，然后每个周期将学习率按2的因子递减，总共训练13个周期。每个小批量的大小为20，我们展开网络20步。训练该网络在NVIDIA K20 GPU上需要2-3小时。 Table 1 compares previous results with our LSTMs, and Figure 4 shows samples drawn from a single large regularized LSTM.表1比较了以前的结果和我们的LSTM，图4显示了从单个大型正则化LSTM中抽取的样本。 4.2 SPEECH RECOGNITION 语音识别Deep Neural Networks have been used for acoustic modeling for over half a century (see Bourlard &amp; Morgan (1993) for a good review). Acoustic modeling is a key component in mapping acoustic signals to sequences of words, as it models $p(s_t|X)$ where $s_t$​ is the phonetic state at time $t$ and $X$ is the acoustic observation. Recent work has shown that LSTMs can achieve excellent performance on acoustic modeling Sak et al. (2014), yet relatively small LSTMs (in terms of the number of their parameters) can easily overfit the training set. A useful metric for measuring the performance of acoustic models is frame accuracy, which is measured at each sts_tst​ for all timesteps ttt. Generally, this metric correlates with the actual metric of interest, the Word Error Rate (WER).深度神经网络已经被用于声学建模超过半个世纪（参见Bourlard &amp; Morgan (1993)的良好综述）。声学建模是将声学信号映射到单词序列中的关键组成部分，因为它对p(st∣X)p(s_t|X)p(st​∣X)建模，其中sts_tst​是时间ttt的语音状态，XXX是声学观测。最近的工作表明，LSTM在声学建模上可以取得优异的性能 Sak等（2014），但相对较小的LSTM（就参数数量而言）很容易对训练集过拟合。衡量声学模型性能的一个有用指标是帧准确率，它在所有时间步长ttt处测量每个sts_tst​的准确率。通常，这个指标与实际感兴趣的指标，即单词错误率（WER）相关。 Since computing the WER involves using a language model and tuning the decoding parameters for every change in the acoustic model, we decided to focus on frame accuracy in these experiments. Table 2 shows that dropout improves the frame accuracy of the LSTM. Not surprisingly, the training frame accuracy drops due to the noise added during training, but as is often the case with dropout, this yields models that generalize better to unseen data. Note that the test set is easier than the training set, as its accuracy is higher. We report the performance of an LSTM on an internal Google Icelandic Speech dataset, which is relatively small (93k utterances), so overfitting is a great concern.由于计算WER涉及使用语言模型并调整声学模型每次变化的解码参数，我们决定在这些实验中专注于帧准确率。表2显示了dropout提高了LSTM的帧准确率。不出所料，由于训练过程中加入的噪声，训练帧准确率下降了，但与dropout经常出现的情况一样，这使得模型在未见数据上的泛化能力更强。请注意，测试集比训练集更容易，因为它的准确率更高。我们报告了LSTM在Google内部冰岛语语音数据集上的性能，该数据集相对较小（93k句子），因此过拟合是一个很大的问题。 4.3 MACHINE TRANSLATION 机器翻译We formulate a machine translation problem as a language modelling task, where an LSTM is trained to assign high probability to a correct translation of a source sentence. Thus, the LSTM is trained on concatenations of source sentences and their translations Sutskever et al. (2014) (see also Cho et al. (2014)). We compute a translation by approximating the most probable sequence of words using a simple beam search with a beam of size 12. We ran an LSTM on the WMT’14 English to French dataset, on the “selected” subset from Schwenk (2014) which has 340M French words and 304M English words. Our LSTM has 4 hidden layers, and both its layers and word embeddings have 1000 units. Its English vocabulary has 160,000 words and its French vocabulary has 80,000 words. The optimal dropout probability was 0.2. Table 3 shows the performance of an LSTM trained with and without dropout. While our LSTM does not beat the phrase-based LIUM SMT system Schwenk et al. (2011), our results show that dropout improves the translation performance of the LSTM.我们将机器翻译问题表述为一个语言建模任务，其中LSTM被训练为对源句子的正确翻译赋予高概率。因此，LSTM在源句子及其翻译的串联上进行训练 Sutskever等（2014）（另见Cho等（2014））。我们通过使用大小为12的简单束搜索来近似最可能的单词序列来计算翻译。我们在WMT’14英法数据集上的“selected”子集（来自Schwenk（2014），包含3.4亿个法语单词和3.04亿个英语单词）上运行了一个LSTM。我们的LSTM有4个隐藏层，其层和词嵌入都有1000个单元。它的英语词汇量有160,000个单词，法语词汇量有80,000个单词。最佳的dropout概率是0.2。表3显示了使用和不使用dropout训练的LSTM的性能。虽然我们的LSTM没有击败基于短语的LIUM SMT系统 Schwenk等（2011），但我们的结果表明dropout提高了LSTM的翻译性能。 4.4 IMAGE CAPTION GENERATION图像描述生成We applied the dropout variant to the image caption generation model of Vinyals et al. (2014). The image caption generation is similar to the sequence-to-sequence model of Sutskever et al. (2014), but where the input image is mapped onto a vector with a highly-accurate pre-trained convolutional neural network (Szegedy et al., 2014), which is converted into a caption with a single-layer LSTM (see Vinyals et al. (2014) for the details on the architecture). We test our dropout scheme on LSTM as the convolutional neural network is not trained on the image caption dataset because it is not large (MSCOCO (Lin et al., 2014)).我们将dropout变体应用于Vinyals等人（2014）的图像描述生成模型。图像描述生成类似于Sutskever等人（2014）的序列到序列模型，但输入图像被映射到一个具有高精度的预训练卷积神经网络（Szegedy等人，2014）的向量，该向量通过单层LSTM转换为描述（有关架构的详细信息，请参见Vinyals等人，2014）。我们在LSTM上测试了我们的dropout方案，因为卷积神经网络并未在图像描述数据集上进行训练，因为它不是很大（MSCOCO（Lin等人，2014））。 Our results are summarized in the following Table 4. In brief, dropout helps relative to not using dropout, but using an ensemble eliminates the gains attained by dropout. Thus, in this setting, the main effect of dropout is to produce a single model that is as good as an ensemble, which is a reasonable improvement given the simplicity of the technique.我们的结果总结在以下表4中。简而言之，dropout相对于不使用dropout有帮助，但使用集成方法消除了通过dropout获得的收益。因此，在这种情况下，dropout的主要作用是产生一个与集成一样好的单一模型，考虑到该技术的简单性，这是一个合理的改进。 5 CONCLUSIONWe presented a simple way of applying dropout to LSTMs that results in large performance increases on several problems in different domains. Our work makes dropout useful for RNNs, and our results suggest that our implementation of dropout could improve performance on a wide variety of applications.我们提出了一种将dropout应用于LSTM的简单方法，这在不同领域的几个问题上导致了性能的大幅提升。我们的工作使dropout对RNN有用，并且我们的结果表明，我们实现的dropout可以提高各种应用的性能。 6 ACKNOWLEDGMENTSWe wish to acknowledge Tomas Mikolov for useful comments on the first version of the paper.我们希望感谢Tomas Mikolov对论文第一版提出的有益意见。 注释1. 元素乘法元素乘法（Element-wise multiplication），也称为Hadamard乘积（Hadamard product），是对两个同形矩阵或向量的对应元素进行逐一相乘的操作，广泛应用于各种线性代数和神经网络计算中。 用符号“⊙”表示。 公式表示给定两个相同大小的矩阵或向量 $A$ 和 $B$，其元素乘法 $C$ 计算如下：$C = A \\odot B$ 其中： $A = [a_1, a_2, …, a_n]$ $B = [b_1, b_2, …, b_n]$ $C = [c_1, c_2, …, c_n]$ $c_i = a_i \\cdot b_i$示例 假设有两个向量 $A$ 和 $B$： $A=[1,2,3]$$B=[4,5,6]$ 它们的元素乘法 $C$ 为：$C = A \\odot B = [1 \\cdot 4, 2 \\cdot 5, 3 \\cdot 6] = [4, 10, 18]$ 应用场景 神经网络中的LSTM： 用于更新单元状态，如公式 $c_t = f \\odot c_{t-1} + i \\odot \\tilde{c}_t$中。 图像处理： 用于图像滤波，将滤波器应用于图像的每个像素。 数据处理： 在数据预处理中，用于按元素缩放或调整数据。 2. 公式拆解:RNNRNN : $h_t^{l-1}​$, $h_{t-1}^l \\rightarrow h_t^l$ 表明在RNN中， 隐藏状态的计算结果依赖于当前时间步的输入 $h_t$和前一时间步的隐藏状态 $h_{t-1}$。 再细化一点， 当前时间步的输入 $h_t$ 应该来源于上一层，所以是 $h_t^{l-1}​$ 前一时间步的隐藏状态 $h_{t-1}$ ，应该是同一层的前一个时间步， 所以是$h_{t-1}^l$ 该状态转移过程，如果用具体的数学公式表示，可以如下所示$h_t^l = f(T_{n,n} h_t^{l-1} + T_{n,n} h_{t-1}^l), where f \\in \\{\\text{sigm, tanh}\\}$ 3. 公式拆解:LSTM 状态更新LSTM : $h_t^{l-1}$, $h_{t-1}^l$, $c_{t-1}^l \\rightarrow h_t^l$​, $c_t^l$描述了LSTM如何通过当前层的输入向量 $h_t^{l-1}$、前一时间步的隐藏状态 $h_{t-1}^l$和单元状态 $c_{t-1}^l$ 来生成新的隐藏状态 $h_t^l$ 和单元状态 $c_t^l$。 $h_t^{l-1}$：表示第 $l−1$ 层在时间步 $t$ 的隐藏状态向量。这是第 $l$ 层的当前输入。 $h_{t-1}^l$：表示第 $l$ 层在时间步 $t−1$ 的隐藏状态向量。这是第 $l$ 层的前一个时间步的状态。 $c_{t-1}^l$：表示第 $l$ 层在时间步 $t−1$的单元状态向量。这是第 $l$ 层的前一个时间步的单元状态。 $h_t^l$：表示第 $l$ 层在时间步 $t$ 的隐藏状态向量。这是经过第 $l$ 层计算后的新状态。 $c_t^l$：表示第 $l$ 层在时间步 $t$ 的新的单元状态向量。这是更新后的单元状态。 $\\left( \\begin{array}{c} i \\ f \\ o \\ g \\end{array} \\right) = \\left( \\begin{array}{c} \\text{sigm} \\ \\text{sigm} \\ \\text{sigm} \\ \\text{tanh} \\end{array} \\right) T_{2n,4n} \\left( \\begin{array}{c} h_{t}^{l-1} \\ h_{t-1}^{l} \\end{array} \\right)​$ 描述了输入门 $i$、遗忘门 $f$、输出门 $o$ 和候选记忆单元 $g$ 的计算。这里，矩阵 $T_{2n,4n}$​ 包含了相应的权重，输入包括当前输入 $h_t^{l-1}$和前一时间步的隐藏状态 $h_{t-1}^l$​ 输入门 $i$ 和 遗忘门 $f$ 控制信息的更新和遗忘，使用$sigmoid$激活函数。 输出门 $o$ 控制输出信息，使用$sigmoid$激活函数。 候选记忆单元 $g$ 提供新的信息内容，使用$tanh$激活函数。 权重矩阵 $T_{2n,4n}$ 一个大小为 $2n \\times 4n$ 的矩阵，其中 $n$ 是隐藏状态向量的维度。将输入向量 $h_t^{l-1}$​ 和隐藏状态向量 $h_{t-1}^l$ 拼接起来（向量长度为 $2n$），并通过矩阵 $T_{2n,4n}$​ 进行线性变换，生成一个长度为 $4n$ 的输出向量,即 $i, f, o, g$ 四个部分1. 遗忘门（Forget Gate） $f_t^l = \\sigma(W_f \\cdot [h_{t-1}^l, h_t^{l-1}] + b_f)$ $[h_t^{l-1}, h_{t-1}^l]$表示将当前输入和前一时间步的隐藏状态向量拼接成一个向量。 $W_f​$ 是该拼接向量的权重矩阵。 $b_f$​ 是偏置向量。 $\\sigma$ 是$sigmoid$激活函数，输出范围在0到1之间。 假设 $n = 4$： 当前输入向量 $h_t^{l-1}$为 $[h_1​,h_2​,h_3​,h_4​]$。 前一时间步的隐藏状态 $h_{t-1}^l$ 为 $[h_5, h_6, h_7, h_8]$ 拼接后的向量为：$[h_1, h_2, h_3, h_4, h_5, h_6, h_7, h_8]$ 权重矩阵 $W_f​$ 将此向量进行线性变换，生成一个长度为 $n$ 的向量。 线性变换进行线性变换的公式为：$z_f = W_f \\cdot [h_t^{l-1}, h_{t-1}^l] + b_f$ 具体步骤： 矩阵乘法： $W_f$是一个 $n \\times 2n$ 的矩阵，拼接向量是一个长度为 $2n$ 的向量。 通过矩阵乘法，结果是一个长度为 $n$ 的向量。 加偏置： 将得到的向量与偏置向量 $b_f$ 相加，仍然是一个长度为 $n$ 的向量。 例如，假设 $W_f$​ 和 $b_f$​ 为：$W_f = \\begin{pmatrix} w_{11} &amp; w_{12} &amp; w_{13} &amp; w_{14} &amp; w_{15} &amp; w_{16} &amp; w_{17} &amp; w_{18} \\ w_{21} &amp; w_{22} &amp; w_{23} &amp; w_{24} &amp; w_{25} &amp; w_{26} &amp; w_{27} &amp; w_{28} \\ w_{31} &amp; w_{32} &amp; w_{33} &amp; w_{34} &amp; w_{35} &amp; w_{36} &amp; w_{37} &amp; w_{38} \\ w_{41} &amp; w_{42} &amp; w_{43} &amp; w_{44} &amp; w_{45} &amp; w_{46} &amp; w_{47} &amp; w_{48} \\end{pmatrix}$ 拼接向量为：$[h_1, h_2, h_3, h_4, h_5, h_6, h_7, h_8]$ 矩阵乘法：$z_f = W_f \\cdot [h_1, h_2, h_3, h_4, h_5, h_6, h_7, h_8]$ 计算每个元素：$\\begin{aligned} z_{f1} &amp;= w_{11}h_1 + w_{12}h_2 + w_{13}h_3 + w_{14}h_4 + w_{15}h_5 + w_{16}h_6 + w_{17}h_7 + w_{18}h_8 \\ z_{f2} &amp;= w_{21}h_1 + w_{22}h_2 + w_{23}h_3 + w_{24}h_4 + w_{25}h_5 + w_{26}h_6 + w_{27}h_7 + w_{28}h_8 \\ z_{f3} &amp;= w_{31}h_1 + w_{32}h_2 + w_{33}h_3 + w_{34}h_4 + w_{35}h_5 + w_{36}h_6 + w_{37}h_7 + w_{38}h_8 \\ z_{f4} &amp;= w_{41}h_1 + w_{42}h_2 + w_{43}h_3 + w_{44}h_4 + w_{45}h_5 + w_{46}h_6 + w_{47}h_7 + w_{48}h_8 \\end{aligned}$ 加偏置：$z_f = \\begin{pmatrix} z_{f1} + b_1 \\ z_{f2} + b_2 \\ z_{f3} + b_3 \\ z_{f4} + b_4 \\end{pmatrix}$ sigmoid 非线性激活通过$sigmoid$激活函数得到遗忘门的激活值：$f_t^l = \\sigma(z_f)$通过 $sigmoid$ 非线性激活函数，得到遗忘门的激活值。 2. 输入门（Input Gate）计算输入门的激活值，决定新的输入信息的哪些部分将更新单元状态： $i_t^l = \\sigma(W_i \\cdot [h_{t-1}^l, h_t^{l-1}] + b_i)$ 输入调制门（Input Modulation Gate）输入调制门产生新的候选记忆内容，通过 tanh 函数进行激活。它的数学表示为：$g_t = \\tanh(W_g \\cdot [h_{t-1}, h_t] + b_g)$ 3. 单元状态结合遗忘门和输入门的信息，更新单元状态： $c_t^l = f \\odot c_{t-1}^l + i \\odot g$ 描述了如何更新单元状态。这里，$\\odot$ 表示元素乘法（Hadamard乘积）。 遗忘门$f$决定了前一时间步的单元状态 $c_{t-1}^l$有多少被保留。遗忘门的输出值在0和1之间： 当 $f$​ 接近1时，表示大部分单元状态被保留。 当 $f$接近0时，表示大部分单元状态被遗忘。 输入门 $i$ 和候选记忆单元 $g$ 决定了多少新的信息被添加到当前单元状态 $c_t^l$。 4. 输出门计算输出门的激活值，决定隐藏状态的更新：输出门：$o_t^l = \\sigma(W_o \\cdot [h_{t-1}^l, h_t^{l-1}] + b_o)$隐藏状态：$h_t^l = o_t^l * \\tanh(c_t^l)$输出门 $o$ 控制了从单元状态 $c_t^l$ 传递到隐藏状态 $h_t^l$​ 的信息，通过$tanh$函数进行非线性变换。 LSTM通过输入门、遗忘门、输出门和候选记忆单元的协同作用，有效地捕捉序列数据中的长短期依赖关系，解决了传统RNN中梯度消失和梯度爆炸的问题。这个更新机制使得LSTM在处理长序列数据时表现出色，能够有效地保留重要信息并过滤无关信息。 5. 更新隐藏状态（Hidden State Update）结合新的单元状态和输出门的激活值，更新隐藏状态： $h_t^l = o_t^l * \\tanh(c_t^l)$ 4. 应用了dropout 的LSTM从正文中可以看出，和标准的LSTM 状态更新过程相比， 其变化只是增加了一个$D$。$D$ 是将其参数的随机子集设置为零的dropout操作符。 $\\left( \\begin{array}{c} i \\ f \\ o \\ g \\end{array} \\right) = \\left( \\begin{array}{c} \\text{sigm} \\ \\text{sigm} \\ \\text{sigm} \\ \\text{tanh} \\end{array} \\right) T_{2n,4n} \\left( \\begin{array}{c} {D}(h_{t}^{l-1}) \\ h_{t-1}^{l} \\end{array} \\right)​$ 如何理解其主要思想是仅将dropout操作符应用于非递归连接。由于： $h_t^{l-1}$：表示第 $l−1$ 层在时间步 $t$ 的隐藏状态向量。这是第 $l$ 层的当前输入。 $h_{t-1}^l$：表示第 $l$ 层在时间步 $t−1$ 的隐藏状态向量。这是第 $l$ 层的前一个时间步的状态。同一层前后时间步之间的数据流转 就是递归操作， 不同层之间的数据流转是非递归操作， 根据公式，$D$ 应用在了$h_t^{l-1}$上， 所以说$D$ 是应用在非递归连接上的操作符合","tags":["AI","神经网络","Ilya sutskever‘s 30  papers"]},{"title":"The Unreasonable Effectiveness of Recurrent Neural Networks","path":"/2472be8a/","content":"Andrej Karpathy blog:# The Unreasonable Effectiveness of Recurrent Neural Networks There’s something magical about Recurrent Neural Networks (RNNs). I still remember when I trained my first recurrent network for Image Captioning. Within a few dozen minutes of training my first baby model (with rather arbitrarily-chosen hyperparameters) started to generate very nice looking descriptions of images that were on the edge of making sense. Sometimes the ratio of how simple your model is to the quality of the results you get out of it blows past your expectations, and this was one of those times. What made this result so shocking at the time was that the common wisdom was that RNNs were supposed to be difficult to train (with more experience I’ve in fact reached the opposite conclusion). Fast forward about a year: I’m training RNNs all the time and I’ve witnessed their power and robustness many times, and yet their magical outputs still find ways of amusing me. This post is about sharing some of that magic with you.循环神经网络（RNN）有其独特的魅力。我还记得第一次训练用于图像描述生成的循环神经网络时的情景。只用了短短几十分钟，即使是随意选择的超参数，这个初步模型已经开始生成看起来非常不错的图像描述，尽管这些描述有时只是勉强合理。有时，模型的简单程度与其输出结果的质量之间的比例会远远超出预期，这次就是一个典型的例子。这次结果如此令人震惊的原因在于，当时的普遍认知是，RNN很难训练（随着经验的增加，我实际上得出了相反的结论）。时间快进大约一年：我一直在训练RNN，目睹了它们的强大和稳健，尽管如此，它们神奇的输出依然能不断带给我惊喜。这篇文章旨在与大家分享这种魔力。 We’ll train RNNs to generate text character by character and ponder the question “how is that even possible?”我们将训练循环神经网络（RNN）逐字符地生成文本，并思考这个问题：“这到底是怎么做到的？” By the way, together with this post I am also releasing code on Github that allows you to train character-level language models based on multi-layer LSTMs. You give it a large chunk of text and it will learn to generate text like it one character at a time. You can also use it to reproduce my experiments below. But we’re getting ahead of ourselves; What are RNNs anyway?顺便提一下，与这篇文章一起，我还在Github上发布了代码，这些代码可以用来训练基于多层LSTM的字符级语言模型。你只需提供一大段文本，它就会逐字符地学习生成类似的文本。你还可以使用它来重现我下面的实验。但在此之前，我们还是先回到正题上来：我们先来了解一下RNN到底是什么？ Recurrent Neural Networks 递归神经网络SequencesSequences. Depending on your background you might be wondering: _What makes Recurrent Networks so special_? A glaring limitation of Vanilla Neural Networks (and also Convolutional Networks) is that their API is too constrained: they accept a fixed-sized vector as input (e.g. an image) and produce a fixed-sized vector as output (e.g. probabilities of different classes). Not only that: These models perform this mapping using a fixed amount of computational steps (e.g. the number of layers in the model). The core reason that recurrent nets are more exciting is that they allow us to operate over _sequences_ of vectors: Sequences in the input, the output, or in the most general case both. A few examples may make this more concrete:序列。根据你的背景，你可能会问：循环神经网络有什么特别之处？一个显而易见的限制是Vanilla 神经网络（以及卷积神经网络）的API过于受限：它们接受固定大小的向量作为输入（例如，一张图片），并产生固定大小的向量作为输出（例如，不同类别的概率）。不仅如此，这些模型使用固定数量的计算步骤来完成这个映射（例如，模型中的层数）。循环神经网络更令人兴奋的核心原因在于它们允许我们对向量序列进行操作：输入中的序列，输出中的序列，或者在最一般的情况下，两者都是序列。几个例子可以让这一点更加具体： Each rectangle is a vector and arrows represent functions (e.g. matrix multiply). Input vectors are in red, output vectors are in blue and green vectors hold the RNN’s state (more on this soon). From left to right: (1) Vanilla mode of processing without RNN, from fixed-sized input to fixed-sized output (e.g. image classification). (2) Sequence output (e.g. image captioning takes an image and outputs a sentence of words). (3) Sequence input (e.g. sentiment analysis where a given sentence is classified as expressing positive or negative sentiment). (4) Sequence input and sequence output (e.g. Machine Translation: an RNN reads a sentence in English and then outputs a sentence in French). (5) Synced sequence input and output (e.g. video classification where we wish to label each frame of the video). Notice that in every case are no pre-specified constraints on the lengths sequences because the recurrent transformation (green) is fixed and can be applied as many times as we like.每个矩形代表一个向量，箭头代表函数（例如矩阵乘法）。输入向量用红色表示，输出向量用蓝色表示，绿色向量表示RNN的状态（稍后会详细说明）。从左到右依次是： (1) 普通模式的处理，没有使用RNN，从固定大小的输入到固定大小的输出（例如图像分类）。 (2) 序列输出（例如图像描述生成，输入一张图片，输出一个单词句子）。 (3) 序列输入（例如情感分析，将给定的句子分类为表达正面或负面情感）。 (4) 序列输入和序列输出（例如机器翻译：RNN读取一段英文句子，然后输出一段法文句子）。 (5) 同步的序列输入和输出（例如视频分类，我们希望对视频的每一帧进行标签）。 注意，在每种情况下，序列长度都没有预先指定的限制，因为循环变换（绿色）是固定的，可以根据需要应用多次。 As you might expect, the sequence regime of operation is much more powerful compared to fixed networks that are doomed from the get-go by a fixed number of computational steps, and hence also much more appealing for those of us who aspire to build more intelligent systems. Moreover, as we’ll see in a bit, RNNs combine the input vector with their state vector with a fixed (but learned) function to produce a new state vector. This can in programming terms be interpreted as running a fixed program with certain inputs and some internal variables. Viewed this way, RNNs essentially describe programs. In fact, it is known that RNNs are Turing-Complete in the sense that they can to simulate arbitrary programs (with proper weights). But similar to universal approximation theorems for neural nets you shouldn’t read too much into this. In fact, forget I said anything.正如你所预料的那样，相较于受限于固定计算步骤的固定网络，序列操作模式要强大得多，因此对于那些希望构建更智能系统的人来说也更具吸引力。此外，正如我们稍后会看到的，RNN通过固定（但可学习）的函数将输入向量与其状态向量结合，生成一个新的状态向量。这在编程术语中可以理解为运行一个具有特定输入和一些内部变量的固定程序。从这个角度来看，RNN本质上是在描述程序。事实上，RNN被认为是图灵完备的，这意味着它们可以模拟任意程序（在适当的权重下）。但是，与神经网络的通用近似定理类似，你不应该对此过于解读。实际上，忘掉我刚才说的话吧。 If training vanilla neural nets is optimization over functions, training recurrent nets is optimization over programs.如果说训练普通神经网络是对函数的优化，那么训练循环网络就是对程序的优化。 Sequential processing in absence of sequences. You might be thinking that having sequences as inputs or outputs could be relatively rare, but an important point to realize is that even if your inputs/outputs are fixed vectors, it is still possible to use this powerful formalism to _process_ them in a sequential manner. For instance, the figure below shows results from two very nice papers from DeepMind. On the left, an algorithm learns a recurrent network policy that steers its attention around an image; In particular, it learns to read out house numbers from left to right (Ba et al.). On the right, a recurrent network _generates_ images of digits by learning to sequentially add color to a canvas (Gregor et al.):在没有序列的情况下进行顺序处理。您可能认为将序列作为输入或输出可能相对罕见，但需要意识到的重要一点是，即使你的输入/输出是固定向量，仍然可以使用这种强大的形式主义以顺序方式处理它们。例如，下图显示了 DeepMind 的两篇非常好的论文的结果。在左边，算法学习一个循环网络策略，将其注意力引导到图像周围;特别是，它学会了从左到右读出门牌号（Ba等人）。在右边，一个循环网络通过学习依次向画布添加颜色来生成数字图像： The takeaway is that even if your data is not in form of sequences, you can still formulate and train powerful models that learn to process it sequentially. You’re learning stateful programs that process your fixed-sized data.要点是，即使你的数据不是以序列形式存在，你仍然可以设计和训练强大的模型，使其学会以顺序方式处理这些数据。你正在学习的是处理固定大小数据的有状态程序。 RNN computationRNN computation. So how do these things work? At the core, RNNs have a deceptively simple API: They accept an input vector x and give you an output vector y. However, crucially this output vector’s contents are influenced not only by the input you just fed in, but also on the entire history of inputs you’ve fed in in the past. Written as a class, the RNN’s API consists of a single step function:RNN 计算。那么这些东西是如何工作的呢？在核心上，RNN 有一个看似简单的 API：它们接受一个输入向量 x 并给你一个输出向量 y 。然而，至关重要的是，这个输出向量的内容不仅受到你刚刚输入的输入的影响，还受到你过去输入的整个输入历史的影响。RNN 的 API 编写为一个类，由一个 step 函数组成：12rnn = RNN()y = rnn.step(x) # x is an input vector, y is the RNN&#x27;s output vectorThe RNN class has some internal state that it gets to update every time step is called. In the simplest case this state consists of a single _hidden_ vector h. Here is an implementation of the step function in a Vanilla RNN:RNN 类具有一些内部状态，每次调用时 step 都会更新。在最简单的情况下，此状态由单个隐藏向量组成 h 。以下是 Vanilla RNN 中 step 函数的实现： 12345678class RNN: # ... def step(self, x): # update the hidden state self.h = np.tanh(np.dot(self.W_hh, self.h) + np.dot(self.W_xh, x)) # compute the output vector y = np.dot(self.W_hy, self.h) return y The above specifies the forward pass of a vanilla RNN. This RNN’s parameters are the three matrices W_hh, W_xh, W_hy. The hidden state self.h is initialized with the zero vector. The np.tanh function implements a non-linearity that squashes the activations to the range [-1, 1]. Notice briefly how this works: There are two terms inside of the tanh: one is based on the previous hidden state and one is based on the current input. In numpy np.dot is matrix multiplication. The two intermediates interact with addition, and then get squashed by the tanh into the new state vector. If you’re more comfortable with math notation, we can also write the hidden state update as $ℎ_𝑡=tanh⁡(𝑊_{ℎℎ}ℎ_{𝑡−1}+𝑊_{𝑥ℎ}𝑥_𝑡)$, where tanh is applied elementwise.上述内容描述了一个基础RNN的前向传播过程。这个RNN的参数是三个矩阵W_hh、W_xh和W_hy。隐藏状态self.h初始化为零向量。np.tanh函数实现了一种非线性激活函数，将激活值压缩到[-1, 1]范围内。简要说明其工作原理：tanh内部有两个项，一个基于前一个时间步隐藏状态，另一个基于当前时间步输入。在numpy中，np.dot表示矩阵乘法。这两个中间结果通过加法相互作用，然后通过tanh函数压缩为新的状态向量。如果你对数学表示法更熟悉，我们也可以将隐藏状态的更新写成 $ℎ_𝑡=tanh⁡(𝑊_{ℎℎ}ℎ_{𝑡−1}+𝑊_{𝑥ℎ}𝑥_𝑡)$，其中tanh逐元素应用。 ⚠️：numpy是Python中一个非常流行的数值计算库。np.tanh函数和np.dot函数都是numpy库中的函数。np.tanh函数用于计算元素级的双曲正切，而np.dot函数用于执行矩阵乘法。 We initialize the matrices of the RNN with random numbers and the bulk of work during training goes into finding the matrices that give rise to desirable behavior, as measured with some loss function that expresses your preference to what kinds of outputs $y$ you’d like to see in response to your input sequences $x$.我们用随机数初始化RNN的矩阵，在训练过程中，大部分工作是找到能够产生理想行为的矩阵，这通过某种损失函数来衡量，该损失函数表达了你对输入序列$x$对应输出$y$的期望。 Going deepGoing deep. RNNs are neural networks and everything works monotonically better (if done right) if you put on your deep learning hat and start stacking models up like pancakes. For instance, we can form a 2-layer recurrent network as follows:深入研究。RNN是神经网络的一种，如果方法得当，采用深度学习的方法并像叠煎饼一样将模型堆叠起来，一切都会单调地变得更好。例如，我们可以如下构建一个两层的循环神经网络：12y1 = rnn1.step(x)y = rnn2.step(y1) In other words we have two separate RNNs: One RNN is receiving the input vectors and the second RNN is receiving the output of the first RNN as its input. Except neither of these RNNs know or care - it’s all just vectors coming in and going out, and some gradients flowing through each module during backpropagation.换句话说，我们有两个独立的 RNN：一个 RNN 接收输入向量，第二个 RNN 接收第一个 RNN 的输出作为其输入。除了这些 RNN 都不知道或不关心之外——它们都只是进出的向量，以及在反向传播过程中流过每个模块的一些梯度。 Getting fancyGetting fancy. I’d like to briefly mention that in practice most of us use a slightly different formulation than what I presented above called a _Long Short-Term Memory_ (LSTM) network. The LSTM is a particular type of recurrent network that works slightly better in practice, owing to its more powerful update equation and some appealing backpropagation dynamics. I won’t go into details, but everything I’ve said about RNNs stays exactly the same, except the mathematical form for computing the update (the line self.h = ... ) gets a little more complicated. From here on I will use the terms “RNN/LSTM” interchangeably but all experiments in this post use an LSTM.更复杂的模型。在实践中，我们大多数人使用的公式与我上面提到的稍有不同，被称为长短期记忆网络（LSTM）。LSTM是一种特定类型的循环神经网络，实际上效果更好，因为它具有更强大的更新方程和一些更具吸引力的反向传播动态。我不会深入讨论细节，但我所说的关于RNN的一切都完全相同，除了计算更新的数学形式（即self.h = …这一行）变得稍微复杂了一些。从现在开始，我会交替使用“RNN/LSTM”这两个术语，但本文中的所有实验都使用LSTM。 Character-Level Language Models字符级语言模型 Okay, so we have an idea about what RNNs are, why they are super exciting, and how they work. We’ll now ground this in a fun application: We’ll train RNN character-level language models. That is, we’ll give the RNN a huge chunk of text and ask it to model the probability distribution of the next character in the sequence given a sequence of previous characters. This will then allow us to generate new text one character at a time.好的，所以我们已经对RNN是什么、为什么它们非常令人兴奋以及它们如何工作有了一定的了解。现在，我们将把这些知识应用到一个有趣的实际应用中：我们将训练RNN字符级别的语言模型。也就是说，我们会给RNN提供一大段文本，并让它根据前面字符的序列来建模下一个字符的概率分布。这样一来，我们就可以一次生成一个字符的新文本。 As a working example, suppose we only had a vocabulary of four possible letters “helo”, and wanted to train an RNN on the training sequence “hello”. This training sequence is in fact a source of 4 separate training examples: 1. The probability of “e” should be likely given the context of “h”, 2. “l” should be likely in the context of “he”, 3. “l” should also be likely given the context of “hel”, and finally 4. “o” should be likely given the context of “hell”.作为一个实际例子，假设我们只有四个可能的字母“helo”的词汇表，并且想要在训练序列“hello”上训练一个RNN。这个训练序列实际上是四个独立的训练示例的来源： 在“h”的上下文中，“e”的概率应该很大。 在“he”的上下文中，“l”的概率应该很大。 在“hel”的上下文中，“l”的概率也应该很大。 最后，在“hell”的上下文中，“o”的概率应该很大。 Concretely, we will encode each character into a vector using 1-of-k encoding (i.e. all zero except for a single one at the index of the character in the vocabulary), and feed them into the RNN one at a time with the step function. We will then observe a sequence of 4-dimensional output vectors (one dimension per character), which we interpret as the confidence the RNN currently assigns to each character coming next in the sequence. Here’s a diagram:具体来说，我们将使用1-of-k编码将每个字符编码成一个向量（即，除了在词汇表中字符索引处为1，其余全为0），然后用step函数将它们逐一输入RNN。随后，我们会得到一系列4维输出向量（每个字符一个维度），我们将这些输出向量解释为RNN当前对序列中下一个字符的置信度。以下是一个示意图： An example RNN with 4-dimensional input and output layers, and a hidden layer of 3 units (neurons). This diagram shows the activations in the forward pass when the RNN is fed the characters “hell” as input. The output layer contains confidences the RNN assigns for the next character (vocabulary is “h,e,l,o”); We want the green numbers to be high and red numbers to be low.具有 4 维输入和输出层的示例 RNN，以及 3 个单元（神经元）的隐藏层。此图显示了将字符“hell”作为输入馈送 RNN 时前向传递中的激活。输出层包含 RNN 为下一个字符分配的置信度（词汇为“h，e，l，o”）;我们希望绿色数字高，红色数字低。 ⚠️： W_xh 指输入层和隐藏层之间的权重矩阵， W_hh 指隐藏层之间的权重矩阵， W_hy 指隐藏层和输出层之间的权重矩阵 For example, we see that in the first time step when the RNN saw the character “h” it assigned confidence of 1.0 to the next letter being “h”, 2.2 to letter “e”, -3.0 to “l”, and 4.1 to “o”. Since in our training data (the string “hello”) the next correct character is “e”, we would like to increase its confidence (green) and decrease the confidence of all other letters (red). Similarly, we have a desired target character at every one of the 4 time steps that we’d like the network to assign a greater confidence to. Since the RNN consists entirely of differentiable operations we can run the backpropagation algorithm (this is just a recursive application of the chain rule from calculus) to figure out in what direction we should adjust every one of its weights to increase the scores of the correct targets (green bold numbers). We can then perform a _parameter update_, which nudges every weight a tiny amount in this gradient direction. If we were to feed the same inputs to the RNN after the parameter update we would find that the scores of the correct characters (e.g. “e” in the first time step) would be slightly higher (e.g. 2.3 instead of 2.2), and the scores of incorrect characters would be slightly lower. We then repeat this process over and over many times until the network converges and its predictions are eventually consistent with the training data in that correct characters are always predicted next.例如，我们看到在第一个时间步中，当RNN看到字符“h”时，它对下一个字符的置信度分配为：字符“h”是1.0，字符“e”是2.2，字符“l”是-3.0，字符“o”是4.1。由于在我们的训练数据（字符串“hello”）中，下一个正确字符是“e”，我们希望增加“e”的置信度（用绿色表示），并降低所有其他字符的置信度（用红色表示）。类似地，在每一个时间步上，我们都有一个期望的目标字符，希望网络能对其分配更高的置信度。由于RNN完全由可微操作组成，我们可以运行反向传播算法（这只是微积分中链式法则的递归应用）来确定应调整每个权重的方向，以提高正确目标的得分（绿色加粗数字）。然后，我们可以执行参数更新，将每个权重在该梯度方向上微调一个小量。如果在参数更新后再次将相同的输入提供给RNN，我们会发现正确字符的得分（例如，第一个时间步中的“e”）会略有提高（例如，从2.2提高到2.3），而错误字符的得分会略有降低。然后，我们反复进行这个过程多次，直到网络收敛，其预测最终与训练数据一致，即总是预测出正确的下一个字符。 ⚠️：图中output 层 数字并不是置信度，而是logits, 这些logits并不直接表示概率/置信度,要将这些logits转化为概率（置信度），我们通常使用Softmax函数。 A more technical explanation is that we use the standard Softmax classifier (also commonly referred to as the cross-entropy loss) on every output vector simultaneously. The RNN is trained with mini-batch Stochastic Gradient Descent and I like to use RMSProp or Adam (per-parameter adaptive learning rate methods) to stablilize the updates.更技术性的解释是，我们在每个输出向量上 同时使用标准的Softmax分类器（也常被称为交叉熵损失）。RNN使用小批量随机梯度下降法进行训练，我喜欢使用RMSProp或Adam（每个参数的自适应学习率方法）来稳定更新。 Notice also that the first time the character “l” is input, the target is “l”, but the second time the target is “o”. The RNN therefore cannot rely on the input alone and must use its recurrent connection to keep track of the context to achieve this task.另请注意，第一次输入字符“l”时，目标是“l”，但第二次目标是“o”。因此，RNN 不能单独依赖输入，必须使用其循环连接来跟踪上下文以实现此任务。 At test time, we feed a character into the RNN and get a distribution over what characters are likely to come next. We sample from this distribution, and feed it right back in to get the next letter. Repeat this process and you’re sampling text! Lets now train an RNN on different datasets and see what happens.在测试时，我们将一个字符输入RNN，并获得下一个字符可能出现的概率分布。我们从这个分布中采样，并将采样得到的字符再次输入RNN以获取下一个字符。重复这个过程，就可以生成文本了！现在，让我们在不同的数据集上训练一个RNN，看看会发生什么。 To further clarify, for educational purposes I also wrote a minimal character-level RNN language model in Python/numpy. It is only about 100 lines long and hopefully it gives a concise, concrete and useful summary of the above if you’re better at reading code than text. We’ll now dive into example results, produced with the much more efficient Lua/Torch codebase.为了进一步说明，我还用Python和numpy编写了一个最小的字符级RNN语言模型。它只有大约100行代码，希望能为你提供一个简洁、具体且有用的总结，如果你更擅长阅读代码而不是文字。现在，我们将深入探讨使用更加高效的Lua/Torch代码库生成的示例结果。 Fun with RNNsAll 5 example character models below were trained with the code I’m releasing on Github. The input in each case is a single file with some text, and we’re training an RNN to predict the next character in the sequence.下面的所有 5 个示例字符模型都是使用我在 Github 上发布的代码训练的。每种情况下的输入都是一个包含一些文本的单个文件，我们正在训练一个 RNN 来预测序列中的下一个字符。 Paul Graham generator 保罗·格雷厄姆发电机Lets first try a small dataset of English as a sanity check. My favorite fun dataset is the concatenation of Paul Graham’s essays. The basic idea is that there’s a lot of wisdom in these essays, but unfortunately Paul Graham is a relatively slow generator. Wouldn’t it be great if we could sample startup wisdom on demand? That’s where an RNN comes in.让我们首先尝试一个小型的英文数据集来进行基本检查。我最喜欢的有趣数据集是保罗·格雷厄姆（Paul Graham）的文章合集。基本想法是，这些文章中有很多智慧，但遗憾的是，保罗·格雷厄姆的写作速度相对较慢。如果我们能按需采样创业智慧，那不是很棒吗？这正是RNN的用武之地。 Concatenating all pg essays over the last ~5 years we get approximately 1MB text file, or about 1 million characters (this is considered a very small dataset by the way). _Technical:_ Lets train a 2-layer LSTM with 512 hidden nodes (approx. 3.5 million parameters), and with dropout of 0.5 after each layer. We’ll train with batches of 100 examples and truncated backpropagation through time of length 100 characters. With these settings one batch on a TITAN Z GPU takes about 0.46 seconds (this can be cut in half with 50 character BPTT at negligible cost in performance). Without further ado, lets see a sample from the RNN:将过去大约5年间的所有保罗·格雷厄姆的文章合并起来，我们得到了一个大约1MB的文本文件，约100万个字符（顺便说一下，这被认为是一个非常小的数据集）。技术细节：让我们训练一个具有2层、每层512个隐藏节点的LSTM（大约350万个参数），并在每层之后使用0.5的dropout。我们将使用100个样本的批次和长度为100字符的截断时间反向传播进行训练。在这些设置下，在TITAN Z GPU上处理一个批次大约需要0.46秒（使用50字符的截断时间反向传播，几乎不会影响性能，可以将时间减半）。事不宜迟，让我们看看RNN生成的一个样本： _“The surprised in investors weren’t going to raise money. I’m not the company with the time there are all interesting quickly, don’t have to get off the same programmers. There’s a super-angel round fundraising, why do you can do. If you have a different physical investment are become in people who reduced in a startup with the way to argument the acquirer could see them just that you’re also the founders will part of users’ affords that and an alternation to the idea. [2] Don’t work at first member to see the way kids will seem in advance of a bad successful startup. And if you have to act the big company too.”__“投资者的惊讶是，他们并不打算筹集资金。我不是那个有时间的公司，有趣的事情很快就会出现，不需要让相同的程序员离开。有一个超级天使轮的融资，你为什么要这样做。如果你有不同的实体投资，会成为那些在初创公司里减少的人中争论的方式，收购者可能会看到他们只是创始人将成为用户努力的一部分，这是对想法的一种替代。[2] 一开始不要在成员身上工作，看孩子们将如何提前在一个失败的成功初创公司中表现出来。而且，如果你必须行动，那么大公司也一样。”_ Okay, clearly the above is unfortunately not going to replace Paul Graham anytime soon, but remember that the RNN had to learn English completely from scratch and with a small dataset (including where you put commas, apostrophes and spaces). I also like that it learns to support its own arguments (e.g. [2], above). Sometimes it says something that offers a glimmer of insight, such as _“a company is a meeting to think to investors”_. Here’s a link to 50K character sample if you’d like to see more.好的，很明显，以上内容暂时还无法替代保罗·格雷厄姆，但请记住，RNN必须从零开始学习英语，而且是用一个小数据集（包括逗号、撇号和空格的位置）。我也喜欢它学会了支持自己的论点（例如，上文中的[2]）。有时，它会说出一些略带启发性的话，比如“a company is a meeting to think to investors”（公司是与投资者思考的会议）。如果你想查看更多，这里有一个50K字符的样本链接。 Temperature. We can also play with the temperature of the Softmax during sampling. Decreasing the temperature from 1 to some lower number (e.g. 0.5) makes the RNN more confident, but also more conservative in its samples. Conversely, higher temperatures will give more diversity but at cost of more mistakes (e.g. spelling mistakes, etc). In particular, setting temperature very near zero will give the most likely thing that Paul Graham might say:温度。我们也可以在采样过程中调整Softmax的温度。将温度从1降低到某个较低的数值（例如0.5），会使RNN更有信心，但也更保守于其采样结果。相反，较高的温度会带来更多的多样性，但代价是会有更多的错误（例如拼写错误等）。特别是，将温度设置得非常接近零，会产生最有可能是保罗·格雷厄姆会说的话： _“is that they were all the same thing that was a startup is that they were all the same thing that was a startup is that they were all the same thing that was a startup is that they were all the same”“他们都是一样的，创业公司是，他们都是创业公司，他们都是一样的创业公司，他们都是一样的，创业公司是一样的”_ looks like we’ve reached an infinite loop about startups.看起来我们已经达到了一个关于初创公司的无限循环。 Shakespeare 莎士比亚It looks like we can learn to spell English words. But how about if there is more structure and style in the data? To examine this I downloaded all the works of Shakespeare and concatenated them into a single (4.4MB) file. We can now afford to train a larger network, in this case lets try a 3-layer RNN with 512 hidden nodes on each layer. After we train the network for a few hours we obtain samples such as:看起来我们可以学会拼写英语单词。但如果数据中有更多的结构和风格呢？为此，我下载了莎士比亚的所有作品，并将它们合并成一个单一的（4.4MB）文件。我们现在有能力训练一个更大的网络，在这种情况下，让我们尝试一个3层的RNN，每层有512个隐藏节点。经过几个小时的训练，我们得到如下样本：123456789101112131415161718192021222324PANDARUS:Alas, I think he shall be come approached and the dayWhen little srain would be attain&#x27;d into being never fed,And who is but a chain and subjects of his death,I should not sleep.Second Senator:They are away this miseries, produced upon my soul,Breaking and strongly should be buried, when I perishThe earth and thoughts of many states.DUKE VINCENTIO:Well, your wit is in the care of side and that.Second Lord:They would be ruled after this chamber, andmy fair nues begun out of the fact, to be conveyed,Whose noble souls I&#x27;ll have the heart of the wars.Clown:Come, sir, I will make did behold your worship.VIOLA:I&#x27;ll drink it. Remember, all the RNN knows are characters, so in particular it samples both speaker’s names and the contents. Sometimes we also get relatively extented monologue passages, such as:请记住，RNN所知道的只有字符，因此它既采样说话者的名字，也采样内容。有时我们还会得到相对较长的独白段落，例如：12345678910111213141516171819VIOLA:Why, Salisbury must find his flesh and thoughtThat which I am not aps, not a man and in fire,To show the reining of the raven and the warsTo grace my hand reproach within, and not a fair are hand,That Caesar and my goodly father&#x27;s world;When I was heaven of presence and our fleets,We spare with hours, but cut thy council I am great,Murdered and by thy master&#x27;s ready thereMy power to give thee but so much as hell:Some service in the noble bondman here,Would show him to her wine.KING LEAR:O, if you were a feeble sight, the courtesy of your law,Your sight and several breath, will wear the godsWith his heads, and my hands are wonder&#x27;d at the deeds,So drop upon your lordship&#x27;s head, and your opinionShall be against your honour. I can barely recognize these samples from actual Shakespeare :) If you like Shakespeare, you might appreciate this 100,000 character sample. Of course, you can also generate an infinite amount of your own samples at different temperatures with the provided code.我几乎无法辨认这些样本是否真的是莎士比亚的作品 :) 如果你喜欢莎士比亚，你可能会喜欢这个10万字符的样本。当然，你也可以使用提供的代码在不同温度下生成无限量的样本。 Wikipedia 维基百科We saw that the LSTM can learn to spell words and copy general syntactic structures. Lets further increase the difficulty and train on structured markdown. In particular, lets take the Hutter Prize 100MB dataset of raw Wikipedia and train an LSTM. Following Graves et al., I used the first 96MB for training, the rest for validation and ran a few models overnight. We can now sample Wikipedia articles! Below are a few fun excerpts. First, some basic markdown output:我们已经看到LSTM可以学会拼写单词和复制一般的句法结构。让我们进一步增加难度，训练在结构化的Markdown上。特别是，让我们使用Hutter Prize的100MB原始维基百科数据集来训练一个LSTM。按照Graves等人的方法，我使用前96MB进行训练，剩余的用于验证，并在一夜之间运行了几个模型。现在我们可以采样生成维基百科文章了！以下是一些有趣的摘录。首先，是一些基本的Markdown输出：1234567891011121314151617Naturalism and decision for the majority of Arab countries&#x27; capitalide was groundedby the Irish language by [[John Clair]], [[An Imperial Japanese Revolt]], associated with Guangzham&#x27;s sovereignty. His generals were the powerful ruler of the Portugal in the [[Protestant Immineners]], which could be said to be directly in Cantonese Communication, which followed a ceremony and set inspired prison, training. The emperor travelled back to [[Antioch, Perth, October 25|21]] to note, the Kingdom of Costa Rica, unsuccessful fashioned the [[Thrales]], [[Cynth&#x27;s Dajoard]], known in western [[Scotland]], near Italy to the conquest of India with the conflict. Copyright was the succession of independence in the slop of Syrian influence that was a famous German movement based on a more popular servicious, non-doctrinal and sexual power post. Many governments recognize the military housing of the [[Civil Liberalization and Infantry Resolution 265 National Party in Hungary]], that is sympathetic to be to the [[Punjab Resolution]](PJS)[http://www.humah.yahoo.com/guardian.cfm/7754800786d17551963s89.htm Official economics Adjoint for the Nazism, Montgomery was swear to advance to the resources for those Socialism&#x27;s rule, was starting to signing a major tripad of aid exile.]] In case you were wondering, the yahoo url above doesn’t actually exist, the model just hallucinated it. Also, note that the model learns to open and close the parenthesis correctly. There’s also quite a lot of structured markdown that the model learns, for example sometimes it creates headings, lists, etc.:如果你在好奇，上述的Yahoo网址实际上并不存在，这是模型臆想出来的。此外，请注意，模型学会了正确地打开和关闭括号。模型还学习了大量的结构化Markdown，例如，有时它会创建标题、列表等内容：1234567891011121314151617181920&#123; &#123; cite journal | id=Cerling Nonforest Department|format=Newlymeslated|none &#125; &#125;&#x27;&#x27;www.e-complete&#x27;&#x27;.&#x27;&#x27;&#x27;See also&#x27;&#x27;&#x27;: [[List of ethical consent processing]]== See also ==*[[Iender dome of the ED]]*[[Anti-autism]]===[[Religion|Religion]]===*[[French Writings]]*[[Maria]]*[[Revelation]]*[[Mount Agamul]]== External links==* [http://www.biblegateway.nih.gov/entrepre/ Website of the World Festival. The labour of India-county defeats at the Ripper of California Road.]==External links==* [http://www.romanology.com/ Constitution of the Netherlands and Hispanic Competition for Bilabial and Commonwealth Industry (Republican Constitution of the Extent of the Netherlands)]Sometimes the model snaps into a mode of generating random but valid XML:有时，模型会进入生成随机但有效的 XML 的模式：123456789101112131415&lt;page&gt; &lt;title&gt;Antichrist&lt;/title&gt; &lt;id&gt;865&lt;/id&gt; &lt;revision&gt; &lt;id&gt;15900676&lt;/id&gt; &lt;timestamp&gt;2002-08-03T18:14:12Z&lt;/timestamp&gt; &lt;contributor&gt; &lt;username&gt;Paris&lt;/username&gt; &lt;id&gt;23&lt;/id&gt; &lt;/contributor&gt; &lt;minor /&gt; &lt;comment&gt;Automated conversion&lt;/comment&gt; &lt;text xml:space=&quot;preserve&quot;&gt;#REDIRECT [[Christianity]]&lt;/text&gt; &lt;/revision&gt;&lt;/page&gt; The model completely makes up the timestamp, id, and so on. Also, note that it closes the correct tags appropriately and in the correct nested order. Here are 100,000 characters of sampled wikipedia if you’re interested to see more.该模型完全由时间戳、id 等组成。另外，请注意，它正确地关闭了标签，并且按照正确的嵌套顺序。这里有 100,000 个字符的样本维基百科，如果您有兴趣查看更多。 Algebraic Geometry (Latex) 代数几何（Latex）The results above suggest that the model is actually quite good at learning complex syntactic structures. Impressed by these results, my labmate (Justin Johnson) and I decided to push even further into structured territories and got a hold of this book on algebraic stacks/geometry. We downloaded the raw Latex source file (a 16MB file) and trained a multilayer LSTM. Amazingly, the resulting sampled Latex _almost_ compiles. We had to step in and fix a few issues manually but then you get plausible looking math, it’s quite astonishing:上述结果表明，模型在学习复杂句法结构方面实际上相当不错。这些结果给我留下了深刻的印象，我的实验室同事Justin Johnson和我决定进一步探索结构化领域，并找到了一本关于代数叠/几何的书。我们下载了原始的Latex源文件（一个16MB的文件）并训练了一个多层LSTM。令人惊讶的是，生成的Latex几乎可以编译。我们不得不手动修复一些问题，但最终得到了看起来很合理的数学表达，这真是令人惊叹：Sampled (fake) algebraic geometry. Here’s the actual pdf.采样（假）代数几何。这是实际的pdf。 Here’s another sample: 下面是另一个示例：More hallucinated algebraic geometry. Nice try on the diagram (right).更多幻觉的代数几何。不错的尝试图（右）。 As you can see above, sometimes the model tries to generate latex diagrams, but clearly it hasn’t really figured them out. I also like the part where it chooses to skip a proof (_“Proof omitted.”_, top left). Of course, keep in mind that latex has a relatively difficult structured syntactic format that I haven’t even fully mastered myself. For instance, here is a raw sample from the model (unedited):正如你在上面看到的，有时模型尝试生成Latex图表，但显然它还没有真正掌握这种技能。我也喜欢它选择跳过证明的部分（“Proof omitted.”，左上角）。当然，请记住，Latex有一个相对复杂的结构化句法格式，我自己都还没有完全掌握。例如，下面是模型生成的一个原始样本（未编辑）：123456789101112131415\\begin&#123;proof&#125;We may assume that $\\mathcal&#123;I&#125;$ is an abelian sheaf on $\\mathcal&#123;C&#125;$.\\item Given a morphism $\\Delta : \\mathcal&#123;F&#125; \\to \\mathcal&#123;I&#125;$is an injective and let $\\mathfrak q$ be an abelian sheaf on $X$.Let $\\mathcal&#123;F&#125;$ be a fibered complex. Let $\\mathcal&#123;F&#125;$ be a category.\\begin&#123;enumerate&#125;\\item \\hyperref[setain-construction-phantom]&#123;Lemma&#125;\\label&#123;lemma-characterize-quasi-finite&#125;Let $\\mathcal&#123;F&#125;$ be an abelian quasi-coherent sheaf on $\\mathcal&#123;C&#125;$.Let $\\mathcal&#123;F&#125;$ be a coherent $\\mathcal&#123;O&#125;_X$-module. Then$\\mathcal&#123;F&#125;$ is an abelian catenary over $\\mathcal&#123;C&#125;$.\\item The following are equivalent\\begin&#123;enumerate&#125;\\item $\\mathcal&#123;F&#125;$ is an $\\mathcal&#123;O&#125;_X$-module.\\end&#123;lemma&#125; This sample from a relatively decent model illustrates a few common mistakes. For example, the model opens a \\begin&#123;proof&#125; environment but then ends it with a \\end&#123;lemma&#125;. This is an example of a problem we’d have to fix manually, and is likely due to the fact that the dependency is too long-term: By the time the model is done with the proof it has forgotten whether it was doing a proof or a lemma. Similarly, it opens an \\begin&#123;enumerate&#125; but then forgets to close it. We observed that these became less common with larger/better models, but nonetheless, these are the kinds of mistakes that come up.这个来自相对不错模型的样本展示了一些常见的错误。例如，模型打开了一个 \\begin{proof} 环境，但随后却以 \\end{lemma} 结束。这是一个我们必须手动修复的问题的例子，可能是由于依赖关系过于长期：到模型完成证明时，它已经忘记了自己是在进行证明还是引理。类似地，它打开了一个 \\begin{enumerate}，但随后忘记了关闭它。我们注意到，这些错误在较大/更好的模型中变得不那么常见，但这些都是可能出现的错误类型。 Linux Source Code Linux 源代码I wanted to push structured data to its limit, so for the final challenge I decided to use code. In particular, I took all the source and header files found in the Linux repo on Github, concatenated all of them in a single giant file (474MB of C code) (I was originally going to train only on the kernel but that by itself is only ~16MB). Then I trained several as-large-as-fits-on-my-GPU 3-layer LSTMs over a period of a few days. These models have about 10 million parameters, which is still on the lower end for RNN models. The results are superfun:我想将结构化数据推向极限，因此在最后的挑战中我决定使用代码。具体来说，我收集了Github上Linux仓库中的所有源文件和头文件，将它们合并成一个巨大的文件（474MB的C代码）（我本来打算只训练内核代码，但它本身只有大约16MB）。然后，我在几天内训练了多个尽可能适应GPU容量的三层LSTM模型。这些模型大约有1000万个参数，这在RNN模型中仍然算是较少的。结果非常有趣：1234567891011121314151617181920212223242526272829303132/* * Increment the size file of the new incorrect UI_FILTER group information * of the size generatively. */static int indicate_policy(void)&#123; int error; if (fd == MARN_EPT) &#123; /* * The kernel blank will coeld it to userspace. */ if (ss-&gt;segment &lt; mem_total) unblock_graph_and_set_blocked(); else ret = 1; goto bail; &#125; segaddr = in_SB(in.addr); selector = seg / 16; setup_works = true; for (i = 0; i &lt; blocks; i++) &#123; seq = buf[i++]; bpf = bd-&gt;bd.next + i * search; if (fd) &#123; current = blocked; &#125; &#125; rw-&gt;name = &quot;Getjbbregs&quot;; bprm_self_clearl(&amp;iv-&gt;version); regs-&gt;new = blocks[(BPF_STATS &lt;&lt; info-&gt;historidac)] | PFMR_CLOBATHINC_SECONDS &lt;&lt; 12; return segtable;&#125;The code looks really quite great overall. Of course, I don’t think it compiles but when you scroll through the generate code it feels very much like a giant C code base. Notice that the RNN peppers its code with comments here and there at random. It is also very good at making very few syntactic errors. For example, it uses strings properly, pointer notation, etc. It also opens and closes brackets { correctly and learns to indent its code very well. A common error is that it can’t keep track of variable names: It often uses undefined variables (e.g. rw above), declares variables it never uses (e.g. int error), or returns non-existing variables. Lets see a few more examples. Here’s another snippet that shows a wider array of operations that the RNN learns: 总体来说，这些代码看起来非常不错。当然，我不认为它能编译，但当你滚动查看生成的代码时，它确实给人一种巨大的C代码库的感觉。注意，RNN会随机在代码中插入注释，并且在语法错误方面表现得非常出色。例如，它能正确使用字符串、指针符号等，还能正确地打开和关闭大括号{}，并很好地学习代码缩进。一个常见的错误是它无法跟踪变量名：它经常使用未定义的变量（例如上面的rw），声明从未使用的变量（例如int error），或者返回不存在的变量。让我们再看一些例子。下面是另一个代码片段，展示了RNN学到的更广泛的操作： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * If this error is set, we will need anything right after that BSD. */static void action_new_function(struct s_stat_info *wb)&#123; unsigned long flags; int lel_idx_bit = e-&gt;edd, *sys &amp; ~((unsigned long) *FIRST_COMPAT); buf[0] = 0xFFFFFFFF &amp; (bit &lt;&lt; 4); min(inc, slist-&gt;bytes); printk(KERN_WARNING &quot;Memory allocated %02x/%02x, &quot; &quot;original MLL instead &quot;), min(min(multi_run - s-&gt;len, max) * num_data_in), frame_pos, sz + first_seg); div_u64_w(val, inb_p); spin_unlock(&amp;disk-&gt;queue_lock); mutex_unlock(&amp;s-&gt;sock-&gt;mutex); mutex_unlock(&amp;func-&gt;mutex); return disassemble(info-&gt;pending_bh);&#125;static void num_serial_settings(struct tty_struct *tty)&#123; if (tty == tty) disable_single_st_p(dev); pci_disable_spool(port); return 0;&#125;static void do_command(struct seq_file *m, void *v)&#123; int column = 32 &lt;&lt; (cmd[2] &amp; 0x80); if (state) cmd = (int)(int_state ^ (in_8(&amp;ch-&gt;ch_flags) &amp; Cmd) ? 2 : 1); else seq = 1; for (i = 0; i &lt; 16; i++) &#123; if (k &amp; (1 &lt;&lt; 1)) pipe = (in_use &amp; UMXTHREAD_UNCCA) + ((count &amp; 0x00000000fffffff8) &amp; 0x000000f) &lt;&lt; 8; if (count == 0) sub(pid, ppc_md.kexec_handle, 0x20000000); pipe_set_bytes(i, 0); &#125; /* Free our user pages pointer to place camera if all dash */ subsystem_info = &amp;of_changes[PAGE_SIZE]; rek_controls(offset, idx, &amp;soffset); /* Now we want to deliberately put it to device */ control_check_polarity(&amp;context, val, 0); for (i = 0; i &lt; COUNTER; i++) seq_puts(s, &quot;policy &quot;);&#125; Notice that in the second function the model compares tty == tty, which is vacuously true. On the other hand, at least the variable tty exists in the scope this time! In the last function, notice that the code does not return anything, which happens to be correct since the function signature is void. However, the first two functions were also declared void and did return values. This is again a form of a common mistake due to long-term interactions.注意在第二个函数中，模型比较了tty == tty，这是显然为真的。另一方面，至少这次变量tty存在于作用域中！在最后一个函数中，注意代码没有返回任何东西，这正好是正确的，因为函数签名是void。然而，前两个函数也声明为void，但却返回了值。这再次是一种由于长时间交互而导致的常见错误形式。 Sometimes the model decides that it’s time to sample a new file. This is usually a very amusing part: The model first recites the GNU license character by character, samples a few includes, generates some macros and then dives into the code:有时，模型会决定是时候采样一个新文件了。这通常是非常有趣的部分：模型首先逐字符地背诵GNU许可证，采样几个include语句，生成一些宏，然后深入到代码中：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/* * Copyright (c) 2006-2010, Intel Mobile Communications. All rights reserved. * * This program is free software; you can redistribute it and/or modify it * under the terms of the GNU General Public License version 2 as published by * the Free Software Foundation. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program; if not, write to the Free Software Foundation, * Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */#include &lt;linux/kexec.h&gt;#include &lt;linux/errno.h&gt;#include &lt;linux/io.h&gt;#include &lt;linux/platform_device.h&gt;#include &lt;linux/multi.h&gt;#include &lt;linux/ckevent.h&gt;#include &lt;asm/io.h&gt;#include &lt;asm/prom.h&gt;#include &lt;asm/e820.h&gt;#include &lt;asm/system_info.h&gt;#include &lt;asm/setew.h&gt;#include &lt;asm/pgproto.h&gt;#define REG_PG vesa_slot_addr_pack#define PFM_NOCOMP AFSR(0, load)#define STACK_DDR(type) (func)#define SWAP_ALLOCATE(nr) (e)#define emulate_sigs() arch_get_unaligned_child()#define access_rw(TST) asm volatile(&quot;movd %%esp, %0, %3&quot; : : &quot;r&quot; (0)); \\ if (__type &amp; DO_READ)static void stat_PC_SEC __read_mostly offsetof(struct seq_argsqueue, \\ pC&gt;[1]);static voidos_prefix(unsigned long sys)&#123;#ifdef CONFIG_PREEMPT PUT_PARAM_RAID(2, sel) = get_state_state(); set_pid_sum((unsigned long)state, current_state_str(), (unsigned long)-1-&gt;lr_full; low;&#125;There are too many fun parts to cover- I could probably write an entire blog post on just this part. I’ll cut it short for now, but here is 1MB of sampled Linux code for your viewing pleasure.有太多有趣的部分要涵盖 - 我可能会写一整篇关于这部分的博客文章。我现在会缩短它，但这里有 1MB 的 Linux 代码样本供您查看。 Generating Baby Names 生成婴儿名字Lets try one more for fun. Lets feed the RNN a large text file that contains 8000 baby names listed out, one per line (names obtained from here). We can feed this to the RNN and then generate new names! Here are some example names, only showing the ones that do not occur in the training data (90% don’t):再来试一个有趣的实验。我们向RNN输入一个包含8000个婴儿名字的大文本文件，每行一个名字（名字从这里获得）。我们可以将其输入RNN，然后生成新的名字！以下是一些示例名字，只展示那些没有出现在训练数据中的名字（90%都不在训练数据中）：_Rudi Levette Berice Lussa Hany Mareanne Chrestina Carissy Marylen Hammine Janye Marlise Jacacrie Hendred Romand Charienna Nenotto Ette Dorane Wallen Marly Darine Salina Elvyn Ersia Maralena Minoria Ellia Charmin Antley Nerille Chelon Walmor Evena Jeryly Stachon Charisa Allisa Anatha Cathanie Geetra Alexie Jerin Cassen Herbett Cossie Velen Daurenge Robester Shermond Terisa Licia Roselen Ferine Jayn Lusine Charyanne Sales Sanny Resa Wallon Martine Merus Jelen Candica Wallin Tel Rachene Tarine Ozila Ketia Shanne Arnande Karella Roselina Alessia Chasty Deland Berther Geamar Jackein Mellisand Sagdy Nenc Lessie Rasemy Guen Gavi Milea Anneda Margoris Janin Rodelin Zeanna Elyne Janah Ferzina Susta Pey Castina_ You can see many more here. Some of my favorites include “Baby” (haha), “Killie”, “Char”, “R”, “More”, “Mars”, “Hi”, “Saddie”, “With” and “Ahbort”. Well that was fun. Of course, you can imagine this being quite useful inspiration when writing a novel, or naming a new startup :)你可以在这里看到更多。我最喜欢的一些包括“宝贝”（haha）、“Killie”、“Char”、“R”、“More”、“Mars”、“Hi”、“Saddie”、“With”和“Ahbort”。嗯，这很有趣。当然，你可以想象这在写小说或命名新的创业公司时是非常有用的灵感:) Understanding what’s going onWe saw that the results at the end of training can be impressive, but how does any of this work? Lets run two quick experiments to briefly peek under the hood.我们看到训练结束时的结果令人印象深刻，但这些是如何实现的呢？让我们进行两个快速实验，简要探究一下其内部工作原理。 The evolution of samples while training训练时样本的演变First, it’s fun to look at how the sampled text evolves while the model trains. For example, I trained an LSTM of Leo Tolstoy’s War and Peace and then generated samples every 100 iterations of training. At iteration 100 the model samples random jumbles:首先，观察模型训练过程中生成文本的演变是很有趣的。例如，我训练了一个基于列夫·托尔斯泰的《战争与和平》的LSTM，并在每100次迭代训练后生成样本。在第100次迭代时，模型生成的样本是随机混杂的字符： 12tyntd-iafhatawiaoihrdemot lytdws e ,tfti, astai f ogoh eoase rrranbyne &#x27;nhthnee e plia tklrgd t o idoe ns,smtt h ne etie h,hregtrs nigtike,aoaenns lng However, notice that at least it is starting to get an idea about words separated by spaces. Except sometimes it inserts two spaces. It also doesn’t know that comma is amost always followed by a space. At 300 iterations we see that the model starts to get an idea about quotes and periods:然而，请注意至少模型开始有了关于单词由空格分隔的概念。尽管有时它会插入两个空格。它还不知道逗号后几乎总是跟着一个空格。在训练300次迭代时，我们看到模型开始了解引号和句号的用法：1234&quot;Tmont thithey&quot; fomesscerliundKeushey. Thom heresheulke, anmerenith ol sivh I lalterthend Bleipile shuwy fil on aseterlomecoaniogennc Phe lism thond hon at. MeiDimorotion in ther thize.&quot;The words are now also separated with spaces and the model starts to get the idea about periods at the end of a sentence. At iteration 500:现在，单词之间也用空格分隔，模型开始理解句末的句号。在第500次迭代时：12we counter. He stutn co des. His stanted out one ofler that concossions and was to gearang reay Jotrets and with fre colt otf paitt thin wall. Which das stimn the model has now learned to spell the shortest and most common words such as “we”, “He”, “His”, “Which”, “and”, etc. At iteration 700 we’re starting to see more and more English-like text emerge:模型现在已经学会了拼写最短和最常见的单词，比如“we”、“He”、“His”、“Which”、“and”等。在第700次迭代时，我们开始看到越来越多类似英语的文本出现：123Aftair fall unsuch that the hall for Prince Velzonski&#x27;s that me ofher hearly, and behs to so arwage fiving were to it beloge, pavu say falling misfort how, and Gogition is so overelical and ofter. At iteration 1200 we’re now seeing use of quotations and question/exclamation marks. Longer words have now been learned as well:在第1200次迭代时，我们现在看到了引号和问号/感叹号的使用。更长的单词也已经被学会了：12&quot;Kite vouch!&quot; he repeated by herdoor. &quot;But I would be done and quarts, feeling, then, son is people....&quot;Until at last we start to get properly spelled words, quotations, names, and so on by about iteration 2000:直到最后，在大约第2000次迭代时，我们开始得到正确拼写的单词、引号、名字等：123&quot;Why do what that day,&quot; replied Natasha, and wishing to himself the fact theprincess, Princess Mary was easier, fed in had oftened him.Pierre aking his soul came to the packs and drove up his father-in-law women. The picture that emerges is that the model first discovers the general word-space structure and then rapidly starts to learn the words; First starting with the short words and then eventually the longer ones. Topics and themes that span multiple words (and in general longer-term dependencies) start to emerge only much later.出现的情况是，模型首先发现了整体的单词-空格结构，然后迅速开始学习单词；先是短单词，然后逐渐学习长单词。跨越多个单词的主题和主题（以及一般的长期依赖关系）要到很久以后才会开始出现。 Visualizing the predictions and the “neuron” firings in the RNN可视化 RNN 中的预测和“神经元”放电 Another fun visualization is to look at the predicted distributions over characters. In the visualizations below we feed a Wikipedia RNN model character data from the validation set (shown along the blue/green rows) and under every character we visualize (in red) the top 5 guesses that the model assigns for the next character. The guesses are colored by their probability (so dark red = judged as very likely, white = not very likely). For example, notice that there are stretches of characters where the model is extremely confident about the next letter (e.g., the model is very confident about characters during the _http://www._ sequence).另一个有趣的可视化是查看模型对字符的预测分布。在下面的可视化中，我们向一个训练好的Wikipedia RNN模型，提供验证集的字符数据（显示在蓝色/绿色行上），并在每个字符下方可视化（用红色表示）模型对下一个字符的前5个猜测。猜测根据其概率进行着色（深红色=被认为非常可能，白色=不太可能）。例如，请注意在某些字符序列中，模型对下一个字符极为自信(例如，模型对 http://www 序列中的字符非常有信心） The input character sequence (blue/green) is colored based on the _firing_ of a randomly chosen neuron in the hidden representation of the RNN. Think about it as green = very excited and blue = not very excited (for those familiar with details of LSTMs, these are values between [-1,1] in the hidden state vector, which is just the gated and tanh’d LSTM cell state). Intuitively, this is visualizing the firing rate of some neuron in the “brain” of the RNN while it reads the input sequence. Different neurons might be looking for different patterns; Below we’ll look at 4 different ones that I found and thought were interesting or interpretable (many also aren’t):输入字符序列（蓝色/绿色）是根据RNN隐藏表示中随机选择的一个神经元的激活情况进行着色的。可以理解为绿色=非常激动，蓝色=不太激动（对于熟悉LSTM细节的人来说，这些值在隐藏状态向量中介于[-1,1]之间，这是经过门控和tanh函数处理的LSTM单元状态）。直观地说，这是在可视化RNN“脑中”某个神经元在读取输入序列时的激活率。不同的神经元可能在寻找不同的模式；下面我们将查看4个我发现有趣或可解释的神经元（也有很多是无法解释的）： The neuron highlighted in this image seems to get very excited about URLs and turns off outside of the URLs. The LSTM is likely using this neuron to remember if it is inside a URL or not.此图像中突出显示的神经元似乎对 URL 非常兴奋，并在 URL 之外关闭。LSTM 可能使用这个神经元来记住它是否在 URL 内。 The highlighted neuron here gets very excited when the RNN is inside the [[ ]] markdown environment and turns off outside of it. Interestingly, the neuron can’t turn on right after it sees the character “[“, it must wait for the second “[“ and then activate. This task of counting whether the model has seen one or two “[“ is likely done with a different neuron.当 RNN 位于 [[ ]] markdown 环境内部并在其外部关闭时，此处突出显示的神经元会非常兴奋。有趣的是，神经元在看到字符“[”后无法立即打开，它必须等待第二个“[”然后激活。计算模型是否看到一个或两个“[”的任务可能是用不同的神经元完成的。 Here we see a neuron that varies seemingly linearly across the [[ ]] environment. In other words its activation is giving the RNN a time-aligned coordinate system across the [[ ]] scope. The RNN can use this information to make different characters more or less likely depending on how early/late it is in the [[ ]] scope (perhaps?).在这里，我们看到一个神经元，它在[[ ]]环境中似乎呈线性变化。换句话说，它的激活为 RNN 提供了一个跨 [[ ]] 范围的时间对齐坐标系。RNN 可以使用此信息或多或少地使不同的字符更有可能，具体取决于它在 [[ ]] 范围内的早/晚（也许？ Here is another neuron that has very local behavior: it is relatively silent but sharply turns off right after the first “w” in the “www” sequence. The RNN might be using this neuron to count up how far in the “www” sequence it is, so that it can know whether it should emit another “w”, or if it should start the URL.这是另一个具有非常局部行为的神经元：它相对安静，但在“www”序列中的第一个“w”之后急剧关闭。RNN 可能正在使用这个神经元来计算它在“www”序列中的距离，以便它可以知道它是否应该发出另一个“w”，或者它是否应该启动 URL。 Of course, a lot of these conclusions are slightly hand-wavy as the hidden state of the RNN is a huge, high-dimensional and largely distributed representation. These visualizations were produced with custom HTML/CSS/Javascript, you can see a sketch of what’s involved here if you’d like to create something similar.当然，很多这些结论都有些笼统，因为RNN的隐藏状态是一个巨大的、高维的、广泛分布的表示。这些可视化是使用自定义的HTML/CSS/Javascript生成的，如果你想创建类似的东西，可以在这里看到涉及的内容示例。 We can also condense this visualization by excluding the most likely predictions and only visualize the text, colored by activations of a cell. We can see that in addition to a large portion of cells that do not do anything interpretible, about 5% of them turn out to have learned quite interesting and interpretible algorithms:我们还可以通过排除最可能的预测并仅根据单元激活情况对文本进行着色来简化这种可视化。我们可以看到，除了大部分不可解释的单元外，大约有5%的单元学会了相当有趣且可解释的算法：Again, what is beautiful about this is that we didn’t have to hardcode at any point that if you’re trying to predict the next character it might, for example, be useful to keep track of whether or not you are currently inside or outside of quote. We just trained the LSTM on raw data and it decided that this is a useful quantitity to keep track of. In other words one of its cells gradually tuned itself during training to become a quote detection cell, since this helps it better perform the final task. This is one of the cleanest and most compelling examples of where the power in Deep Learning models (and more generally end-to-end training) is coming from.再次强调，这其中的美妙之处在于，我们不需要在任何时候硬编码，例如在预测下一个字符时需要跟踪当前是否在引号内或引号外。我们只是对LSTM进行原始数据的训练，它自己决定跟踪这个信息是有用的。换句话说，其中一个单元在训练过程中逐渐调整自己，变成了一个引号检测单元，因为这有助于它更好地完成最终任务。这是深度学习模型（更广泛地说，端到端训练）力量的最清晰和最有说服力的例子之一。 Source Code 源代码I hope I’ve convinced you that training character-level language models is a very fun exercise. You can train your own models using the char-rnn code I released on Github (under MIT license). It takes one large text file and trains a character-level model that you can then sample from. Also, it helps if you have a GPU or otherwise training on CPU will be about a factor of 10x slower. In any case, if you end up training on some data and getting fun results let me know! And if you get lost in the Torch/Lua codebase remember that all it is is just a more fancy version of this 100-line gist.我希望我已经让你相信，训练字符级语言模型是一个非常有趣的练习。你可以使用我在Github上发布的char-rnn代码（基于MIT许可证）来训练你自己的模型。它需要一个大型文本文件，并训练一个字符级模型，你可以从中进行采样。此外，如果你有GPU，这会更有帮助，否则在CPU上训练的速度大约会慢10倍。不管怎样，如果你在一些数据上训练并得到了有趣的结果，请告诉我！如果你在Torch/Lua代码库中迷失了方向，请记住，这只是这个100行代码示例的更复杂版本。 _Brief digression._ The code is written in Torch 7, which has recently become my favorite deep learning framework. I’ve only started working with Torch/LUA over the last few months and it hasn’t been easy (I spent a good amount of time digging through the raw Torch code on Github and asking questions on their _gitter_ to get things done), but once you get a hang of things it offers a lot of flexibility and speed. I’ve also worked with Caffe and Theano in the past and I believe Torch, while not perfect, gets its levels of abstraction and philosophy right better than others. In my view the desirable features of an effective framework are:简单插曲一下。这段代码是用Torch 7编写的，它最近成为了我最喜欢的深度学习框架。我只是过去几个月才开始使用Torch/LUA，过程并不容易（我花了大量时间在Github上挖掘Torch的源代码，并在他们的gitter上提问以解决问题），但一旦你掌握了它，它就能提供很大的灵活性和速度。我过去也使用过Caffe和Theano，我认为Torch虽然不完美，但它在抽象层次和理念上做得比其他框架更好。在我看来，一个有效框架的理想特性是： CPU/GPU transparent Tensor library with a lot of functionality (slicing, array/matrix operations, etc. )CPU/GPU透明的张量库：具有丰富的功能（切片、数组/矩阵操作等）。） An entirely separate code base in a scripting language (ideally Python) that operates over Tensors and implements all Deep Learning stuff (forward/backward, computation graphs, etc)完全独立的脚本语言代码库：理想情况下是Python，操作张量并实现所有深度学习相关功能（前向/后向传播、计算图等）。 It should be possible to easily share pretrained models (Caffe does this well, others don’t), and crucially能够轻松共享预训练模型：Caffe在这方面做得很好，其他框架则不尽如人意。 NO compilation step (or at least not as currently done in Theano). The trend in Deep Learning is towards larger, more complex networks that are are time-unrolled in complex graphs. It is critical that these do not compile for a long time or development time greatly suffers. Second, by compiling one gives up interpretability and the ability to log/debug effectively. If there is an _option_ to compile the graph once it has been developed for efficiency in prod that’s fine.没有编译步骤：或至少不像Theano目前那样。深度学习的发展趋势是使用更大、更复杂的网络，这些网络在复杂的计算图中进行时间展开。关键是这些图不应长时间编译，否则会严重影响开发时间。其次，通过编译，会失去可解释性和有效记录/调试的能力。如果有选项可以在开发完成后编译图以提高生产效率，那也很好。 Further Reading 延伸阅读Before the end of the post I also wanted to position RNNs in a wider context and provide a sketch of the current research directions. RNNs have recently generated a significant amount of buzz and excitement in the field of Deep Learning. Similar to Convolutional Networks they have been around for decades but their full potential has only recently started to get widely recognized, in large part due to our growing computational resources. Here’s a brief sketch of a few recent developments (definitely not complete list, and a lot of this work draws from research back to 1990s, see related work sections):在文章的结尾，我还想把RNN放在更广泛的背景中，并提供当前研究方向的概述。最近，RNN在深度学习领域引起了大量关注和兴奋。类似于卷积网络，RNN已经存在了几十年，但它们的全部潜力直到最近才开始被广泛认可，这在很大程度上要归功于我们不断增长的计算资源。以下是一些最近发展的简要概述（绝不是完整的列表，其中很多工作可以追溯到1990年代，详见相关研究部分）： In the domain of NLP/Speech, RNNs transcribe speech to text, perform machine translation, generate handwritten text, and of course, they have been used as powerful language models (Sutskever et al.) (Graves) (Mikolov et al.) (both on the level of characters and words). Currently it seems that word-level models work better than character-level models, but this is surely a temporary thing.在NLP/Speech领域，RNN用于将语音转录为文本、执行机器翻译、生成手写文本，当然，它们也被用作强大的语言模型（Sutskever等人）（Graves）（Mikolov等人）（包括字符级和单词级）。目前看来，单词级模型比字符级模型效果更好，但这肯定只是暂时的。 Computer Vision. RNNs are also quickly becoming pervasive in Computer Vision. For example, we’re seeing RNNs in frame-level video classification, image captioning (also including my own work and many others), video captioning and very recently visual question answering. My personal favorite RNNs in Computer Vision paper is Recurrent Models of Visual Attention, both due to its high-level direction (sequential processing of images with glances) and the low-level modeling (REINFORCE learning rule that is a special case of policy gradient methods in Reinforcement Learning, which allows one to train models that perform non-differentiable computation (taking glances around the image in this case)). I’m confident that this type of hybrid model that consists of a blend of CNN for raw perception coupled with an RNN glance policy on top will become pervasive in perception, especially for more complex tasks that go beyond classifying some objects in plain view.计算机视觉。RNN也迅速在计算机视觉领域普及。例如，我们看到RNN用于帧级视频分类、图像描述生成（包括我自己的工作和许多其他人的工作）、视频描述生成以及最近的视觉问答。我个人最喜欢的计算机视觉领域的RNN论文是《视觉注意力的递归模型》，因为它在高层次方向（通过扫视对图像进行顺序处理）和低层次建模（REINFORCE学习规则，这是强化学习中策略梯度方法的特例，允许训练执行不可微计算的模型（在本例中是环顾图像））上都很出色。我相信这种混合模型，即结合了用于原始感知的CNN和用于扫视策略的RNN的模型，将在感知领域普及，特别是在超越简单对象分类的复杂任务中。 Inductive Reasoning, Memories and Attention. Another extremely exciting direction of research is oriented towards addressing the limitations of vanilla recurrent networks. One problem is that RNNs are not inductive: They memorize sequences extremely well, but they don’t necessarily always show convincing signs of generalizing in the _correct_ way (I’ll provide pointers in a bit that make this more concrete). A second issue is they unnecessarily couple their representation size to the amount of computation per step. For instance, if you double the size of the hidden state vector you’d quadruple the amount of FLOPS at each step due to the matrix multiplication. Ideally, we’d like to maintain a huge representation/memory (e.g. containing all of Wikipedia or many intermediate state variables), while maintaining the ability to keep computation per time step fixed.归纳推理、记忆和注意力。另一个极其令人兴奋的研究方向是解决普通循环网络的局限性。一个问题是RNN不具备归纳能力：它们非常擅长记忆序列，但不一定总是能以正确的方式表现出令人信服的泛化能力（稍后我会提供一些具体的例子）。第二个问题是它们不必要地将表示大小与每步计算量耦合在一起。例如，如果你将隐藏状态向量的大小加倍，那么由于矩阵乘法，每步的浮点运算量（FLOPS）将增加四倍。理想情况下，我们希望保持一个巨大的表示/记忆（例如包含整个维基百科或许多中间状态变量），同时保持每个时间步的计算量固定。 The first convincing example of moving towards these directions was developed in DeepMind’s Neural Turing Machines paper. This paper sketched a path towards models that can perform read/write operations between large, external memory arrays and a smaller set of memory registers (think of these as our working memory) where the computation happens. Crucially, the NTM paper also featured very interesting memory addressing mechanisms that were implemented with a (soft, and fully-differentiable) attention model. The concept of soft attention has turned out to be a powerful modeling feature and was also featured in Neural Machine Translation by Jointly Learning to Align and Translate for Machine Translation and Memory Networks for (toy) Question Answering. In fact, I’d go as far as to say that第一个朝着这些方向前进的令人信服的例子是DeepMind的《神经图灵机》（Neural Turing Machines）论文。这篇论文勾画了一个模型的路径，这些模型可以在大型外部存储阵列和一小组计算发生的存储寄存器（可以将这些视为我们的工作记忆）之间执行读/写操作。至关重要的是，NTM论文还展示了非常有趣的记忆寻址机制，这些机制通过一个（软且完全可微分的）注意力模型实现。软注意力的概念被证明是一个强大的建模特性，它也出现在《通过联合学习对齐和翻译的神经机器翻译》和《记忆网络用于（玩具）问答》中。实际上，我甚至可以说 The concept of attention is the most interesting recent architectural innovation in neural networks.注意力的概念是神经网络中最近最有趣的架构创新。 Now, I don’t want to dive into too many details but a soft attention scheme for memory addressing is convenient because it keeps the model fully-differentiable, but unfortunately one sacrifices efficiency because everything that can be attended to is attended to (but softly). Think of this as declaring a pointer in C that doesn’t point to a specific address but instead defines an entire distribution over all addresses in the entire memory, and dereferencing the pointer returns a weighted sum of the pointed content (that would be an expensive operation!). This has motivated multiple authors to swap soft attention models for hard attention where one samples a particular chunk of memory to attend to (e.g. a read/write action for some memory cell instead of reading/writing from all cells to some degree). This model is significantly more philosophically appealing, scalable and efficient, but unfortunately it is also non-differentiable. This then calls for use of techniques from the Reinforcement Learning literature (e.g. REINFORCE) where people are perfectly used to the concept of non-differentiable interactions. This is very much ongoing work but these hard attention models have been explored, for example, in Inferring Algorithmic Patterns with Stack-Augmented Recurrent Nets, Reinforcement Learning Neural Turing Machines, and Show Attend and Tell.现在，我不想深入研究太多细节，但用于内存寻址的软注意力方案很方便，因为它使模型保持完全可微分，但不幸的是，人们牺牲了效率，因为所有可以处理的东西都被处理了（但很软）。可以把它想象成在 C 语言中声明一个指针，该指针不指向特定地址，而是在整个内存中的所有地址上定义整个分布，并且取消引用指针会返回指向内容的加权总和（这将是一个昂贵的操作！这促使多位作者将软注意力模型换成硬注意力模型，其中一个人对要关注的特定内存块进行采样（例如，对某些记忆单元进行读/写操作，而不是在某种程度上从所有单元读取/写入）。这个模型在哲学上更具吸引力、可扩展性和效率，但不幸的是，它也是不可微分的。然后，这需要使用强化学习文献中的技术（例如REINFORCE），在这些技术中，人们完全习惯了不可微分交互的概念。这是一项正在进行的工作，但这些硬注意力模型已经被探索过，例如，在使用堆栈增强的循环网络推断算法模式、强化学习神经图灵机和显示、出席和讲述中。 People. If you’d like to read up on RNNs I recommend theses from Alex Graves, Ilya Sutskever and Tomas Mikolov. For more about REINFORCE and more generally Reinforcement Learning and policy gradient methods (which REINFORCE is a special case of) David Silver’s class, or one of Pieter Abbeel’s classes.人。如果你想深入了解RNN，我推荐阅读Alex Graves、Ilya Sutskever和Tomas Mikolov的论文。关于REINFORCE和更广泛的强化学习及策略梯度方法（REINFORCE是其特例），可以参考David Silver的课程，或Pieter Abbeel的课程之一。 Code. If you’d like to play with training RNNs I hear good things about keras or passage for Theano, the code released with this post for Torch, or this gist for raw numpy code I wrote a while ago that implements an efficient, batched LSTM forward and backward pass. You can also have a look at my numpy-based NeuralTalk which uses an RNN/LSTM to caption images, or maybe this Caffe implementation by Jeff Donahue.代码。如果你想尝试训练RNN，我听说keras或passage for Theano的评价很好，可以参考本文发布的用于Torch的代码，或者我之前编写的这个实现了高效批量LSTM前向和后向传递的纯numpy代码。你也可以看看我基于numpy的NeuralTalk，它使用RNN/LSTM生成图像描述，或者看看Jeff Donahue的这个Caffe实现。 Conclusion 结论We’ve learned about RNNs, how they work, why they have become a big deal, we’ve trained an RNN character-level language model on several fun datasets, and we’ve seen where RNNs are going. You can confidently expect a large amount of innovation in the space of RNNs, and I believe they will become a pervasive and critical component to intelligent systems.我们已经了解了RNN，它们是如何工作的，为什么它们变得如此重要。我们在几个有趣的数据集上训练了一个RNN字符级语言模型，并且看到了RNN的发展方向。你可以自信地期待在RNN领域出现大量的创新，我相信它们将成为智能系统中普遍且关键的组成部分。 Lastly, to add some meta to this post, I trained an RNN on the source file of this blog post. Unfortunately, at about 46K characters I haven’t written enough data to properly feed the RNN, but the returned sample (generated with low temperature to get a more typical sample) is:最后，为了给这篇文章增加一些元内容，我用这篇博客文章的源文件训练了一个RNN。不幸的是，大约46K字符的数据量还不足以充分训练RNN，但生成的样本（在低温下生成，以获得更典型的样本）如下： 12I&#x27;ve the RNN with and works, but the computed with program of the RNN with and the computed of the RNN with with and the code Yes, the post was about RNN and how well it works, so clearly this works :). See you next time!是的，这篇文章是关于 RNN 及其工作情况的，所以很明显这:)工作。下次再见！ EDIT (extra links): 编辑（额外链接）Videos: 视频： I gave a talk on this work at the London Deep Learning meetup (video).我在伦敦深度学习聚会上就这项工作发表了演讲（视频）。 Discussions: 讨论： HN discussion HN 讨论 Reddit discussion on r/machinelearningReddit 关于 r/machinelearning 的讨论 Reddit discussion on r/programmingReddit 上关于 r/programming 的讨论 Replies: 答复： Yoav Goldberg compared these RNN results to n-gram maximum likelihood (counting) baselineYoav Goldberg 将这些 RNN 结果与 n-gram 最大似然（计数）基线进行了比较 @nylk trained char-rnn on cooking recipes. They look great!@nylk培训了char-rnn的烹饪食谱。它们看起来很棒！ @MrChrisJohnson trained char-rnn on Eminem lyrics and then synthesized a rap song with robotic voice reading it out. Hilarious :)@MrChrisJohnson用 Eminem 的歌词训练了 char-rnn，然后合成了一首带有机器人声音的说唱歌曲。搞笑:) @samim trained char-rnn on Obama Speeches. They look fun!@samim培训了奥巴马演讲的char-rnn。他们看起来很有趣！ João Felipe trained char-rnn irish folk music and sampled music若昂·费利佩（João Felipe）训练了char-rnn爱尔兰民间音乐并采样了音乐 Bob Sturm also trained char-rnn on music in ABC notation鲍勃·斯特姆（Bob Sturm）还对char-rnn进行了ABC记谱法的音乐培训 RNN Bible bot by MaximilienRNN Bible bot 的 Maximilien Learning Holiness learning the Bible学习圣洁 学习圣经 Terminal.com snapshot that has char-rnn set up and ready to go in a browser-based virtual machine (thanks @samim)Terminal.com 已设置 char-rnn 并准备在基于浏览器的虚拟机中使用的快照（感谢 @samim） 注释1.Vanilla 神经网络“Vanilla 神经网络”通常指的是最基本、最简单的神经网络模型，没有使用任何特殊的层或复杂的架构。具体来说，它一般指的是简单的前馈神经网络（Feedforward Neural Network, FNN） 2. 向量（Vector）vs 序列（Sequence）向量（Vector）： 定义：在数学和计算机科学中，向量是一组有序的数值。这些数值可以表示多维空间中的一个点或某个特定的数据结构。 特性： 固定长度：向量的长度是固定的，例如一个包含三个数值的向量$x_1, x_2, x_3$。 这种处理方式对于图像分类、固定长度的文本分类等任务非常有效。 无时间依赖：向量中的元素没有时间或顺序上的依赖关系。例如，一张图片的像素数据可以作为输入向量，但这些像素之间没有时间顺序上的关系。 示例： 图像处理中的像素值向量。 静态文本分类中的单词向量。 向量输入输出：向量输入输出通常指的是神经网络处理固定长度的向量，即一组固定大小的数值输入和输出。 应用场景： 图像分类：输入是一个固定大小的图像向量，输出是一个类别标签向量。 静态文本分类：输入是一个表示单个文档的向量，输出是分类标签。 序列（Sequence）： 定义：序列是一组按特定顺序排列的数据，通常是时间或顺序相关的。 特性： 变长：序列的长度可以变化，例如一段文本可以是一个字符序列$c_1, c_2, …, c_t$ 有时间依赖：序列中的元素有时间或顺序上的依赖关系。后续元素依赖于前面出现的元素。例如，在自然语言处理中，一个句子的单词顺序决定了句子的意义。 示例： 时间序列数据，如股票价格的每日记录。 文本数据，如一段句子中的单词序列。 序列输入输出：序列输入输出指的是神经网络处理一系列的输入数据，这些数据有时间或顺序上的依赖关系。RNN（循环神经网络）就是处理序列数据的典型模型。 应用场景： 语言模型和文本生成：输入是一个文本序列，输出是下一个字符或单词的预测序列。 机器翻译：输入是源语言的句子序列，输出是目标语言的句子序列。 语音识别：输入是语音信号的时间序列，输出是对应的文本序列。 3. RNN computation论文正文中对该过程的描述文字较多，我反倒觉得结合数学公式后更好理解。这里描述就是 RNN 的前向传播过程， 如果你了解了基础神经网络的前向传播过程，那么RNN也非常好理解。 简单理解就是 相比在神经网络一文中讲述的基础 前向传播过程中，递归神经网络在此基础上增加了一个隐藏层到隐藏层的权重矩阵参与计算。 这3个权重矩阵分别对应文中W_hh（隐藏层到隐藏层）、W_xh（输入层到隐藏层）和W_hy（隐藏层到输出层）,下面以$ℎ_𝑡=tanh⁡(𝑊_{ℎℎ}ℎ_{𝑡−1}+𝑊_{𝑥ℎ}𝑥_𝑡)$ 来拆解整个过程 假设网络结构和参数如下 输入层：2个节点，表示输入特征 $x_1$ 和 $x_2$。 隐藏层：2个节点，表示隐藏状态 $h_1$ 和 $h_2$​，,使用tanh激活函数。 输出层：1个节点，表示输出 $y$，使用线性激活函数。 权重矩阵 输入层到隐藏层的权重： $W_{xh} = \\begin{bmatrix} W_{11} &amp; W_{12} \\ W_{21} &amp; W_{22} \\end{bmatrix}$ $W_{11}$、$W_{12}$​ 连接 $x_1$​ 到 $h_1$​ 和 $h_2$​，$W_{21}$、$W_{22}$​ 连接 $x_2$​ 到 $h_1$​ 和 $h_2$。 隐藏层到隐藏层的权重：$W_{hh} = \\begin{bmatrix} U_{11} &amp; U_{12} \\ U_{21} &amp; U_{22} \\end{bmatrix}$ $U_{11}$和 $U_{12}$ 连接 $h_1(t-1)$到 $h_1(t)$ 和 $h_2(t)$。 $U_{21}$ 和 $U_{22}$ 连接 $h_2(t-1)$ 到 $h_1(t)$ 和 $h_2(t)$。[[#5. 序列数据的处理]] 隐藏层到输出层的权重： $W_{hy} = \\begin{bmatrix} W_{31} &amp; W_{32} \\end{bmatrix}$ $W_{31}$​ 和 $W_{32}$分别连接$h_1$ 和$h_2$到 $y$。 前向传播过程对于每个时间步 $t$，前向传播的计算步骤如下： 1. 输入层到隐藏层计算当前时间步的隐藏状态, 即正文中的“隐藏状态的更新”$ℎ_𝑡=tanh⁡(𝑊_{ℎℎ}ℎ_{𝑡−1}+𝑊_{𝑥ℎ}𝑥_𝑡)$其中，$\\mathbf{x}_t$​ 是当前时间步的输入向量，$\\mathbf{h}_{t-1}$是前一时间步的隐藏状态。具体展开如下： $\\begin{bmatrix} h_{1t} \\ h_{2t} \\end{bmatrix} = \\text{tanh} \\left( \\begin{bmatrix} W_{11} &amp; W_{12} \\ W_{21} &amp; W_{22} \\end{bmatrix} \\begin{bmatrix} x_{1t} \\ x_{2t} \\end{bmatrix} + \\begin{bmatrix} U_{11} &amp; U_{12} \\ U_{21} &amp; U_{22} \\end{bmatrix} \\begin{bmatrix} h_{1(t-1)} \\ h_{2(t-1)} \\end{bmatrix} + \\begin{bmatrix} b_1 \\ b_2 \\end{bmatrix} \\right)$ 分开计算：$h_{1t} = \\text{tanh}(W_{11} x_{1t} + W_{12} x_{2t} + U_{11} h_{1(t-1)} + U_{12} h_{2(t-1)} )$ $h_{2t} = \\text{tanh}(W_{21} x_{1t} + W_{22} x_{2t} + U_{21} h_{1(t-1)} + U_{22} h_{2(t-1)})$ 2. 隐藏层到输出层计算当前时间步的输出。 $y_t = W_{hy} \\mathbf{h}_t$具体展开如下：$y_t = \\begin{bmatrix} W_{31} &amp; W_{32} \\end{bmatrix} \\begin{bmatrix} h_{1t} \\ h_{2t} \\end{bmatrix}$ 分开计算： $y_t = W_{31} h_{1t} + W_{32} h_{2t}$ ⚠️： tanh 是非线性激活函数 4. 1-of-k编码1-of-k编码，也称为独热编码（One-Hot Encoding），是一种将分类数据转换为二进制向量的方法。它的目的是将非数值型的类别变量转化为适合于机器学习算法处理的数值型数据。 工作原理假设有一个类别变量，它有 $k$ 个不同的类别。1-of-k编码将每个类别表示为一个长度为 $k$ 的二进制向量，其中只有一个位置为1，其他位置为0。 例如，考虑一个有四个类别的变量：”A”, “B”, “C”, “D”。其1-of-k编码如下： 类别 1-of-k编码 A [1, 0, 0, 0] B [0, 1, 0, 0] C [0, 0, 1, 0] D [0, 0, 0, 1] 优点 消除排序关系：独热编码将分类变量转化为二进制向量，避免了对分类变量的误解，即认为它们之间存在排序关系。 适合模型处理：许多机器学习算法（如线性回归、逻辑回归等）无法直接处理非数值型数据，1-of-k编码使这些数据适合于这些算法。 缺点 高维度问题：当类别数量较多时，编码后的向量长度会变得很长，导致高维度问题，增加计算和存储成本。 实际应用 文本处理：在自然语言处理（NLP）任务中，1-of-k编码常用于将单词转化为二进制向量。 分类任务：在分类任务中，用于将类别标签转化为模型可以处理的数值型数据。 1-of-k编码是数据预处理中的一种重要技术，广泛应用于各种机器学习和深度学习任务中。它帮助将分类数据转化为数值数据，使得各种模型能够更好地处理这些数据。 5. 置信度在机器学习中，置信度（confidence）是衡量模型预测结果确定性的一个指标。置信度可以理解为模型对其预测的某个结果是正确的信心程度。 在机器学习中，置信度通常以概率值的形式表示，反映了模型对某个预测的确定性。例如，在分类任务中，模型对某个样本属于某一类的置信度可能是80%，表示模型认为该样本属于该类的概率为80%。具体应用： 分类任务：如图像分类，模型输出每个类别的概率分布。例如，对于一张图片，模型可能输出：[猫: 0.7, 狗: 0.2, 兔子: 0.1]，其中猫的置信度最高。 置信度阈值：在某些应用中，可能会设置一个置信度阈值，只有当预测的置信度超过某个值时，才认为预测有效。 置信度的计算 概率分布：使用Softmax函数将模型输出的logits转化为概率分布，这些概率值即为置信度。 Softmax公式：对于第 $i$ 个输出节点，置信度 $P(y_i)$ 为： $P(y_i) = \\frac{e^{z_i}}{\\sum_{j} e^{z_j}}$ 其中， $z_i$ 是第 $i$ 个节点的logit。Logits Logits 是神经网络在分类任务中的输出层的原始得分。它们是未经过归一化的数值，用于表示每个类别的相对置信度。Logits 是通过前向传播计算得到的，表示模型对每个可能的类别的初始估计。 具体理解 原始得分：Logits 是神经网络最后一层输出的原始分数，这些分数还没有被转换为概率。 用途：在分类任务中，Logits 被用来计算每个类别的概率，这通常通过 Softmax 函数完成。 Softmax 转换：Softmax 函数将 Logits 转换为概率分布，使得这些概率的和为1。公式如上 6. Softmax[[0-神经网络（Neural Networks）#^cfe178]] 7. 超参数 Temperature 温度Temperature是在模型使用或调优过程中设定的参数，并不通过模型训练过程中的优化算法来更新，因此它属于超参数。Temperature作为超参数，在神经网络中用来控制Softmax输出的概率分布平滑程度，它的作用是调节模型生成样本的多样性和确定性。 Temperature的公式Softmax函数带有Temperature的公式如下： $P(y_i) = \\frac{e^{z_i / T}}{\\sum_{j} e^{z_j / T}}$ 其中，$z_i$ 是logits值，$T$ 是Temperature参数。 Temperature的影响 高Temperature（T &gt; 1）： 平滑分布：使概率分布更加平滑，增加生成样本的多样性。 增加随机性：输出类别之间的概率差距缩小，使得选择更随机。 示例：假设 logits 为 $[2.0,1.0,0.1]$，使用 $T = 2$ 时，概率可能变得更接近，如 $[0.4,0.35,0.25]$。 低Temperature（0 &lt; T &lt; 1）： 尖锐分布：使概率分布更加尖锐，增加生成样本的确定性。 减少随机性：输出类别之间的概率差距加大，使得选择更确定。 示例：假设 logits 为 $[2.0,1.0,0.1]$，使用 $T = 0.5$ 时，概率可能变得更尖锐，如 $[0.7,0.25,0.05]$。 Temperature等于1： 标准Softmax：概率分布保持原样，不做任何调整。 作用及应用场景 文本生成： 控制生成文本的多样性和创造性。在文本生成任务中，高Temperature可能生成更有创意但不一定合理的句子，而低Temperature可能生成更合理但缺乏多样性的句子。 探索与利用： 在强化学习中，高Temperature用于探索多样性策略，低Temperature用于利用已知的最佳策略。","tags":["AI","神经网络","Ilya sutskever‘s 30  papers"]},{"title":"递归神经网络（Recurrent Neural Networks, RNNs）","path":"/6ac941eb/","content":"前置概念1. 时间步（Time Step）和序列数据（Sequential Data）1.1 序列数据（Sequential Data）序列数据（Sequential Data）是指按照时间或其他顺序排列的数据，其中每个数据点的意义和价值都依赖于它在序列中的位置和前后数据点的关系。序列数据广泛存在于许多实际应用中，如时间序列、自然语言处理、语音识别等。 序列数据的特点 时间依赖性：序列数据中的每个数据点与其前后数据点存在依赖关系。这种依赖性可以是短期的（仅依赖于最近的数据点）或长期的（依赖于较早的数据点）。 顺序关系：序列数据的顺序是至关重要的，数据点的顺序关系决定了其实际意义。例如，在语音信号中，音频帧的顺序决定了最终语音的内容。 动态性：序列数据往往是动态变化的，数据点的值随时间或其他顺序变化而变化。 1.2 时间步时间步指的是序列数据中的每一个元素在时间维度上的位置。例如，在一个时间序列中，每个时间点上的数据称为一个时间步。在递归神经网络中，输入序列按时间步逐步处理，每个时间步的输入不仅影响当前时间步的输出，还影响后续时间步的计算。 1.3 序列数据与时间步的实际例子序列数据可以分为多种类型，具体包括： 1. 时间序列数据时间序列数据是按照时间顺序排列的数据，常用于金融市场分析、气象预报等领域。示例：股票价格、温度记录等。12时间： t1 t2 t3 t4 t5股票价格： 100 102 101 103 104 2. 自然语言处理数据自然语言处理中的数据是按照文本中的顺序排列的单词或字符，常用于文本分类、机器翻译等任务。 示例：一段文本、一句话等。12时间： t1 t2 t3 t4 t5句子： 我 喜欢 学习 机器 学习 3. 语音信号数据语音信号是连续的音频帧序列，每个音频帧表示一小段时间内的声音特征，常用于语音识别、语音合成等任务。 示例：一段语音信号。12时间步： t1 t2 t3 t4 t5音频帧： F1 F2 F3 F4 F5 4. 视频数据视频数据是由一系列按时间顺序排列的图像帧组成，常用于视频分类、目标检测等任务。 示例：一段视频。12时间步： t1 t2 t3 t4 t5视频帧： F1 F2 F3 F4 F5 1.4 序列数据的实际应用场景 时间序列预测：通过分析历史数据，预测未来的值。示例：股票价格预测、天气预报、销售量预测等。 自然语言处理：处理和理解人类语言，执行各种语言相关任务。示例：文本分类、情感分析、机器翻译、文本生成等。 语音识别：将语音信号转换为文本，或者识别语音中的情感、语种等信息。示例：语音到文本转换、语音情感识别、语音翻译等。 视频处理：处理和分析视频数据，执行各种视频相关任务。示例：视频分类、目标检测、行为识别等 1.5 序列数据的处理处理序列数据时，需要考虑数据的顺序和时间依赖性。以下是一些常见的处理方法和模型： 1. 递归神经网络（Recurrent Neural Networks, RNNs）RNNs通过循环结构能够记住和利用序列数据中的时间依赖性，适用于处理各种序列数据。 特点： 能够处理变长序列数据。 能够捕捉短期和长期依赖关系。 2. 长短期记忆网络（Long Short-Term Memory, LSTM）LSTM是RNN的一种变体，专门用于解决RNN中的梯度消失和梯度爆炸问题，能够更好地捕捉长序列中的依赖关系。 特点： 通过引入遗忘门、输入门和输出门控制信息流动。 能够记住长时间的依赖关系。 3. 门控循环单元（Gated Recurrent Unit, GRU）GRU是LSTM的简化版本，具有类似的门控机制，但参数更少，计算效率更高。 特点： 通过更新门和重置门控制信息流动。 计算效率更高，适合处理长序列数据。 4. Transformer模型Transformer模型通过自注意力机制（Self-Attention）处理序列数据，能够并行处理序列中的每个位置，解决了传统RNN的计算瓶颈问题。 特点： 通过注意力机制捕捉序列中任意位置之间的依赖关系。 计算效率高，适合处理长序列数据。 2. 什么是RNN递归神经网络（Recurrent Neural Networks, RNNs）是一类专门用于处理序列数据的神经网络模型。RNNs通过循环结构使得网络能够捕捉和记忆输入数据中的时间依赖性，适用于各种序列数据处理任务，如时间序列预测、自然语言处理、语音识别等。 如果你已经对基础神经网络的层次结构和前向传播过程了解了， 那么RNN 与它的区别就是其隐藏层具有循环连接，使得当前时间步的隐藏状态不仅依赖于当前输入，还依赖于前一时间步的隐藏状态。 下面在 基础神经网络中的层次结构的基础上说明 RNN 网络结构和参数 输入层：2个节点，表示输入特征 $x_1$ 和 $x_2​$。 隐藏层：2个节点，表示隐藏状态 $h_1$ 和 $h_2$​，偏置向量分别为$b_1$、$b_2$,使用ReLU激活函数。 输出层：1个节点，表示输出 $y$，偏置向量分别为$b_3$,使用线性激活函数。 权重矩阵 输入层到隐藏层的权重： $W_{xh} = \\begin{bmatrix} W_{11} &amp; W_{12} \\ W_{21} &amp; W_{22} \\end{bmatrix}$ $W_{11}​$、$W_{12}$​ 连接 $x_1$​ 到 $h_1$​ 和 $h_2$​，$W_{21}​$、$W_{22}$​ 连接 $x_2$​ 到 $h_1$​ 和 $h_2​$。 隐藏层到隐藏层的权重：$W_{hh} = \\begin{bmatrix} U_{11} &amp; U_{12} \\ U_{21} &amp; U_{22} \\end{bmatrix}$ $U_{11}​$和 $U_{12}​$ 连接 $h_1(t-1)$到 $h_1(t)$ 和 $h_2(t)$。 $U_{21}​$ 和 $U_{22}$ 连接 $h_2(t-1)$ 到 $h_1(t)$ 和 $h_2(t)$。 隐藏层到输出层的权重： $W_{hy} = \\begin{bmatrix} W_{31} &amp; W_{32} \\end{bmatrix}$ $W_{31}$​ 和 $W_{32}$分别连接$h_1$ 和$h_2​$到 $y$。 偏置向量 隐藏层的偏置：$\\mathbf{b}_h = \\begin{bmatrix} b_1 \\ b_2 \\end{bmatrix}$ 输出层的偏置：$b_3$前向传播过程 对于每个时间步 $t$，前向传播的计算步骤如下： 输入层到隐藏层：计算当前时间步的隐藏状态。$\\mathbf{h}_t = \\text{ReLU}(W_{xh} \\mathbf{x}_t + W_{hh} \\mathbf{h}_{t-1} + \\mathbf{b}_h)$ 其中，$\\mathbf{x}_t$​ 是当前时间步的输入向量，$\\mathbf{h}_{t-1}​$是前一时间步的隐藏状态。具体展开如下： $\\begin{bmatrix} h_{1t} \\ h_{2t} \\end{bmatrix} = \\text{ReLU} \\left( \\begin{bmatrix} W_{11} &amp; W_{12} \\ W_{21} &amp; W_{22} \\end{bmatrix} \\begin{bmatrix} x_{1t} \\ x_{2t} \\end{bmatrix} + \\begin{bmatrix} U_{11} &amp; U_{12} \\ U_{21} &amp; U_{22} \\end{bmatrix} \\begin{bmatrix} h_{1(t-1)} \\ h_{2(t-1)} \\end{bmatrix} + \\begin{bmatrix} b_1 \\ b_2 \\end{bmatrix} \\right)$ 分开计算： $h_{1t} = \\text{ReLU}(W_{11} x_{1t} + W_{12} x_{2t} + U_{11} h_{1(t-1)} + U_{12} h_{2(t-1)} + b_1)$ $h_{2t} = \\text{ReLU}(W_{21} x_{1t} + W_{22} x_{2t} + U_{21} h_{1(t-1)} + U_{22} h_{2(t-1)} + b_2)$ 隐藏层到输出层：计算当前时间步的输出。 $y_t = W_{hy} \\mathbf{h}_t + b_3$具体展开如下： $y_t = \\begin{bmatrix} W_{31} &amp; W_{32} \\end{bmatrix} \\begin{bmatrix} h_{1t} \\ h_{2t} \\end{bmatrix} + b_3$ 分开计算： $y_t = W_{31} h_{1t} + W_{32} h_{2t} + b_3$ Dropout在RNN中的表现在传统的前馈神经网络中，Dropout被证明是非常有效的正则化方法。然而，直接将这种方法应用于RNN时，会破坏时间步之间的依赖关系，导致模型性能下降。 在RNN中，Dropout的效果确实没有在前馈神经网络中那么明显，原因如下： 时间步之间的依赖性：RNN中的隐藏层具有时间步之间的依赖关系，即当前时间步的隐藏状态依赖于前一时间步的隐藏状态。传统的Dropout方法在RNN中会破坏这种时间步之间的依赖关系，从而影响模型的学习效果。 梯度传播的影响：RNN通过反向传播通过时间（Backpropagation Through Time, BPTT）来更新权重，Dropout会在时间步之间引入不稳定性，可能导致梯度传播过程中的问题，如梯度消失或梯度爆炸。 3. RNN中的梯度消失和梯度爆炸在训练循环神经网络（RNN）时，常常会遇到梯度消失和梯度爆炸问题，这两者都是由RNN的反向传播算法（BPTT, Backpropagation Through Time）引起的。 1. 梯度消失（Vanishing Gradient）现象： 当梯度在反向传播过程中逐层传递时，它的数值会逐渐变小，最终趋近于零。 这导致前面层的权重更新几乎停止，使网络难以训练。 原因： 在反向传播过程中，梯度是通过链式法则逐层相乘的。如果某些层的梯度小于1（例如小于1的激活函数导数），则乘积会快速缩小。 常见的激活函数如tanh和sigmoid在输入值较大或较小时，其导数接近零，从而加剧了梯度消失问题。 2. 梯度爆炸（Exploding Gradient）现象： 当梯度在反向传播过程中逐层传递时，它的数值会逐渐变大，最终变得非常大。 这导致前面层的权重更新过大，使网络参数变得不稳定，甚至导致溢出。 原因： 在反向传播过程中，如果某些层的梯度大于1（例如大于1的激活函数导数），则乘积会快速增大。 常见的原因包括不合理的初始化权重和未处理的数值不稳定问题。 解决方法 梯度裁剪（Gradient Clipping）： 当梯度的范数超过某个阈值时，将其缩放到该阈值。 这可以有效防止梯度爆炸。 长短期记忆网络（LSTM）和门控循环单元（GRU）： 这些是专门设计用于缓解梯度消失和梯度爆炸问题的RNN变种。 通过引入门机制，它们能够更好地保持长时间依赖。 适当的权重初始化： 使用如Xavier初始化或He初始化来设置初始权重，可以减少梯度消失和爆炸的风险。 使用不同的激活函数： ReLU等激活函数在一定程度上可以缓解梯度消失问题。","tags":["AI","神经网络","Ilya sutskever‘s 30  papers"]},{"title":"神经网络（Neural Networks）","path":"/f27811be/","content":"0. 什么是神经网络 (Neural Networks)神经网络是实现AI 的一种技术手段，一种广泛用于机器学习（Machine Learning）和深度学习（Deep Learning）领域的计算模型/算法架构。 它受到人类大脑神经元（Neurons）和它们的互动方式的启发，它由多个层（Layers）组成，每层包含多个神经元，这些神经元通过权重（Weights）连接传递信息。 神经网络的训练过程基于机器学习的基本前提，即能够从数据中学习。通过向网络提供大量的数据样本（包括输入和期望的输出），神经网络可以学习到如何映射输入到输出，这种能力是通过调整内部结构（即权重）来实现的。 这一学习过程使用了机器学习中的核心概念，如损失函数（Loss Functions）、梯度下降（Gradient Descent）和反向传播算法（Backpropagation Algorithms）。这些都是机器学习领域的基本工具，用于训练模型以改进其性能。 1. 神经网络的层次结构1.1 节点（Nodes）或神经元（Neurons）节点是神经网络的基本单位，也称为神经元。每个节点接收输入信号，进行加权求和和非线性变换，然后将结果传递给下一层的节点。节点的主要功能包括： 接收输入：从前一层的所有节点接收输入信号。 加权求和：对接收到的输入信号乘以相应的权重并求和。 应用激活函数：对加权求和的结果应用激活函数，生成节点的输出。 传递输出：将输出信号传递给下一层的节点。 1.2 层（Layers）层是由多个节点组成的一个集合，在神经网络中起着分层处理输入数据的作用。每一层中的节点执行相同类型的计算，但每个节点有各自的权重和偏置。 一个典型的神经网络由以下几个部分组成： 输入层（Input Layer）：接收外部输入数据，每个节点代表一个输入特征。 隐藏层（Hidden Layers）：位于输入层和输出层之间，用于特征提取和数据变换。一个神经网络可以有一个或多个隐藏层。 输出层（Output Layer）：生成最终的预测结果，每个节点代表一个输出。 1.3 节点和层的关系节点和层之间的关系可以概括如下： 层是节点的集合：每一层由多个节点组成，这些节点在同一层内进行相同类型的计算。 数据传递和处理：数据在神经网络中逐层传递，每一层的节点接收前一层的输出，进行计算后将结果传递给下一层的节点。 层次结构：神经网络的层次结构决定了数据处理的顺序和方式。输入数据经过输入层后，依次通过一个或多个隐藏层进行复杂的特征提取，最终通过输出层生成预测结果。 1.4 层与层之间的连接层与层之间的连接由权重矩阵决定。每一层的节点与下一层的每个节点相连，连接的强度由权重值决定。在前向传播过程中，输入层的节点将输入数据传递给第一个隐藏层的节点，后者再将处理后的数据传递给下一个隐藏层，依此类推，直到输出层。 2. 权重权重是连接神经网络中不同层节点的参数，用于调节输入信号在网络中的传递和变换强度。每个连接都有一个权重，表示输入信号对输出信号的影响力。 调节信号强度：权重乘以输入信号后，再通过求和和激活函数的变换，决定了输出信号的值。不同的权重值代表输入信号的重要程度。 特征学习：通过学习和调整权重，神经网络能够识别和提取输入数据中的重要特征。 优化：在训练过程中，权重被调整以最小化预测误差。通过反向传播算法，权重的值不断更新，使得模型的预测更加准确。 2.1 权重的存在形式权重并不存在于单独的节点内，而是存在于节点之间的连接上。具体来说，每一层的节点与下一层的节点之间的连接由一组权重参数表示。权重矩阵表示了两个层之间所有节点连接的权重值。 2.2 权重的初始化和调整权重的初始化方法有多种，包括零初始化、随机初始化、Xavier初始化和He初始化等。这些方法旨在为模型提供一个良好的起点，以便更好地进行训练。 2.3 权重的训练调整在训练过程中，权重通过优化算法进行调整。最常用的优化算法是梯度下降（Gradient Descent）及其变种（如随机梯度下降、Adam优化算法等）。训练步骤如下： 前向传播：计算网络的预测输出。 计算损失：通过损失函数衡量预测输出与真实标签之间的差距。 反向传播：计算损失函数对每个权重的梯度。 更新权重：使用梯度下降法更新权重，以最小化损失函数。 2.4 优化算法为了提高训练效率和稳定性，可以使用各种优化算法，包括： 动量（Momentum）：结合当前梯度和之前更新的方向，加速收敛。 AdaGrad：根据过去的梯度调整学习率，适应性地进行参数更新。 RMSProp：改进AdaGrad，使用指数加权平均计算梯度平方和，避免学习率过快减小。 Adam：结合动量和RMSProp的优点，适应性地调整学习率和动量，广泛应用于各种神经网络训练。 2.5 权重在不同类型神经网络中的角色不同类型的神经网络中，权重的具体作用可能有所不同： 前馈神经网络（Feedforward Neural Networks, FNNs）：权重连接每一层的所有节点，负责将输入数据逐层传递和变换。 卷积神经网络（Convolutional Neural Networks, CNNs）：权重是卷积核的参数，负责在局部感知野上提取特征。 递归神经网络（Recurrent Neural Networks, RNNs）：权重用于处理序列数据，包括当前时间步的输入与前一时间步的隐藏状态之间的关系。 3. 偏置（Biases）偏置是每个节点附加的一个参数，用于调整节点的输出独立于输入信号。偏置帮助神经网络学到更灵活的决策边界。 作用 调节输出：偏置提供一个额外的自由度，使得神经网络能够更好地拟合数据。 避免零输出：在输入信号为零的情况下，偏置确保节点仍然能够产生非零输出。 4. 激活函数（Activation Function）激活函数（Activation Function）是神经网络中的一个关键组件，它引入了非线性变换，使得神经网络能够学习和表示复杂的非线性关系。如果没有激活函数，神经网络的每一层只进行线性变换，那么无论多少层的堆叠，整体仍然是一个线性变换。这将极大限制神经网络的表示能力。因此，激活函数对于神经网络的性能和能力至关重要。 线性（Linear）和非线性（Nonlinear）是数学和信号处理中两个基本的概念，这些概念在神经网络和机器学习中也具有重要意义。理解这两个概念有助于掌握为什么激活函数对神经网络的性能如此重要。 4.1 线性（Linear）vs 非线性（Nonlinear）4.1.1 线性（Linear）线性关系是指两个变量之间的关系可以用一个线性方程表示。对于一个变量 $x$ 和其对应的输出 $y$，线性关系可以表示为：$y = mx + b$其中，$m$ 是斜率，$b$ 是截距。这意味着如果我们绘制 $y$ 对 $x$ 的图像，它将是一条直线。 特点 叠加性：线性系统满足叠加原理，即输入的线性组合会产生输出的线性组合。如果 $f(x_1) = y_1$​ 和$f(x_2) = y_2$，那么对于任何常数 $a$和 $b$，有 $f(ax_1 + bx_2) = ay_1 + by_2$​。 同质性：线性系统满足同质性，即输入的放大会导致输出的相应放大。如果 $f(x) = y$，那么对于任何常数 $k$，有 $f(kx) = ky$。 在神经网络中的应用在神经网络中，线性变换通常通过矩阵乘法和加法实现，例如输入与权重矩阵的乘积加上偏置：$z = W \\cdot x + b$ 4.1.2 非线性（Nonlinear）非线性关系是指两个变量之间的关系不能用一个简单的线性方程表示。非线性关系的数学表示形式可以非常多样，常见的形式包括多项式、指数函数、对数函数、三角函数等。例如，对于变量 $x$ 和 $y$，非线性关系可以表示为：$y=ax^2+bx+c$其中，$a$、$b$、$c$ 是常数。这意味着如果我们绘制 $y$ 对 $x$ 的图像，它将不是一条直线，而是一个曲线。特点 非叠加性：非线性系统不满足叠加原理。如果 $f(x_1) = y_1​$ 和 $f(x_2) = y_2​$，那么 $f(ax_1 + bx_2) eq ay_1 + by_2$​。 复杂性：非线性系统可以表示复杂的关系和模式，能够捕捉到数据中的复杂结构和动态。 为什么需要非线性如果神经网络只使用线性激活函数（例如，恒等函数 f(z)=z），那么无论网络有多少层，其最终输出仍然是输入的线性变换。也就是说，整个网络等效于一个单层的线性模型，无法捕捉数据中的复杂关系。因此，引入非线性激活函数使得网络具有更强的表达能力，能够学习和表示复杂的非线性关系，从而解决更复杂的问题。 4.2 常见的非线性激活函数4.2.1 Sigmoid 函数$σ(z)=\\frac{1}{1+e^{−z}} ​$ 特点： 输出值在0到1之间，适用于概率预测。 在极值区间梯度较小，可能导致梯度消失问题。 计算复杂度较高。 应用： 常用于二分类问题的输出层。 4.2.2 Tanh（双曲正切）函数$tanh(z)=\\frac{e^z-e^{-z}}{e^z+e^{-z}}$​特点： 输出值在-1到1之间。 相对于Sigmoid函数，Tanh函数的输出均值为0，使得数据更中心化。 也存在梯度消失问题，但在0附近的梯度较大，梯度消失问题稍好于Sigmoid。 应用： 常用于隐藏层。4.2.3 ReLU（Rectified Linear Unit）函数$ReLU(z)=max(0,z)$ 特点： 计算简单，收敛速度快。 在正区间保持线性关系，在负区间输出为0。 解决了Sigmoid和Tanh的梯度消失问题。 可能导致部分神经元“死亡”，即在训练过程中某些神经元的输出始终为0，不再更新。 应用： 广泛用于隐藏层。4.2.4 Leaky ReLU 函数$Leaky ReLU(z)=max(αz,z)$ 特点： 解决了ReLU的“死亡神经元”问题。 在负区间给定一个很小的斜率（通常为0.01）。 应用： 替代ReLU，在隐藏层中使用4.2.5 Softmax 函数$Softmax(z_i​)=\\frac{e^z_i}{∑_j​​e^z_j} ​$ 特点： 将输出值转换为概率分布，总和为1。 适用于多分类问题。 应用： 常用于多分类问题的输出层。4.2.6 Swish 函数$Swish(z)=z⋅σ(z)=\\frac{z}{1+e^{−z}} ​​$ 特点： 平滑的非线性函数，性能优于ReLU和Sigmoid。 由Google提出，结合了ReLU和Sigmoid的特点。 应用： 新型激活函数，在一些深度学习模型中表现出色。 4.3 激活函数的选择激活函数的选择对于神经网络的训练和性能有重要影响。以下是一些常见的选择准则： 隐藏层：通常使用ReLU或其变种（如Leaky ReLU、Swish），因为它们计算简单且能有效缓解梯度消失问题。 输出层： 回归问题：使用线性激活函数。 二分类问题：使用Sigmoid函数。 多分类问题：使用Softmax函数 5 训练过程假设我们有一个简单的神经网络，包含一个输入层、一个隐藏层和一个输出层： 输入层**：2个节点，表示输入特征 $x_1$ 和 $x_2​$。 隐藏层：2个节点，表示隐藏状态 $h_1$ 和 $h_2$​，偏置向量分别为$b_1$、$b_2$,使用ReLU激活函数。 输出层：1个节点，表示输出 $y$，偏置向量分别为$b_3$,使用线性激活函数。 权重矩阵 输入层到隐藏层的权重：假设权重为 $W^{(1)} = \\begin{bmatrix} W_{11} &amp; W_{12} \\ W_{21} &amp; W_{22} \\end{bmatrix}$,其中 $W_{11}​$、$W_{12}$​ 连接 $x_1$​ 到 $h_1$​ 和 $h_2$​，$W_{21}​$、$W_{22}$​ 连接 $x_2$​ 到 $h_1$​ 和 $h_2​$。 隐藏层到输出层的权重：假设权重为 $W^{(2)} = \\begin{bmatrix} W_{31} &amp; W_{32} \\end{bmatrix}$ $W_{31}$​ 和 $W_{32}$分别连接$h_1$ 和$h_2​$到 $y$。其中 $W_{31}$、$W_{32}$分别连接 $h_1$和 $h_2$到 $y$ 如果指定具体数据，可以设置为 输入数据为$\\mathbf{X} = [0.5, 0.6]$ 隐藏层权重矩阵 $\\mathbf{W}^{(1)} = \\begin{bmatrix} 0.1 &amp; 0.2 \\ 0.3 &amp; 0.4 \\end{bmatrix}$ 隐藏层偏置向量 $\\mathbf{b}^{(1)} = \\begin{bmatrix} 0.1 \\ 0.2 \\end{bmatrix}$ 输出层权重矩阵 $\\mathbf{W}^{(2)} = \\begin{bmatrix} 0.5 &amp; 0.6 \\end{bmatrix}$ 输出层偏置向量$\\mathbf{b}^{(2)} = \\begin{bmatrix} 0.3 \\end{bmatrix}$ 在训练过程中，通过调整权重和偏置，使得模型的预测结果尽可能准确。以下的主要步骤. 5.1 前向传播（Forward Propagation）前向传播是数据从输入层经过隐藏层传递到输出层的过程。在这个过程中，每一层的节点接收前一层的输出，进行加权求和，并通过激活函数生成输出。具体步骤如下： 加权求和：每个节点接收前一层所有节点的输出，计算加权和。 $z_i = \\sum_{j} w_{ij} x_j + b_i$​ 其中，$z_i$ 是第 $i$ 个节点的加权和，$w_{ij}$ 是从第 $j$ 个输入到第 $i$ 个节点的权重，$x_j$是第 $j$ 个输入，$b_i$​ 是偏置。 激活函数：对加权和应用激活函数，生成节点的输出。 $a_i = f(z_i)$常用的激活函数包括Sigmoid、Tanh和ReLU。 5.1.1 输入层输入层接收外部数据，将其传递给第一个隐藏层。假设输入数据为 $\\mathbf{X} = [x_1, x_2]$ 5.1.2 隐藏层 计算隐藏层的输入加权和：$z_1^{(1)} = w_{11}x_1 + w_{12}x_2 + b_1$ $z_2^{(1)} = w_{21}x_1 + w_{22}x_2 + b_2$ 代入具体数据：$z^{(1)} = \\mathbf{W}^{(1)} \\mathbf{X} + \\mathbf{b}^{(1)} = \\begin{bmatrix} 0.1 &amp; 0.2 \\ 0.3 &amp; 0.4 \\end{bmatrix} \\begin{bmatrix} 0.5 \\ 0.6 \\end{bmatrix} + \\begin{bmatrix} 0.1 \\ 0.2 \\end{bmatrix} = \\begin{bmatrix} 0.1 \\cdot 0.5 + 0.2 \\cdot 0.6 + 0.1 \\ 0.3 \\cdot 0.5 + 0.4 \\cdot 0.6 + 0.2 \\end{bmatrix} = \\begin{bmatrix} 0.27 \\ 0.62 \\end{bmatrix}$ 应用激活函数，计算隐藏层的输出：$h_1 = \\text{ReLU}(z_1^{(1)})$ $h_2 = \\text{ReLU}(z_2^{(1)})$ $h^&#123;(1)&#125; = \\text&#123;ReLU&#125;(z^&#123;(1)&#125;) = \\begin&#123;bmatrix&#125; \\max(0, 0.27) \\\\ \\max(0, 0.62) \\end&#123;bmatrix&#125; = \\begin&#123;bmatrix&#125; 0.27 \\\\ 0.62 \\end&#123;bmatrix&#125;$ 5.1.3 输出层 计算输出层的输入加权和：$z^{(2)} = w_{31}h_1 + w_{32}h_2 + b_3$$z^{(2)} = \\mathbf{W}^{(2)} a^{(1)} + \\mathbf{b}^{(2)} = \\begin{bmatrix} 0.5 &amp; 0.6 \\end{bmatrix} \\begin{bmatrix} 0.27 \\ 0.62 \\end{bmatrix} + \\begin{bmatrix} 0.3 \\end{bmatrix} = 0.5 \\cdot 0.27 + 0.6 \\cdot 0.62 + 0.3 = 0.735$ 应用激活函数，计算最终输出：$y = z^{(2)}$假设输出层使用线性激活函数（即不做非线性变换）$y = z^{(2)} = 0.735$5.2 计算损失（Loss Calculation） 使用损失函数计算预测输出与真实标签之间的差异。损失函数是一个衡量模型预测误差的指标，常见的损失函数包括均方误差（MSE）和交叉熵损失。 均方误差（MSE, Mean Squared Error）：用于回归问题。 $\\text{MSE} = \\frac{1}{N} \\sum_{i=1}^N (y_i - \\hat{y}_i)^2$ 交叉熵损失（Cross-Entropy Loss）：用于分类问题。 $\\text{Cross-Entropy} = -\\sum_{i=1}^N y_i \\log(\\hat{y}_i)$ 5.3 反向传播（Backpropagation）反向传播算法通过计算损失函数对每个模型参数（权重和偏置）的偏导数/梯度，来指导参数更新，使得损失函数逐步减小，从而提高模型的准确性。 计算梯度：首先计算输出层节点的损失梯度，即损失函数对输出层每个节点输出的偏导数。然后通过链式法则，依次计算每个隐藏层节点的梯度。梯度由后一层节点的梯度和当前层节点的输出值共同决定。 传播误差：误差从输出层逐层传播回输入层，计算每个参数的梯度。 ∂ 是偏导数符号 5.3.1 偏导数和梯度偏导数表示在固定其他变量的情况下，一个变量的变化率。假设 $f(x, y)$ 是一个关于 $x$ 和 $y$的函数，则 $f$ 对 $x$ 的偏导数记作 $\\frac{\\partial f}{\\partial x}$。 在神经网络中，偏导数用于计算梯度，帮助反向传播算法更新权重。梯度是损失函数关于每个参数的导数，表示损失函数变化率。对于一个权重 $w$，梯度 $\\frac{\\partial L}{\\partial w}$ 表示权重变化对损失函数 $L$ 的影响。具体而言，梯度表示损失函数相对于每个参数的偏导数： $\\frac{\\partial L}{\\partial W} = \\text{梯度}$ 通过计算每个参数的偏导数，反向传播算法能逐步调整网络权重，使得损失函数 $L$ 最小化，提高模型的预测能力。 5.3.2 偏导数推导过程如果 $f(x, y) = x^2 + y^2$，则对 $x$ 的偏导数为： $\\frac{\\partial f}{\\partial x} = \\frac{\\partial (x^2 + y^2)}{\\partial x} = 2x$ 根据求导法则，分开对每一项求导：$\\frac{\\partial f}{\\partial x} = \\frac{\\partial (x^2 + y^2)}{\\partial x} =\\frac{\\partial}{\\partial x} (x^2) + \\frac{\\partial}{\\partial x} (y^2)$ 对于 $x^2$，使用幂函数求导法则 $\\frac{\\partial}{\\partial x} (x^n) = nx^{n-1}$：$\\frac{\\partial}{\\partial x} (x^2) = 2x^{2-1}= 2x$对于 $y^2$，因为$y$ 被视为常数，对 $x$ 求导结果为 0：$\\frac{\\partial}{\\partial x} (y^2) = 0$ 同理，对 $y$ 的偏导数为： $\\frac{\\partial f}{\\partial y} = \\frac{\\partial (x^2 + y^2)}{\\partial y} = 2y$ 现在根据以上理解逐层反向计算每个参数的梯度 5.3.3 计算输出层的梯度假设我们使用均方误差（MSE）作为损失函数：$L = \\frac{1}{2} (y - t)^2$ 其中，$t$ 是目标值。 首先，计算损失相对于输出 $y$ 的梯度： $\\frac{\\partial L}{\\partial y} = y - t$ 然后，计算损失相对于隐藏层到输出层权重 $W_{31}$​ 和 $W_{32}$的梯度： $\\frac{\\partial L}{\\partial W_{31}} = \\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial y}{\\partial W_{31}}=\\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial (w_{31}h_1 + w_{32}h_2 + b_3)}{\\partial W_{31}} = (y - t) \\cdot h_1$ 由于 $W_{31}$和 $h_1$​ 相乘，而 $h_1$​ 不依赖于 $W_{31}$，其余项在偏导数计算中都是常数，因此可以忽略。所以 在这个表达式中，$W_{31}$和 $h_1$​ 相乘，其余项与 $W_{31}$无关，因此在对 $W_{31}​$ 求导时可以忽略。$\\frac{\\partial L}{\\partial W_{31}} = \\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial y}{\\partial W_{31}}=\\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial (w_{31}h_1)}{\\partial W_{31}}$ 根据幂函数求导法则 $\\frac{\\partial}{\\partial x} (x^n) = nx^{n-1}$根据线性求导法则，常数项可以直接提取出来 $\\frac{\\partial}{\\partial x} (a\\cdot x) = a$ $\\frac{\\partial L}{\\partial W_{31}} = \\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial y}{\\partial W_{31}}=\\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial (w_{31}h_1)}{\\partial W_{31}} = \\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial (w_{31}h_1)}{\\partial W_{31}}= (y-t) \\cdot h_1$ 同理可得：$\\frac{\\partial L}{\\partial W_{32}} = \\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial y}{\\partial W_{32}} = (y - t) \\cdot h_2$ 计算损失相对于偏置 $b_3​$ 的梯度： $\\frac{\\partial L}{\\partial b_3} = \\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial y}{\\partial b_3} = (y - t) \\cdot 1 = y - t$ 5.3.4 计算隐藏层的梯度对于隐藏层的梯度，需要计算损失相对于隐藏状态 $h_1$​ 和 $h_2$​ 的梯度： $\\frac{\\partial L}{\\partial h_1} = \\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial y}{\\partial h_1} = (y - t) \\cdot W_{31}$ $\\frac{\\partial L}{\\partial h_2} = \\frac{\\partial L}{\\partial y} \\cdot \\frac{\\partial y}{\\partial h_2} = (y - t) \\cdot W_{32}$ 其中，$y = w_{31}h_1 + w_{32}h_2 + b_3$ 计算推导过程同上，可以得到以上结果 由于隐藏层使用的是ReLU激活函数，其导数为： $\\frac{\\partial \\text{ReLU}(z)}{\\partial z} = \\begin{cases} 1 &amp; \\text{if } z &gt; 0 \\ 0 &amp; \\text{if } z \\leq 0 \\end{cases}$ 其中 $h_1 = \\text{ReLU}(z_1^{(1)})$ 因此应用链式法则后： $\\frac{\\partial L}{\\partial z_1} = \\frac{\\partial L}{\\partial h_1} \\cdot \\frac{\\partial h_1}{\\partial z_1} = (y - t) \\cdot W_{31} \\cdot \\begin{cases} 1 &amp; \\text{if } z_1 &gt; 0 \\ 0 &amp; \\text{if } z_1 \\leq 0 \\end{cases}$ $\\frac{\\partial L}{\\partial z_2} = \\frac{\\partial L}{\\partial h_2} \\cdot \\frac{\\partial h_2}{\\partial z_2} = (y - t) \\cdot W_{32} \\cdot \\begin{cases} 1 &amp; \\text{if } z_2 &gt; 0 \\ 0 &amp; \\text{if } z_2 \\leq 0 \\end{cases}$ 5.3.5 计算输入层的梯度最后，计算损失相对于输入层权重 $W_{11}, W_{12}, W_{21}, W_{22}$​ 的梯度： $\\frac{\\partial L}{\\partial W_{11}} = \\frac{\\partial L}{\\partial z_1} \\cdot \\frac{\\partial z_1}{\\partial W_{11}} = \\frac{\\partial L}{\\partial z_1} \\cdot x_1$ $\\frac{\\partial L}{\\partial W_{12}} = \\frac{\\partial L}{\\partial z_2} \\cdot \\frac{\\partial z_2}{\\partial W_{12}} = \\frac{\\partial L}{\\partial z_2} \\cdot x_1$ $\\frac{\\partial L}{\\partial W_{21}} = \\frac{\\partial L}{\\partial z_1} \\cdot \\frac{\\partial z_1}{\\partial W_{21}} = \\frac{\\partial L}{\\partial z_1} \\cdot x_2$ $\\frac{\\partial L}{\\partial W_{22}} = \\frac{\\partial L}{\\partial z_2} \\cdot \\frac{\\partial z_2}{\\partial W_{22}} = \\frac{\\partial L}{\\partial z_2} \\cdot x_2$​ 5.4 更新权重（Weight Update）使用梯度下降算法根据计算得到的梯度调整权重。梯度下降的基本公式为：$W_{new​}=W_{old}​−η⋅\\frac{\\partial L}{\\partial W}$ 其中，$\\eta$ 是学习率（Learning Rate），$\\frac{\\partial L}{\\partial W}$​ 是损失函数对权重的梯度。 常见的梯度下降变种 批量梯度下降（Batch Gradient Descent）：在整个训练数据集上计算梯度，然后更新权重。适用于小数据集，但计算量大，效率较低。 随机梯度下降（Stochastic Gradient Descent, SGD）：在每个训练样本上计算梯度，然后更新权重。计算效率高，但梯度噪声大，收敛不稳定。 小批量梯度下降（Mini-Batch Gradient Descent）：在小批量训练样本上计算梯度，然后更新权重。结合了批量和随机梯度下降的优点，常用在实际训练中。 7. 超参数（Hyperparameters） vs 模型参数（Parameters）超参数（Hyperparameters）： 定义：超参数是指在模型训练之前需要手动设置的参数，不通过训练数据学习得到，而是通过试验、经验或自动调优方法设定。 作用：控制模型的训练过程、模型复杂度、正则化程度等。 示例：学习率（learning rate）、批大小（batch size）、隐藏层的数量和大小、正则化系数（如L2正则化中的λ）、训练轮数（epochs）等。 调整方法：手动调试（Manual Tuning）、网格搜索（Grid Search）、随机搜索（Random Search）、贝叶斯优化（Bayesian Optimization）等。 调整频率：通常在训练之前设定，在训练过程中不变。可能需要多次试验和调优过程才能确定最佳超参数。 模型参数（Model Parameters）： 定义：模型参数是指在模型训练过程中通过数据学习得到的参数，这些参数定义了模型的最终形态和行为。 作用：直接影响模型的预测输出，反映了模型从数据中学到的知识。 示例：神经网络中的权重和偏置、线性回归中的回归系数、支持向量机中的支持向量等。 调整方法：通过训练数据和优化算法（如梯度下降）自动调整。 调整频率：在每个训练迭代中都要更新，直到模型收敛或达到预设的训练轮数。 神经网络中的超参数和模型参数超参数： 学习率（Learning Rate）：决定每次权重更新的步长。 批大小（Batch Size）：决定每次权重更新时使用的训练样本数量。 隐藏层数和每层神经元数量：定义神经网络的结构和复杂度。 正则化系数：控制正则化项在损失函数中的权重，防止过拟合。 训练轮数（Epochs）：模型在整个训练数据集上完整训练的次数。 模型参数： 权重（Weights）：连接神经元的权重，表示输入特征的重要性。 偏置（Biases）：每个神经元的偏置，用于调整激活函数的输出。 8. 序列数据 vs 非序列数据1. 序列数据（Sequential Data）序列数据（Sequential Data）是指按照时间或其他顺序排列的数据，其中每个数据点的意义和价值都依赖于它在序列中的位置和前后数据点的关系。序列数据广泛存在于许多实际应用中，如时间序列、自然语言处理、语音识别等。 序列数据的特点 时间依赖性：序列数据中的每个数据点与其前后数据点存在依赖关系。这种依赖性可以是短期的（仅依赖于最近的数据点）或长期的（依赖于较早的数据点）。 顺序关系：序列数据的顺序是至关重要的，数据点的顺序关系决定了其实际意义。例如，在语音信号中，音频帧的顺序决定了最终语音的内容。 动态性：序列数据往往是动态变化的，数据点的值随时间或其他顺序变化而变化。 递归神经网络（RNN）和其变体如LSTM和GRU擅长处理序列数据 2. 非序列数据非序列化数据是指那些数据点之间没有时间或顺序依赖关系的数据。与序列化数据（如时间序列、文本、语音信号等）不同，非序列化数据中的每个数据点都是独立的，不依赖于前后的数据点。非序列化数据在各种领域中广泛存在，包括图像数据、表格数据（结构化数据）、图数据等。不同类型的非序列化数据可以通过不同的神经网络进行处理，如卷积神经网络（CNN）处理图像数据，前馈神经网络（FNN）处理表格数据，图神经网络（GNN）处理图数据。在实际应用中，选择合适的神经网络模型能够有效地处理各种非序列化数据，解决实际问题。 非序列化数据的实际应用1. 图像数据的应用图像数据是高维非序列数据，具有空间结构特性。卷积神经网络（CNN）是处理图像数据的主要神经网络类型。 医疗影像分析：通过CNN处理医疗影像（如MRI、CT图像），进行疾病诊断和分类。 自动驾驶：使用CNN分析汽车摄像头捕捉的道路图像，识别行人、交通标志和其他车辆。图像分类：使用CNN对输入图像进行分类。例如，ImageNet数据集上的物体识别任务。 具体应用：卷积层提取图像的局部特征，池化层减少特征维度，全连接层进行分类。 典型模型：AlexNet、VGG、ResNet等。图像分割：将图像划分为具有不同语义意义的区域。例如，自动驾驶中的道路标记识别。 具体应用：利用全卷积神经网络（FCN）或U-Net对图像进行像素级分类。 典型模型：U-Net、SegNet等。 2. 表格数据的应用表格数据通常存储在数据库或电子表格中，包含多种特征和目标变量。前馈神经网络（FNN）适用于处理表格数据。回归分析：预测连续值，如房价预测。 具体应用：输入层接收多种特征，隐藏层提取特征之间的复杂关系，输出层给出预测值。 典型模型：多层感知器（MLP）。-分类任务：对数据进行分类，如信用卡欺诈检测。 具体应用：输入层接收各特征值，隐藏层提取特征间关系，输出层进行分类。 典型模型：多层感知器（MLP）。 客户分类：使用FNN对客户进行分类，如根据客户购买行为预测客户流失风险。 3. 图数据的应用图数据由节点和边构成，具有复杂的连接结构。图神经网络（Graph Neural Networks, GNNs）专门用于处理图数据。 节点分类：在图中为每个节点分配标签，如社交网络中的用户分类。 具体应用：图卷积神经网络（GCN）通过聚合邻居节点的信息更新每个节点的表示，然后进行分类。 典型模型：GCN、GraphSAGE。图分类：对整个图进行分类，如分子结构的化学性质预测。 具体应用：将图嵌入到固定长度的向量表示中，然后使用前馈神经网络进行分类。 典型模型：DGCNN、GraphSAGE。 社交网络分析：通过GNN分析社交网络中的用户关系，进行用户分类和推荐系统。 化学分子建模：使用GNN分析化学分子结构，预测分子的物理和化学性质。 9. 向量在神经网络中，向量是一个重要的数学工具，用于表示和操作多个数值。向量在神经网络的各个部分都有广泛的应用，包括输入数据、权重、偏置、激活值等。为了更好地理解向量在神经网络中的角色，我们可以从以下几个方面进行详细阐述： 向量的定义一个向量是一个具有方向和大小的数量集合，通常用一维数组来表示。在神经网络中，向量可以用来表示输入特征、隐藏层的激活值、输出值以及模型的权重和偏置。 向量在神经网络中的具体应用1. 输入向量输入向量表示神经网络接收到的原始数据。在一个简单的前馈神经网络中，输入向量通常是一个包含多个特征的数据点。例如，对于一个图像分类任务，每个输入向量可能代表一张图像的像素值。 示例： 对于一个具有三个特征的输入数据点$(x_1, x_2, x_3)$，输入向量可以表示为：$\\mathbf{x} = \\begin{bmatrix} x_1 \\ x_2 \\ x_3 \\end{bmatrix}$ 2. 权重向量权重向量表示神经元之间的连接强度。在神经网络中，每个神经元的输出都是前一层神经元输出的加权和。权重向量决定了输入特征对输出的影响程度。 示例： 对于一个具有三个输入特征的神经元，其权重向量可以表示为： $\\mathbf{w} = \\begin{bmatrix} w_1 \\ w_2 \\ w_3 \\end{bmatrix}$ 3. 偏置向量偏置向量是一个额外的参数，用于调整神经元的输出，使其能够更好地拟合数据。偏置向量与权重向量一起，影响每个神经元的输出。 示例： 对于一个具有三个输入特征的神经元，其偏置向量可以表示为： $\\mathbf{b} = b$ 4. 激活值向量激活值向量表示神经网络中每一层的输出。在前向传播过程中，输入向量与权重向量相乘并加上偏置向量，经过激活函数后得到的值即为激活值。 示例： 对于一个具有三个神经元的隐藏层，其激活值向量可以表示为： $\\mathbf{a} = \\begin{bmatrix} a_1 \\ a_2 \\ a_3 \\end{bmatrix}$ 向量操作在神经网络中，常见的向量操作包括向量加法、向量乘法（点积）、标量乘法和向量的激活函数应用。 1. 向量加法向量加法是将两个向量的对应元素相加。假设有两个向量 $\\mathbf{a}$ 和 $\\mathbf{b}$，它们的向量加法表示为： $\\mathbf{c} = \\mathbf{a} + \\mathbf{b}$$\\mathbf{c} = \\begin{bmatrix} a_1 + b_1 \\ a_2 + b_2 \\ a_3 + b_3 \\end{bmatrix}$ 2. 向量乘法（点积）向量点积是将两个向量的对应元素相乘并求和。假设有两个向量 a\\mathbf{a}a 和 $\\mathbf{b}$，它们的点积表示为：$c = \\mathbf{a} \\cdot \\mathbf{b}$$c = a_1 \\cdot b_1 + a_2 \\cdot b_2 + a_3 \\cdot b_3$ 3. 标量乘法标量乘法是将向量的每个元素乘以一个标量。假设有一个向量 $\\mathbf{a}$ 和一个标量 $k$，它们的标量乘法表示为： $\\mathbf{b} = k \\cdot \\mathbf{a}$ $\\mathbf{b} = \\begin{bmatrix} k \\cdot a_1 \\ k \\cdot a_2 \\ k \\cdot a_3 \\end{bmatrix}$ 示例：前向传播中的向量运算以一个简单的两层神经网络为例，说明向量在前向传播中的应用。 输入层：输入向量 $\\mathbf{x}$$\\mathbf{x} = \\begin{bmatrix} x_1 \\ x_2 \\end{bmatrix}$ 隐藏层：权重向量 $\\mathbf{W}$ 和偏置向量 $\\mathbf{b}$$\\mathbf{W} = \\begin{bmatrix} w_{11} &amp; w_{12} \\ w_{21} &amp; w_{22} \\end{bmatrix}$ $\\mathbf{b} = \\begin{bmatrix} b_1 \\ b_2 \\end{bmatrix}$ 计算隐藏层激活值：$\\mathbf{z} = \\mathbf{W} \\cdot \\mathbf{x} + \\mathbf{b}$ $\\mathbf{z} = \\begin{bmatrix} w_{11}x_1 + w_{12}x_2 + b_1 \\ w_{21}x_1 + w_{22}x_2 + b_2 \\end{bmatrix}$ 应用激活函数（如ReLU）：$\\mathbf{a} = \\text{ReLU}(\\mathbf{z})$$\\mathbf{a} = \\begin{bmatrix} \\text{ReLU}(z_1) \\ \\text{ReLU}(z_2) \\end{bmatrix}$ 输出层：权重向量 $\\mathbf{W’}$ 和偏置 $\\mathbf{b’}$$\\mathbf{W’} = \\begin{bmatrix} w_{31} &amp; w_{32} \\end{bmatrix}$$\\mathbf{b’} = b’$ 计算输出值：$y = \\mathbf{W’} \\cdot \\mathbf{a} + \\mathbf{b’}$$y = w_{31}a_1 + w_{32}a_2 + b’$ 9. 误差训练误差、测试误差和验证误差是三个不同的概念，它们分别衡量模型在不同数据集上的表现。这些误差帮助我们评估模型的拟合程度和泛化能力 9.1 区别和联系 训练误差：衡量模型在训练数据上的表现，主要用于训练过程中调整模型参数。 验证误差：衡量模型在验证数据上的表现，主要用于超参数调优和模型选择。验证数据是从训练数据中分离出来的一部分，不参与模型训练。 测试误差：衡量模型在测试数据上的表现，主要用于评估模型的最终泛化能力。测试数据在训练和验证过程中都不使用，只有在模型训练完成后才用于评估。9.2 训练误差（Training Error） 训练误差是指模型在训练数据上的误差。它反映了模型对训练数据的拟合程度。计算方法 训练误差通常通过在训练数据上计算损失函数（例如均方误差、交叉熵损失等）来得到。例如，如果使用均方误差（MSE）作为损失函数，训练误差可以表示为： $\\text{MSE}_{\\text{train}} = \\frac{1}{N_{\\text{train}}} \\sum_{i=1}^{N_{\\text{train}}} (y_i - \\hat{y}_i)^2$ 其中，NtrainN_{\\text{train}}Ntrain​ 是训练数据的样本数量，yiy_iyi​ 是第 iii 个样本的真实值，y^i\\hat{y}_i y^​i​ 是模型对第 iii 个样本的预测值。 目标最小化训练误差，以便模型能够良好地拟合训练数据。 意义低训练误差表明模型能够很好地拟合训练数据。但这并不一定意味着模型在新数据上的表现也会良好。 9.2 预测误差/测试误差预测误差/测试误差 是指模型在未见过的数据（通常是测试数据或验证数据）上的误差。它反映了模型的泛化能力，即模型在新数据上的表现。 计算方法：在模型训练完成后，使用测试数据或验证数据计算损失函数的值，计算方法与训练误差类似 目标：评估模型的泛化能力，期望模型在测试数据上的误差尽可能低。 意义：低预测误差表明模型具有良好的泛化能力，能够在新数据上表现良好。 9.3 误差的作用训练误差和预测误差的关系可以帮助我们诊断模型的状态，判断模型是否过拟合或欠拟合。 欠拟合（Underfitting）：模型在训练数据和测试数据上的误差都很高，说明模型复杂度不足，无法捕捉数据中的规律。 合适拟合（Good Fit）：模型在训练数据上的误差较低，并且在测试数据上的误差也较低，说明模型具有良好的泛化能力。 过拟合（Overfitting）：模型在训练数据上的误差很低，但在测试数据上的误差很高，说明模型过于复杂，捕捉到了训练数据中的噪声和细节，泛化能力较差。 10.过度拟合过度拟合（Overfitting）是机器学习中的一个常见问题，指的是模型在训练数据上表现良好，但在未见过的测试数据或实际应用中表现不佳。这通常是因为模型过于复杂，捕捉到了训练数据中的噪声和偶然性模式，而不是数据的潜在规律。 过度拟合的具体表现 训练误差低，测试误差高：模型在训练数据上的误差很低，但在测试数据或新数据上的误差很高。 高方差：模型对训练数据中的细节和噪声过于敏感，导致对不同数据集的表现差异很大。 复杂模型：过于复杂的模型（例如，具有太多参数的深度神经网络）容易过度拟合。 过度拟合的原因 模型复杂度高：模型的参数过多，能够拟合训练数据中的每一个细节和噪声。 训练数据不足：训练数据量过少，模型无法学习到数据的真实分布和规律。 噪声数据：训练数据中包含大量噪声，模型将这些噪声误认为是数据的潜在模式。 缺乏正则化：没有使用正则化技术来约束模型的复杂度。 如何检测过度拟合 训练误差与验证误差：在训练过程中，观察训练误差和验证误差的变化。如果训练误差持续下降，而验证误差在某个点之后开始上升，这通常是过度拟合的信号。 交叉验证：使用交叉验证技术评估模型在多个数据子集上的表现，避免模型对单一训练集的过度依赖。 学习曲线：绘制学习曲线（训练误差和验证误差随训练样本数量变化的曲线），分析模型的学习行为。 解决过度拟合的方法 增加训练数据：通过增加训练数据量，模型可以更好地学习数据的真实分布，减少对噪声的拟合。 简化模型：减少模型的参数数量或选择更简单的模型，避免过度拟合。 正则化：使用正则化技术（如L1和L2正则化）来约束模型参数，使其更平滑，减少对训练数据的过度拟合。 L1正则化：通过对模型参数的绝对值求和，使部分参数变为零，起到特征选择的作用。 L2正则化：通过对模型参数的平方和进行约束，使参数值尽可能小，从而使模型更平滑。 Dropout：在训练过程中随机丢弃一部分神经元，防止模型对某些路径的过度依赖。 数据增强：通过对训练数据进行旋转、缩放、裁剪等变换，生成更多的训练样本，增加数据的多样性。 早停法（Early Stopping）：在训练过程中监控验证误差，当验证误差不再下降时，提前停止训练，防止模型过度拟合。11. 泛化能力泛化能力（Generalization）是指机器学习模型在训练数据以外的数据（通常是未见过的测试数据或真实应用中的数据）上表现良好的能力。它反映了模型对数据的普遍规律的学习程度，而不是对训练数据的记忆程度。 一个具有良好泛化能力的模型能够有效地从训练数据中学习到潜在的规律，并将这些规律应用于新数据上，从而在实际应用中保持高效和准确的表现。 理解泛化能力需要考虑以下几个方面： 训练误差和测试误差如果模型在训练数据上的误差很低，但在测试数据上的误差很高，这通常表明模型过度拟合（Overfitting）。相反，如果模型在训练数据和测试数据上的误差都较低，这表明模型具有良好的泛化能力。 模型复杂度 简单模型：模型复杂度低，参数较少，容易欠拟合（Underfitting），即无法充分捕捉数据中的规律。 复杂模型：模型复杂度高，参数较多，容易过度拟合，即捕捉了训练数据中的噪声和偶然模式。一个具有良好泛化能力的模型应在简单和复杂之间取得平衡，既能捕捉数据的潜在规律，又不过度拟合噪声。 12.正则化正则化（Regularization）是一种在机器学习和统计学中用于防止模型过拟合（overfitting）的技术,提高模型泛化能力的关键技术。 正则化的类型 L1 正则化（Lasso 正则化）* 定义：在损失函数中添加所有模型参数绝对值的和。 数学表达： $\\text{Loss} = \\text{Original Loss} + \\lambda \\sum |w_i|$ 特点：可以导致一些参数完全为零，起到特征选择的作用。 L2 正则化（Ridge 正则化）： 定义：在损失函数中添加所有模型参数平方和。 数学表达： $\\text{Loss} = \\text{Original Loss} + \\lambda \\sum w_i^2$ 特点：可以防止参数变得过大，但不会使参数完全为零。 弹性网络（Elastic Net）正则化： 定义：结合 L1 和 L2 正则化。 数学表达：$\\text{Loss} = \\text{Original Loss} + \\lambda_1 \\sum |w_i| + \\lambda_2 \\sum w_i^2$ 特点：结合了 L1 和 L2 的优点，既可以选择特征又可以防止参数过大。 Dropout 正则化： 定义：在每次训练时随机丢弃一部分神经元，使得模型在训练过程中不会过于依赖某些特定的神经元。 特点：通过在训练过程中引入随机性，增强模型的鲁棒性。 正则化的原理 复杂度惩罚：通过向损失函数中添加一个表示模型复杂度的项，模型在训练时不仅要最小化原始损失函数，还要考虑模型的复杂度。 参数约束：限制模型参数的大小或数量，防止模型在训练数据上过度拟合。 增强泛化能力：通过控制模型的复杂度，提升模型在未见数据上的表现。 正则化在模型中的应用正则化技术在许多机器学习模型中应用广泛，包括线性回归、逻辑回归、支持向量机（SVM）、神经网络等。在实际应用中，正则化参数（如 λ\\lambdaλ）通常需要通过交叉验证等方法进行调优，以获得最佳的模型性能。","tags":["AI","神经网络","Ilya sutskever‘s 30  papers"]},{"title":"Ilya sutskever's approx 30 research papers about AI","path":"/17f5a37e/","content":"之前无意中刷到这个twitter, 有点好奇这30篇paper 到底讲了啥，学完到底能知道什么，所以决定读一读。 如何读作为一个算法和AI小白, 真的学会在今天90%关于AI 的内容有点超出能力范畴， 所以我的目标是读懂这些paper的文本内容，建立一个整体的大框架即可。 依然对于一个算法和AI小白来说，直接阅读paper,、会遇到大量读不懂的概念， 需要查询相关资料，我觉得如果你也是小白同时也对这些paper 感兴趣的话，我查询的资料和阅读过程对你也会有帮助，所以我会把这些内容都记录下来，供你参考。 阅读记录神经网络（Neural Networks） 递归神经网络（Recurrent Neural Networks, RNNs） The Unreasonable Effectiveness of Recurrent Neural Networks Understanding LSTM Networks RECURRENT NEURAL NETWORK REGULARIZATION) 30 research papershttps://arc.net/folder/D0472A20-9C20-4D3F-B145-D2865C0A9FEE The Annotated Transformer简介：Transformer 模型注释版，详细解析了 Transformer 模型的内部结构和工作原理。推荐理由：理解现代 NLP 模型的基础。 The First Law of Complexodynamics简介：探讨了复杂动力学的第一定律，解释了复杂系统的演变规律。推荐理由：提供了关于复杂系统的一些理论基础。 The Unreasonable Effectiveness of Recurrent Neural Networks简介：讨论了 RNN 在处理序列数据时的有效性。推荐理由：帮助理解 RNN 的应用和优势。 Understanding LSTM Networks简介：详细介绍了 LSTM 网络的结构和功能。推荐理由：LSTM 是 RNN 的重要变种，广泛应用于序列数据处理。 Recurrent Neural Network Regulation简介：探讨了 RNN 的正则化方法。推荐理由：正则化是提高模型泛化能力的重要手段。 Keeping Neural Networks Simple by Minimizing the Description Length of the Weights简介：通过最小化权重描述长度来简化神经网络。推荐理由：提供了一种简化模型的方法，提升模型的解释性。 Pointer Networks简介：介绍了指针网络及其在处理离散序列问题上的应用。推荐理由：拓展了对序列模型的认识。 ImageNet Classification with Deep Convolutional Neural Networks简介：深度卷积神经网络在 ImageNet 分类上的应用。推荐理由：经典论文，推动了深度学习在计算机视觉领域的革命。 Order Matters: Sequence to Sequence for Sets简介：讨论了顺序在序列到序列模型中的重要性。推荐理由：提供了对序列模型的深刻理解。 GPipe: Easy Scaling with Micro-Batch Pipeline Parallelism简介：介绍了通过微批次流水线并行实现模型扩展的方法。推荐理由：解决大规模模型训练的瓶颈问题。 Deep Residual Learning for Image Recognition简介：深度残差学习在图像识别中的应用。推荐理由：残差网络是深度学习的一大突破。 Multi-Scale Context Aggregation by Dilated Convolutions简介：通过膨胀卷积实现多尺度上下文聚合。推荐理由：在处理图像和信号时的有效方法。 Neural Message Passing for Quantum Chemistry简介：神经消息传递在量子化学中的应用。推荐理由：展示了神经网络在科学计算中的潜力。 Attention Is All You Need简介：Transformer 模型的奠基论文，提出了注意力机制。推荐理由：现代 NLP 模型的基石。 Neural Machine Translation By Jointly Learning To Align And Translate简介：通过联合学习对齐和翻译的神经机器翻译方法。推荐理由：NMT 的重要发展。 Identity Mappings in Deep Residual Networks简介：残差网络中的恒等映射。推荐理由：帮助理解深度网络的训练。 A simple neural network module for relational reasoning简介：用于关系推理的简单神经网络模块。推荐理由：增强模型的推理能力。 Variational Lossy Autoencoder简介：变分有损自编码器的介绍。推荐理由：提供了一种新颖的生成模型。 Relational recurrent neural networks简介：关系递归神经网络。推荐理由：结合关系推理和序列建模的优势。 Quantifying the Rise and Fall of Complexity in Closed Systems: The Coffee Automaton简介：定量分析封闭系统中复杂性的兴衰。推荐理由：理论性强，有助于理解复杂系统。 Neural Turing Machines简介：神经图灵机的概念和应用。推荐理由：连接神经网络和计算理论的重要工作。 Deep Speech 2: End-to-End Speech Recognition in English and Mandarin简介：端到端语音识别系统 Deep Speech 2 的介绍。推荐理由：语音识别领域的重要进展。 Scaling Laws for Neural Language Models简介：神经语言模型的规模法则。推荐理由：帮助理解模型扩展的规律。 A Tutorial Introduction to the Minimum Description Length Principle简介：最小描述长度原理的教程。推荐理由：理论基础，适用于多种模型选择问题。 Machine Super Intelligence简介：机器超级智能的讨论。推荐理由：未来 AI 发展的重要参考。 Kolmogorov Complexity and Algorithmic Randomness简介：Kolmogorov 复杂性和算法随机性的介绍。推荐理由：计算复杂性理论的经典。 CS231n Convolutional Neural Networks for Visual Recognition简介：CS231n 课程网站，包含卷积神经网络的详细教程。推荐理由：全面的学习资源，适合入门和进阶学习。","tags":["AI","神经网络","Ilya sutskever‘s 30  papers"]},{"title":"InnoDB事务-持久性的实现,binglog & redo log","path":"/6cb5dc64/","content":"在MySQL InnoDB 这个语境下， crash safe、数据不丢失 都指的是事务的持久性特性，即事务一旦提交，应当保证所有被成功提交的数据修改都能够正确地被持久化，不丢失数据, 即使宕机也能够恢复数据 在InnoDB 中，持久性 基于binlog 和redo log 实现， 且binlog 与redo log 的写入通过2PC 协调. 0 XA 事务：binlog 和redo log 的两阶段提交 在MySQL中，InnoDB存储引擎 的 redo log 和MySQL服务器层binlog 之间的一致性是通过内部的XA机制（即分布式事务）来实现的，任何一个数据出现问题都会进行会滚。 XA事务是一种分布式事务。通过两阶段提交协议和XA接口标准，事务管理器和资源管理器能够可靠地协同工作，实现跨系统的事务处理，确保多个独立资源的一致性。 在binlog 和redo log 的两阶段提交， binlog 充当协调者的角色。 关于XA 事务具体可在这篇文章中查看 binlog 和 redo log 各自写入的过程还有很多细节，接下来进行讲解 1 binlogbinlog是 MySQL 服务器层使用的日志文件，记录了所有修改数据库内容的SQL语句（如 INSERT, UPDATE, DELETE）,也被称为逻辑日志。 binlog 主要用于主备复制同步、崩溃恢复等功能。 1.1 binlog 的三种日志格式 格式 定义 优点 缺点 Statement-Based Logging (SBL) 记录执行的 SQL 语句本身，而不是每行数据的变更。 1. 空间效率高：通常占用更少的空间，因为记录的是 SQL 语句。 2. 易于审计：直接记录 SQL 语句，易于阅读和理解。 1. 非确定性行为：可能在主从复制中导致数据不一致，特别是涉及到非确定性函数（如 NOW()、RAND()）的 SQL 语句。2. 复制错误：某些特定情况下可能引起从服务器的复制错误。 Row-Based Logging (RBL) 记录数据变更前后的每行数据的具体变化，而不是执行的 SQL 语句。 1. 数据一致性：在复制过程中提供高度的数据一致性。2. 安全性更高：不记录 SQL 语句，降低了 SQL 注入的风险。 1. 空间占用大：因为记录了每一行的变化，可能导致 binlog 文件迅速增大。2. 可读性差：不记录 SQL 语句，对于人类审计不友好。 Mixed-Based Logging (MBL) 结合了 SBL 和 RBL 的特点，根据操作的类型自动选择使用基于语句的格式或基于行的格式记录。 1. 灵活性高：根据 SQL 语句的特性选择最合适的日志格式。2. 平衡性能和一致性：在确保数据一致性的同时考虑日志大小和性能。 1. 配置复杂：需要适当配置以确保效率和准确性。2. 预测性差：自动切换日志格式可能使得日志的结果难以预测。 1.2 binlog写入过程binlog 的写入逻辑比较简单：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。 1.2.1 binlog cache对于每个客户端会话，MySQL 服务器为其分配一个 binlog cache。这个缓存是用来临时存储一个事务中产生的所有 binlog 事件。 但是binlog cache 刷新到磁盘时 多个线程是共写同一份 binlog 文件。 当一个新事务开始时，根据binlog 日志格式记录 每个修改SQL 语句到binlog cache 中 1.2.2 page cache 与 磁盘刷新持久化当事务到达提交阶段时，首先将 binlog cache 中的内容 写入到binlog 文件中，然后提交事务到 InnoDB，即 commit redo log 。 注意，这里的写入并不是直接写到到磁盘，而是先写入到文件系统的page cache, 然后通过sync_binlog 参数来决定 何时把数据写入到 磁盘。 磁盘刷新频率通过 sync_binlog 配置参数， sync_binlog=0 的时候，表示每次提交事务都不主动刷新磁盘，由文件系统自己控制刷盘频率 sync_binlog=1 的时候，表示每次提交事务都会将 binlog cache 中的内容刷新到磁盘 sync_binlog=N(N&gt;1) 的时候，表示累积 N 个提交事务后才将多个binlog cache中的内容刷新到磁盘。 可以看到如果sync_binlog不设置为1 ，有有助于提高刷盘效率， 但是有丢失binlog 的风险。 1.2.3 binlog cache 不够用怎么办如果binlog cache 写满了怎么办？需要把数据暂存到磁盘 每个事务的 binlog 事件首先被写入到 binlog cache 中，这个缓存的大小由 binlog_cache_size 系统变量控制。 如果一个事务非常大，涉及大量的数据修改，导致binlog cache不足以存储当前事务的所有事件时，MySQL采用的处理机制是将缓存中的数据写入到磁盘上的一个临时文件中。这一过程可以分为以下几个步骤： 检测缓存溢出：当试图向binlog cache中写入数据，而缓存空间不足以容纳更多数据时，将触发溢出处理机制。 数据写入临时文件：MySQL将当前binlog cache中的数据写入到一个临时文件中。这个临时文件通常位于MySQL的数据目录下，具有唯一标识，确保数据的隔离和安全。 清空binlog cache：将数据写入临时文件后，binlog cache会被清空，为接下来的日志数据腾出空间。 继续事务日志的记录：事务继续执行，新的日志事件会再次被记录到现在已经被清空的binlog cache中。 事务提交：事务如果最终被提交，MySQL会将临时文件中的日志数据以及现在binlog cache中的数据一并写入到全局的binlog文件中。如果事务回滚，则临时文件和binlog cache中的数据都将被丢弃。 1.3 xidXID（Transaction Identifier） 可以理解成时MySQL server 层的事务唯一标识。 MySQL服务器内部维护一个全局事务ID计数器，每个新事务都会分配一个唯一的ID。该计数器在内存中递增，保证每个事务ID在实例中是唯一的。 当一个新事务开始时，MySQL服务器层会从全局计数器中获取一个新的事务ID，将其赋予该事务，并存储在该事务的上下文中。 2 redo logredo log是 InnoDB 存储引擎特有的日志文件，用于记录对数据库做出的更改前的数据页状态,也被称作物理日志，确保在数据库系统发生崩溃后能够恢复这些更改。记录内容：Redo log 记录的是数据页修改的物理操作，而非具体的 SQL 语句。 循环使用：Redo log 是固定大小的，通常配置为一组文件，工作在循环写入的方式。 崩溃恢复：系统重启后，InnoDB 通过回放 redo log 来恢复未完成的事务，确保数据的完整性和一致性。 提高性能：Redo log 允许 InnoDB 在事务提交时不必将所有数据页写回磁盘，只需确保 redo log 已被写入磁盘。 记录的是数据页的物理修改。 不论数据页是否在buffer pool 中， redo log 都要记录修改， 因为不记不能保证crash safe. 保存自增值 2.1 为什么要记录redo log2.1.1 buffer poolMySQL 为了实现高性能，是不可能每次都从磁盘读数据或者把对数据的修改持久化到磁盘上的,所以 InnoDB 申请了一块连续的内存，用于存储从磁盘上读取的pages, 这个内存就是buffer pool。 buffer pool 有一块内存叫做，change buffer 用于暂存对数据的修改 那么在修改数据时，就会遇到两种情况 数据所在的page 在buffer pool 中， 就会直接更新page 数据所在的page 不在buffer pool 中， 如果不需要加载对应page, 就会先把对数据的修改先记在change buffer 中 不论是buffer pool, 还是 buffer pool 中的change buffer, 都是内存，一旦发生宕机，那就数据的修改的修改就会丢失，此时就违背了事务的持久性。 为了能把修改过的数据持久化又不影响性能，InnoDB 给出的方案是优先把修改操作记下来并持久化， 事务提交后，万一宕机丢失了buffer pool 中已修改但是未持久化的内容，就可以根据持久化的修改操作重新得到修改后数据。 这里记录下来的修改操作就是redo log, 而这种先记录修改操作，再记录修改后的技术叫做WAL。 2.1.2 WALWAL（Write-Ahead Logging）是一种在数据库系统中广泛采用的日志管理技术，用于保证数据库的事务持久性和恢复能力。 它的关键点就是先写日志，再写真正的数据。 redo log 直接应用了 WAL 技术，确保在任何数据被写入数据库页之前，相应的日志信息（如数据页的修改）先被写入到 redo log 中。 总的来说WAL 技术的优势有以下3项， 恢复能力：WAL 提供了强大的数据恢复能力。在发生系统故障后，可以利用日志文件中的记录来重做或撤销事务，恢复到最后一致的状态。 性能优化：通过将对磁盘数据的随机写转换为顺序写 ， 同时利用 组提交 ，WAL 可以显著提高数据库的写性能。 事务原子性和持久性：WAL 通过确保所有日志记录在实际数据写入前被提交到磁盘，从而支持数据库事务的原子性和持久性。 2.2 redo log 记录的内容之所以说redo log 是物理日志， 是因为其记录了对特定数据page 数据的修改。该例子来自极客专栏《MySQL 实战45讲》 12mysql&gt; create table t(ID int primary key, c int);mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2); 这条更新语句做了如下的操作（按照图中的数字顺序）： Page 1 在内存中，直接更新内存； Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息 将上述两个动作记入 redo log 中（图中 3 和 4）。 Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。 2.3 redo log 写入过程# 23 | MySQL是怎么保证数据不丢的？ redo log 的写入机制-redo log buffer redo log 的写入机制和 binlog 类型， 需要经历 MySQL 系统内存cache ， redo lo buffer 文件系统page cache 刷新持久化到磁盘 2.3.1 redo log bufferadd(id1,k1) to page1, new change buffer item add(id2,k2) to page2 都是先写入redo log buffer 中 相比较 每个线程都拥有自己一块独立的 binlog cache ， 而 redo log buffer 是全局共用的。 2.3.2 redo log持久化到磁盘事务提交，执行commit redo log 后，会触发redo log buffer 中内容写入到redo log 中。 为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值： 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ; 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘； 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。 所以想要确保MySQL异常重启之后redo log 数据不丢失，innodb_flush_log_at_trx_commit 这个参数 建议设置成1. 前面在binlog部分说到， 在事务提交前，事务binlog 是不会被写入到真正的binlog 文件中的。 redo log 不一样，在事务提交前，redo log 有可能备持久化磁盘。有以下3种情况 后台线程,每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。， redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。 并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑， 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上未提交事务 在 redo log buffer 里的日志一起持久化到磁盘。2.3.3 2PC的细化过程 2.4 日志文件组InnoDB 的 redo log 是以日志文件组的形式组织的。一个日志文件组通常包含两个或更多的日志文件，这些文件在物理上是连续的，并且循环使用。当一个日志文件写满后，InnoDB 会自动切换到下一个日志文件继续写入。当最后一个文件写满后，它会回到第一个文件并开始覆盖旧的日志记录，这就是所谓的“环形写入”。 2.5 LSNLSN（Log Sequence Number）,日志序列号,是一个不断增长的全局变量， 用来记录当前redo log 文件中 已经写入的日志量， 单位是字节。 图片中的write pos LSN 指当前已经产生的的日志量，随着更多的事务数据被写入，write pos LSN 会不断增加 checkpoint LSN 是redo log 中的一个位置，表示所有之前的日志记录都已经被应用（或说是“刷新”）到了磁盘的数据页上，因此，从这个位置以前的日志数据可以安全地被覆写， 不会出现数据丢失的情况。 redo log 会有多个检查点 write pos LSN 和 checkpoint LSN之间空着的部分，可以用来记录新的操作。 如果 write pos LSN 赶上了最一个checkpoint LSN 位置，这意味着 redo log 的空间不足，可能会导致数据库操作停顿，因为系统需要等待足够的日志空间来记录新的事务数据。 2.6 组提交前面提过，redo log 提升性能，一个是把对磁盘的随机写转换成了顺序写，一个是组提交机制。 组提交机制（Group Commit）是一种通过合并多个事务的日志提交操作来提高I/O效率的策略。这一机制基于LSN（Log Sequence Number，日志序列号）来追踪和管理日志提交。 以下图为例解释 事务trx1开始： trx1进入事务队列并被选为组的领导者，日志记录的LSN开始增加。 事务trx2和trx3加入 在trx1进入队列之后，trx2和trx3紧随其后进入提交队列。 LSN更新到160： 随着trx2和trx3的日志写入缓冲区，整个组的最后一个日志序列号LSN变为160。 领导者trx1执行写盘： trx1作为组的领导者，携带LSN=160去执行一次性日志写盘（fsync）操作。 写盘完成： trx1的fsync操作完成后，所有LSN &lt;= 160的日志记录都被持久化到磁盘。 事务返回提交成功： trx1、trx2和trx3都标记为提交成功并从提交队列中移除。 3 事务执行过程中的binlog 和redolog 和undo log下面将结合MySQL 的逻辑架构 和具体SQL , 来具体地看一下binlog 和redo log 的写入 SQL12mysql&gt; create table T(ID int primary key, c int);mysql&gt; update T set c=c+1 where ID=2; 结果MySQL 的逻辑架构， 该update sql的执行过程如下 执行器先找InnoDB取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在buffer pool 中，就直接返回给执行器；否则，需要先从磁盘读入buffer pool，然后再返回。 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。 InnoDB引擎记录该行数据的undo log, 然后新数据更新到内存中，如果数据本来就在内存中，则直接修改数据页，如果不再内存中，则将修改记录在change buffer 中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。 然后告知执行器执行完成了，随时可以提交事务。执行器生成这个操作的 binlog，并把 binlog 写入磁盘。 执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。根据 innodb_flush_log_at_trx_commit 决定redo log 是否持久化到磁盘 buffer pool 中对数据页的更新 ,等待脏页刷线操作持久化到磁盘 14.prepare阶段,将事务的xid写入，将binlog_cache里的进行flush以及sync操作(大事务的话这步非常耗时)15.commit阶段，由于之前该事务产生的redo log已经sync到磁盘了。所以这步只是在redo log里标记commit 4 崩溃恢复的逻辑崩溃恢复过程中，InnoDB 会从最近的 checkpoint LSN开始，应用 redo log 中的更改，直到达到崩溃时的 write pos LSN，以此来恢复数据库到最后一次提交的状态。 看一下崩溃恢复时的判断规则 如果 redo log 里面的事务是完整的，则直接提交； 如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整： 如果完整，则提交事务； 否则，回滚事务。==此处事务回滚基于undo log == 如果redo log 没有完整的prepare, 则事务基于undo log 回滚 ⚠️说明一下，innodb_flush_log_at_trx_commit 实际上控制了redo prepare 和commit 两个阶段的刷盘策略，比如innodb_flush_log_at_trx_commit =1 时在 prepare 阶段和 commit 阶段，redo log 都会持久化写入磁盘。所以才会出现第二种磁盘有且只有完整prepare 的情况。 接下来根据一些具体的问题来详细说明崩溃恢复时的细节 4.1 如何判断 redo log 是完整的redo log commit 阶段会有commit 标识 4.2. 如果判断binlog 完整性一个事务的 binlog 是有完整格式的：statement 格式的 binlog，最后会有 COMMIT；row 格式的 binlog，最后会有一个 XID event。 4.3. redo log 和 binlog 是怎么关联起来的在崩溃恢复时，通过读取Redo Log中的Xid，能够将其与Binlog中的Xid进行匹配。 XID（Transaction Identifier） 可以理解成时MySQL server 层的事务唯一标识。redo log 中会记录XID 如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。 4.4. 为什么要用2PC 协调binlog和redo log类似的问题还有，为什么处于 prepare 阶段的 redo log 加上完整 binlog 就可以提交事务。 这两个问题本质上都是数据一致性的问题。 binlog 是server 层日志， 是MySQL 一开始就有的功能，被用在了很多地方，比如备份、主备同步复制。redo log 是InnoDB 层日志，是InnoDB 为了实现事务功能新增的。使用2PC可以维护两份之间的逻辑一致。 那么，为什么要维护两份日志间的逻辑一致呢。 binlog 是server 层日志， 是MySQL 一开始就有的功能，被用在了很多地方，比如备份、主备同步复制。redo log 是InnoDB 层日志，是InnoDB 为了实现事务功能新增的。如果两份日志逻辑或者说数据不一致， 那么用日志恢复出来的数据库状态就有可能和它本来应该的状态不一致。 具体举例来讲，如果不用2PC，两种日志要么是先写 redo log 再写 binlog，或者先写binlog 再写redo log 。仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？ 先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。 先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。 同理，为什么处于 prepare 阶段的 redo log 加上完整 binlog 就可以提交事务。因为如果binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。如果redo log 事务不提交的话，就会发生数据不一致的情况 4.5. 不要binlog 可以吗仅从事务持久化/崩溃恢复这个功能来讲， 只要redo log 是可以完成的。但是binlog 作为 MySQL 一开始就有的功能，被用在了很多地方，有redo log 无法替代的功能 。 归档。redo log 是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log 也就起不到归档的作用。 主从复制同步 MySQL 高可用 在一些业务场景中， 也会使用binlog做数据同步，比如使用canal 同步binlog数据 到ES4.6 数据一定不会丢失吗-双1 设置 在介绍binlog和redo log 写入过程的时候，有两个参数sync_binlog 控制binlog 持久化到磁盘的频率 sync_binlog=0 的时候，表示每次提交事务都不主动刷新磁盘，由文件系统自己控制刷盘频率 sync_binlog=1 的时候，表示每次提交事务都会将 binlog cache 中的内容刷新到磁盘 sync_binlog=N(N&gt;1) 的时候，表示累积 N 个提交事务后才将多个binlog cache中的内容刷新到磁盘。 innodb_flush_log_at_trx_commit 控制redo log 持久化到磁盘的频率 设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ; 设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘； 设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。 可以看到吗，只有在双1设置的时候，sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1， 才能确保一定不会丢数据 通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。 如果不设置成双1， 有助于提高性能。 5. binlog vs redo log差异 层级差异：Binlog 工作在 MySQL 服务器层，所有引擎都可以使用；而 redo log 是 InnoDB 存储引擎层特有的。 记录形式：Binlog 可以记录 SQL 语句或行变更，redo log 记录的是数据页的物理变化，即“在某个数据页上做了什么修改” 目的和用途：Binlog 主要用于数据复制和崩溃恢复，而 redo log 主要用于事务的持久性和崩溃恢复。 大小管理：Redo log 的大小是固定的，循环使用循环写；binlog 是追加写，可以不断增长，需要定期进行清理。 日志写入：每个线程都拥有自己一块独立的 binlog cache ， 而 redo log buffer 是全局共用的 共同点 事务安全：两者都是为了保证事务的持久性和原子性。 恢复支持：在系统或硬件故障后，两者都能被用来恢复数据。 写前日志：都采用了写前日志（write-ahead logging, WAL）的技术，即在实际修改数据库内容前先记录日志。 从生产到写入磁盘均有内存page - 到page cache - 磁盘，刷新到磁盘的时机均有参数控制 相关文章Intro to 事务Intro to InnoDB 事务InnoDB事务-原子性的实现,undo logInnoDB事务-隔离性的实现,MVCC &amp; 锁","tags":["MySQL","事务"]},{"title":"InnoDB事务-隔离性的实现, MVCC & 锁","path":"/9faedfe0/","content":"隔离性，还有一个说法就是 数据可见性。 隔离性、数据可见性是一个在并发事务下才需要考虑的问题，并发事务可以分3种情况考虑 读-读， 读操作不会对数据产生影响，所以不需要关注 读-写 or 写-读， 可能会出现脏读、不可重复读、幻读 写-写，可能会脏写的情况 并发事务下的数据的一致性写问题 脏写：一个事务修改了另一个未提交事务修改过的数据。 并发事务下的数据的一致性读问题 脏读：事务读取了未提交的数据，可能造成数据不一致。 不可重复读：事务在内部的多次读取中看到了同一数据的不同版本，主要由于其他事务的更新操作。 幻读：事务在两次查询同一个范围时看到了不一样的行，通常是因为其他事务添加或删除了行。 MySQL 的 4种 事务隔离级别 隔离级别 解决的问题 未解决的问题 原理描述 读未提交 无 脏读、不可重复读、幻读 允许事务读取其他事务未提交的修改，可能导致脏读。 读已提交 脏读 不可重复读、幻读 只能看到已经被其他事务提交的数据，避免了脏读，但不能防止在同一事务中看到不一致的数据。 可重复读 脏读、不可重复读 MySQL 在该隔离级别下加上gap 锁可部分解决幻读问题 在事务开始后所有SELECT操作都看到一致的快照，避免了不可重复读，但无法防止其他事务插入新行（幻读）。 串行化 脏读、不可重复读、幻读 无 “写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。通过强制事务串行执行，防止了脏读、不可重复读和幻读，提供了最高级别的隔离。 由于脏写导致的数据一致性问题非常严重，任何一种隔离级别下都不允许发生，对数据的修改操作必须通过锁串行执行 InnoDB 在解决 并发事务时，分成两种情况对应不同的解决方案 快照读-MVCC 当前读- 锁 1 快照读的隔离性-MVCC 一致性视图：在快照读中，事务会创建一个一致性视图（Consistent Read View），确保当前事务读取到的都是事务开始时的数据状态。它依赖于MVCC的实现。 无需锁定：快照读是一种无锁的读取，即读取数据时不需要对行记录进行锁定，因此它不会阻塞事务的读写，同时也不会被其他事务的读写操作阻塞。 隔离级别影响：快照读的行为受事务隔离级别的影响，不同的隔离级别会影响读取到的版本。 在读未提交隔离级别下，所有事务都读取最新事务； 在串行化隔离级别下，使用锁控制数据的访问。 在读已提交和可重复读隔离级别下，使用MVCC 来控制数据的可见性。 InnoDB存储引擎的MVCC（多版本并发控制）机制是基于ReadView和Undo Log共同实现的，关键是通过TRX_ID和ROLL_PTR两个行记录隐藏列来跟踪和管理每一行的修改版本。 1.1 版本链 -undo log在基于undo log 实现原子性 一文中，可以看到 行记录中有roll_pointer, update 操作中TRX_UNDO_UPD_EXIST_REC 和 TRX_UNDO_DEL_MARK_REC 类型的undo log 中，也有roll_pointer,通过这些roll_pointer, 可以形成一条行记录的版本链。 insert 操作中，对应的undo log没有roll_pointer 属性，因为insert 操作就是一个行记录的初始版本，没有比它更早的操作了。 以下是一个通过roll_pointer 组成的版本链，每个undo log 进行了内容省略以展示链接的重点内容 1.2 readview有了版本链，那么该如何判断哪个版本的数据对当前事务可见呢，这里需要引入readview 概念。 Read View 主要包含以下几个关键的部分： m_ids：当前系统中活跃的事务ID列表。这些事务在生成 Read View 时已经开始但尚未提交。 min_trx_id：生成 Read View 时，活跃事务ID中的最小值。这是因为任何 ID 小于此值的事务在 Read View 生成前已经提交。 max_trx_id：生成 Read View 时，已知的下一个事务ID。任何大于或等于此 ID 的事务在生成 Read View 后开始的。 creator_trx_id：生成这个 Read View 的事务的事务ID。 一个事务只有进行修改操作时，才会被分配trx_id, 否则一个事务的trx_id 默认都是0， 所以 creator_trx_id 也有可能时0 运作方式： 当事务执行查询操作时，它会根据自己的 Read View 来判断数据行的可见性。具体来说，每行数据都有自己的系统版本号（trx_id，即事务ID）。Read View 通过以下逻辑来确定行的可见性： 如果行及记录的trx_id 和creator_trx_id 相等，说明当前事务在访问自己修改的数据，数据可见。 如果行的版本号小于 min_trx_id，说明行是在 Read View 生成之前被创建或最后修改的，因此对当前事务可见。 如果行的版本号大于或等于 max_trx_id，说明行是在 Read View 生成之后被创建或修改的，因此对当前事务不可见。 如果行的版本号在 min_trx_id 和 max_trx_id 之间，还需要检查这个版本号是否属于 m_ids 列表中的某个事务： 如果属于，说明该行可能由尚未提交的事务修改，对当前事务不可见。 如果不属于，说明该行由已提交的事务修改，对当前事务可见。 如果某个版本的数据对当前事务不可见，那就顺着版本链找洗一个版本的数据，并按照上面的步骤进行判断。如果一个数据直到最后一个版本都不可见，那就说明该条数据对当前事务完全不可见 1.2.1 readview 和 读已提交（Read Committed） 生成时机：在 RC 隔离级别下，Read View 不是在事务开始时生成，而是在一个事务内每次执行 SQL 查询时都会生成新的readview, 所以该事务内是可以看到其他事务已提交的对数据的修改，这在数据一致性上就表现为不可重复读 行为：每次查询都创建一个新的 Read View，包含当前时刻所有未完成的事务ID。这确保了查询只能看到那些在执行查询前已经提交的事务所做的更改。 1.2.2 readview 和 可重复读（Repeatable Read）InnoDB 的 默认隔离级别。 生成时机：在 RR 隔离级别下，Read View 是在事务的第一次查询操作开始时创建的，且在整个事务期间保持不变。这意味着整个事务中所有的查询都将看到相同的数据快照。 行为：一旦生成，这个 Read View 将包含事务开始时刻的所有活跃事务ID。无论这些事务后来如何提交或回滚，当前事务的后续查询都不会感知到这些变化。 1.2.3 两者的对比 数据可见性：在读已提交中，事务可能看到其他事务提交的更新（即事务中的查询可能返回不同的结果），而在可重复读中，事务保证了始终对数据的一致视图。 Read View 的生成频率：读已提交每次查询都重新生成 Read View，而可重复读只在事务开始时生成一次。 系统开销：由于读已提交每次查询都需要生成 Read View，可能会有更高的系统开销，尤其是在查询频繁的场景中。相比之下，可重复读的开销主要集中在事务开始阶段。 2 当前读的隔离型-锁当前读指的是读取数据时总是获取数据的最新版本，并通过加锁（行级别的排他锁，S锁或X锁）以确保一致性，防止其他事务修改或删除这些数据。 当前读通常用于需要修改数据的查询，如 select…lock in share mode (共享读锁) select…for update UPDATE DELETE 关于行锁和间隙锁的具体加锁规则，和隔离级别和索引有关，大家可以参考何登成的加锁分析文章MySQL 加锁分析 3. 幻读bad case在前面介绍隔离级别时，提到 在可重复读隔离级别下 加上 间隙锁， 可以一定程度上解决幻觉。但是如果一个事务中 快照读和当前读混用，就会出现幻读bad case. 幻读被完全解决了吗？ 这篇文章中例举两个幻读 bad case,讲的比较清晰，可以参考 4. 当前读vs快照读 快照读（Snapshot Read）： 读取数据时使用的是某一时间点的快照，不会加锁。 使用MVCC机制，根据事务的隔离级别和版本号返回合适的行版本。 通常用于SELECT查询。 当前读（Current Read）： 始终读取最新版本的行。 可能会加锁，防止其他事务修改或删除读取的数据。 通常用于修改数据的查询操作，如SELECT ... FOR UPDATE、SELECT ... LOCK IN SHARE MODE、UPDATE和DELETE。 相关文章Intro to 事务Intro to InnoDB 事务InnoDB事务-原子性的实现,undo logInnoDB事务-持久性的实现, binglog &amp; redo log&amp;undo log","tags":["MySQL","事务"]},{"title":"InnoDB事务-原子性的实现,undo log","path":"/b36b0ce9/","content":"原子性指的是事务要么完全成功执行，要么完全失败回滚，不允许部分执行。 这本质上是在要求具有rollback 回滚能力。 InnoDB中的事务可能会由用户主动触发Rollback；也可能因为遇到死锁异常Rollback；或者发生Crash，重启后对未提交的事务回滚。 InnoDB 的 rollback回滚能力 是基于 undo log 实现的。undo log 记录了修改操作前的旧版本数据，以便在回滚时恢复数据。 1 一条 undo log 的结构1.1 undo log 的分类只有在事务中对数据进行修改（如 INSERT、DELETE、UPDATE）的时候， 才需要记录undo log，快照读 select 不需要记录。 不同的修改操作产生的 undo log 记录的内容和结构会有所不同，因为每种操作对数据的影响不同, 所以undo log 也会有不同的类型。 InnoDB 的 undo log 主要分为两大类： TRX_UNDO_INSERT：此类主要包括 TRX_UNDO_INSERT_REC 类型的日志，专门用于记录插入操作的撤销信息。 TRX_UNDO_UPDATE：此类包括 TRX_UNDO_UPD_EXIST_REC 和 TRX_UNDO_DEL_MARK_REC，用于记录更新存在的记录和标记删除操作的撤销信息。 共同点：所有类型的操作都需要且只需要记录足够的信息来逆转所执行的操作。这些记录都存储在 InnoDB 的 undo 表空间或者系统表空间中 差异：不同操作类型的 undo 日志记录的具体内容根据操作的性质而异。INSERT 主要关注标记新增行的删除，DELETE 需要记录完整的行数据以便恢复，而 UPDATE 记录修改前的字段值。 ⚠️：对于 undo log 的记录并不是基于每条修改 SQL 语句，而是基于 修改SQL 语句影响的每一条记录。这意味着每条被修改的记录都会有对应的 undo log 。如果一个 SQL 语句影响修改了多行数据，那么将会有多条 undo log 生成。 1.2 INSERT 操作的 Undo log对于 INSERT 操作，undo 日志通常记录较少的信息，主要是把这条记录的主键信息记上。 1.2.1 end of record 和 start of record在InnoDB的undo日志结构中，end of record和start of record 两个字段共同起到链接undo日志记录的作用，使这些记录形成一个双向链表，并提供顺序遍历和反向遍历的功能 end of record 定义： end of record字段指示当前undo日志记录的结束位置，并提供下一条undo日志记录的起始地址。 当最后一条undo日志记录没有后继时，则下一条undo日志记录的起始地址为NULL 目的： 指向链表中的下一条记录，方便顺序遍历日志记录，可以用于回放或者重做日志，特别是在恢复阶段 start of record 定义： start of record字段指示当前undo日志记录的起始位置，并提供上一条undo日志记录的结束地址。 如果当前undo日志记录是链表中的第一条，则上一条undo日志记录的结束地址为NULL。 目的： 指向链表中的上一条记录，方便反向遍历日志记录，用于事务回滚 1.2.2 undo type该字段指定undo日志记录的类型, 用于区分不同类型的undo操作，如TRX_UNDO_INSERT_REC 、 TRX_UNDO_UPD_EXIST_REC 和 TRX_UNDO_DEL_MARK_REC 1.2.3 undo no日志编号， 在一个事务内从0开始递增，每生成一条日志，undo no 就加1 1.2.4 table id原始记录所在表的标识符，使undo日志能够与原始记录所在的表关联。 1.2.5 此部分以&lt;长度，值&gt;的形式保存每个主键列的信息，以便在回滚插入操作时恢复主键值： len：表示对应列的存储空间大小。 value：存储主键的实际值。 1.3 DELETE 操作的 Undo log-标记删除 trx_id记录上一个旧版本数据的trx_id, 该值从行记录的隐藏列trx_id 中获取 目的： 在回滚过程中，这个字段可以帮助恢复被删除的记录的原始事务信息，确保在恢复期间不会出现不一致的问题。 roll_pointer记录上一个旧版本数据的roll_pointer, 该值从行记录的隐藏列roll_pointer 中获取 描述： 指向被删除记录的原始回滚指针 (roll_pointer)。 在InnoDB中，每条行记录都有一个位（bit）标记来指示该记录的状态，包括是否已被删除。这是通过记录头（Record Header）中的info bits字段实现的。 1.3.1 标记删除TRX_UNDO_DEL_MARK_REC 日志 指的是对记录的逻辑删除，逻辑删除指的是只被标记为删除状态，并不会立即将其物理删除，因为还要支持事务回滚，以及MVCC。 被标记删除的数据如果真的需要删除，会在适当的时候由后台线程实际清理 1.3.2 行记录的删除标记每条行记录的头部都有一个info bits字段，用来存储记录的状态信息，包括是否已被删除。 在info bits字段的第5个bit位上，标记记录是否已被删除， 当此bit位为1时，表示该记录已被标记删除；为0时，表示该记录是正常的。 1.4 UPDATE 操作的 Undo logupdate 的操作 分为两种 不更新主键的update, 这种操作 一条记录 只会TRX_UNDO_UPD_EXIST_REC 一条undo log 更新主键的update ，这种update在实际执行时， 会先删除旧记录，再insert 一条新纪录， 所以会记录两条undo log, 一条TRX_UNDO_DEL_MARK_REC， 一条TRX_UNDO_INSERT_REC 具体字段信息和前面两种类似，不再详述。 2一个事务中的多条undo log如何组织在一起2.1 undo page -分类型存储undo logInnoDB 对数据的管理是以 page 为单位进行的，undo log 也遵循这一原则，即存储在专门的 undo pages 中。 每个 undo page 中的日志记录是专用的，不同类型的undo log 不能混着存储， 即一个 page 中不能同时记录 TRX_UNDO_INSERT 类型和 TRX_UNDO_UPDATE 类型的日志。 这样设计的理由是为了避免在回滚时需要在同一页面上搜索不同类型的日志记录，从而提高了回滚操作的效率。 可是 一个事务内可以同时存在insert undo log和update undo log, 如果事务需要回滚则所有操作都需要回滚，那为什么还要分开存储呢？ 优化事务回滚的逻辑 操作依赖性减少：插入操作的回滚仅涉及到删除之前插入的行，而更新或删除操作的回滚需要恢复原始数据。将这些操作的日志分开，可以在回滚时减少对不同类型日志处理逻辑的依赖，使得回滚过程更加模块化和有序。 执行效率：分开存储使得处理各自的回滚逻辑时可以更加高效，因为每种类型的回滚处理只需关注其对应类型的日志页。这减少了在单一日志页中搜索和处理不同类型日志的复杂性和时间。 并行处理尽管一个事务中可能存在多种类型的 undo 日志，但在并发环境中，不同的回滚任务可能由不同的系统进程或线程处理。例如，某些情况下系统可能并行地处理 insert undo log 和 update undo log。分开存储可以减少锁的竞争和管理的复杂性，提高并发处理的效率。 空间和性能管理 简化空间回收：在事务提交后，insert undo log 可以立即被丢弃和回收，因为插入操作生成的记录一旦提交即视为有效。而 update undo log 可能需要被保留以支持其他事务的一致性读（由于 MVCC）。分开存储使得空间管理更为高效，因为可以针对性地处理和回收日志空间。 优化读取性能：在事务处理过程中，尤其是在一些只涉及到特定类型操作的查询或回滚操作中，分开存储可以优化日志的读取性能，因为系统可以直接定位到相关类型的日志页。 日志维护的简化 分开存储有助于简化日志维护和日志生命周期管理。系统可以更容易地追踪和管理不同类型日志的生成、使用和清理周期。 2.2 undo page 链表在一个事务中，可能会产生多条 undo log。 如果一个 undo page 填满了，事务会向系统申请新的undo page,并将其通过链表（通常是使用类似于前驱（previous）和后继（next）指针的机制）连接起来。 前面提到过，一个 undo page 不能混合存储不能类型的链接， 所以对于一个事务它可以有insert undo page 和update undo page 两个链表。 每个事务都会分配单独的页面链表。 下面简单介绍下链表中第一个 undo page file header 如前面介绍，会有一个字段来标识该page 是undo page, 用来存储undo log。 undo page header 会记录该页面存储的undo log 类型， insert or update undo log segment header , 会记录该链表所属的segment undo log header ,理论上，每个事务都会分配自己的页面链表， 但如果一个事务产生的undo log很少，那么这个页面链表就有可能被重用。所以实际上一个页面链表中实际可能存储多个事务的undo log, undo log header 中记录了不同事务间日志的分隔信息。 2.3 回滚段InnoDB默认创建128个回滚段（Rollback Segments），用于管理undo日志。 元数据存储： 每个回滚段的元数据存储在系统表空间第5号页面中。 Slot结构：每个回滚段包含1024个slot，每个slot可以映射到一个Undo页。 事务与回滚段的关联： 事务会在需要的时候分配一个回滚段。 轮询策略： InnoDB使用轮询方式将回滚段分配给新事务，以实现负载均衡。 2.4 Undo页链表的形成与维护 事务开始： 新的事务开始时，会分配一个插入段和一个更新段。 在分配的回滚段头页中，初始化undo页链表的头指针和尾指针。 查找可用的Slot： 事务在开始写入undo日志时，会首先查找一个可用的slot，并初始化一个新的undo页链表。 分配新的Undo页： 分配新的undo页，将其添加到undo页链表的末尾。 如果这是链表的第一个undo页，回滚段头页的first指针和last指针会同时指向该页。 维护Undo页链表： 当undo页链表中的最后一个undo页已满时，分配一个新的undo页并链接到链表的末尾。 回滚段头页的last指针会指向新分配的undo页。 新undo页的prev指针指向链表的前一个undo页，形成链表结构。 3 行记录如何与undo log 关联 -roll_pointer roll_pointer 是存储在每个行记录中的一个指针，指向该行记录相关的最近一次undo log 记录。 注意这个undo 记录指的是具体的 undo log，而不是整个页面链表。 当行记录被修改（包括更新、删除或作为多步操作的一部分的插入）时，InnoDB 首先会在 undo 日志中写入一条记录，这条记录包含了行修改前的数据，和行记录中的的roll_pointer, InnoDB 更新行记录中的 roll_pointer，使其指向新写入的 undo 日志记录。如果这个行再次被修改，新的 undo 日志将被写入，roll_pointer 会更新为指向这条新的记录。新的undo 日志中会记录之前的roll_pointer 4. 一条记录的版本链如何形成InnoDB 通过 roll_ptr 把每一行的历史版本串联在一起 行记录中有roll_pointer, update 操作中TRX_UNDO_UPD_EXIST_REC 和 TRX_UNDO_DEL_MARK_REC 类型的undo log 中，也有roll_pointer,通过这些roll_pointer, 可以形成一条行记录的版本链。 insert 操作中，对应的undo log没有roll_pointer 属性，因为insert 操作就是一个行记录的初始版本，没有比它更早的操作了。 以下是一个通过roll_pointer 组成的版本链，每个undo log 进行了内容省略以展示链接的重点内容 5. undo log 的持久化undo日志刷盘时机的参数，但通过控制Redo日志、脏页刷新和Purge线程的参数，可以间接影响undo日志的刷盘策略。 WAL技术在数据实际修改前，先将undo日志持久化到磁盘。 刷盘时机： 事务提交： 当事务提交时，相关的undo日志会被写入磁盘。 脏页刷盘： 在InnoDB将脏页（dirty page）写入磁盘之前，首先会确保所有相关的undo日志已经被持久化。 Redo日志同步： 当一个Redo日志被同步到磁盘时，所有相关的undo日志也必须被同步。 6 基于undo log 的回滚操作InnoDB中的事务 可能会由用户主动触发Rollback； 也可能因为遇到死锁异常Rollback； 或者发生Crash，重启后对未提交的事务回滚。6.1. 用户/应用程序主动回滚 反向遍历（start of record）当前事务的undo日志链表，按逆序恢复每个更改。 插入操作： 在数据页中删除已插入的记录。 删除操作： 恢复已删除的记录。 更新操作： 恢复更新前的记录。 每个操作恢复完成后，从undo日志链表中移除相应的undo日志记录。 6.2. 死锁异常回滚InnoDB通过死锁检测算法发现两个或多个事务之间的锁等待，形成死锁，,选择最小代价，即持有锁资源最少的事务务进行回滚。 与主动回滚类似，遍历当前事务的undo日志链表，按逆序恢复每个更改。 6.3 崩溃恢复MySQL服务器或操作系统崩溃后，InnoDB通过Undo日志与Redo日志结合，确保崩溃时数据页的状态恢复到一致的状态， undo日志用来 回滚未提交的事务。 7 undo log 的清理事务提交后，相关的Undo日志记录仍需保留一段时间以支持多版本并发控制（MVCC） 7.1 Purge 线程InnoDB 通过一个后台线程称为 Purge，来清理不再需要的 undo log。 触发条件：Purge 进程会定期检查那些已提交事务的 undo log。它会确定这些 undo log 是否还被其他活跃事务作为 MVCC 的一部分所需。 删除操作：如果一个 undo log 记录不再被任何事务所需要，Purge 进程会将其从 undo 表空间中删除，释放相关资源。 undo log 的清理机制是区分操作类型的。 7.2 Insert Undo LogInsert undo log 主要记录插入操作的信息。因为插入操作仅仅添加新的记录，不涉及已存在数据的修改，所以这种类型的 undo log 主要用于在事务失败时撤销插入操作。 清理时机：当一个事务进行插入操作并成功提交后，相应的 insert undo log 立即变得无用，因为插入的数据已经被确认并不需要再被撤销。此时，这些 undo log 可以被安全地清理掉，因为它们不再被任何事务所需。 清理过程：Purge 线程会检测到这些 insert undo log 与已提交的事务关联，并将它们标记为可清理。然后，这些 log 会从 undo 表空间中删除，相关的磁盘空间得以回收。 7.3 Update Undo LogUpdate undo log 记录了对现有数据的修改（包括更新和删除操作）。这些记录对于事务回滚和多版本并发控制（MVCC）至关重要。 清理时机：与 insert undo log 不同，即使相关事务已经提交，update undo log 也不能立即被清理。这是因为在 InnoDB 中实现 MVCC 时，其他并发事务可能需要访问这些 log 中的旧数据版本来维持一致性读。 清理过程：Purge 线程会周期性地检查 update undo log。只有当这些 log 记录不再被任何其他活跃事务所需时（即没有更早的读视图需要这些数据），它们才会被标记为可清理。然后，Purge 操作会逐步从 undo 表空间中删除这些记录。 7.4 长事务对undo log 清理的影响长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。 相关文章Intro to 事务Intro to InnoDB 事务InnoDB事务-隔离性的实现,MVCC &amp; 锁InnoDB事务-持久性的实现,binglog &amp; redo log&amp;undo log","tags":["MySQL","事务"]},{"title":"Intro to InnoDB事务","path":"/9cd551f5/","content":"在Intro to 事务中介绍过， 一致性是事务的核心特征，或者说最终目的，原子性、隔离性和持久性都是实现一致性的手段。 所以在介绍InnoDB 事务时，主要介绍AID 特性的实现InnoDB事务-原子性的实现， undo logInnoDB事务-隔离性的实现, MVCC &amp; 锁InnoDB事务-持久性的实现， binglog &amp; redo log&amp;undo log 在具体看InnoDB 事务实现AID 特性之前，可以先看以下这些前置知识 1. InnoDB 数据管理1.1 Pagepage 是 InnoDB 存储数据的基本单位，也是数据在磁盘和内存之间交换的最小单位。每个页通常的大小为 16KB针对不同的数据有不同的Page类型进行存储，如index page 索引页， undo page 等 File Header 中 有fil_page_type 来标识该页的类型 File Trailer 用来校验页面数据是否完成 1.2 区（extent）为了更好地管理page, InnoDB引入了区的概念， 连续的64个page 是一个区，大小默认是1MB。 可以认为extent 是一个物理上概念 一个区（Extent）是由连续的页组成的数据块，每个区包含 64 个连续的页，因此每个区的大小为 1MB （16KB * 64）。使用区的目的是为了优化磁盘空间的分配和管理，通过批量处理连续的页,减少随机IO来提高数据存取效率。 1.3 段 （segment ）InnoDB 中的段（Segment）作为一个逻辑结构，起着将数据库的高层逻辑结构（如表和索引）与低层物理存储结构（如页和区）连接起来的桥梁作用。 以下是几个详细的例子，通过这些例子可以更好地理解段是如何在数据库管理系统中发挥作用的。 1.3.1 数据表段假设您在数据库中创建了一个新表，这个表将需要存储数据行。InnoDB 会为这个表创建一个数据段： 逻辑层面：在逻辑层面，这个数据段代表了表中所有数据行的集合。 物理层面：物理上，这个数据段开始时可能只包含几个区，每个区由 64 个连续的页组成。随着表中数据的增加，段可以动态地分配更多的区来存储更多的数据页。 操作：当你执行 INSERT 操作向表中添加数据时，InnoDB 将在这个数据段中找到适当的页来存储新的行。如果必要的页不存在或页已满，段管理逻辑将请求分配新的区，并继续数据插入。 1.3.2 索引段当你为表创建一个索引时，无论是主键索引还是辅助索引，InnoDB 都会为每个索引创建一个单独的索引段： 逻辑层面：索引段逻辑上表示索引的结构，这包括维护键值和指向表中对应行的指针。 物理层面：物理上，索引段存储索引树（B-tree）的结构，其中每个节点（或页）包含索引键和指向行的指针。随着索引的增长，可能需要更多的页和区来扩展索引树。 操作：进行查询优化时，如执行基于索引的查找，InnoDB 通过索引段快速访问相关页，有效地定位到数据行。 1.3.3 Undo 日志段Undo 日志也是使用段来管理的，每当数据被修改时，修改前的数据将存储在 undo 日志段中： 逻辑层面：逻辑上，undo 日志段保存了数据修改前的状态，支持事务的回滚操作。 物理层面：物理上，undo 日志段由一系列的页组成，这些页按需分配，并在事务回滚时提供必要的历史数据。 操作：如果事务失败或执行 ROLLBACK 命令，InnoDB 通过访问 undo 日志段中的记录来恢复数据到其原始状态。 1.4 表空间（Tablespace）表空间是 InnoDB 数据存储的最高层级，它可以包含多个段。表空间是磁盘上的物理文件，可以看作是一个容器，内部组织着数据库的数据和索引。InnoDB 默认有一个主表空间，即 ibdata 文件，它包含了系统数据、数据字典、undo 日志等。此外，InnoDB 还支持每个表使用单独的文件作为独立表空间（file-per-table），这有助于数据库的扩展和管理。 2.行记录格式数据表中的行存放在 数据page 中， 以compact 行格式为例， 每一条数据记录的存储格式如下， 其中真实数据部分，除了数据表中定义的列之外，InnoDB 会默认为每条记录添加隐藏列 列名 是否必须 占据空间 描述 row_id 否 6 字节 行ID，唯一标识一条记录 trx_id 是 6 字节 事务ID roll_pointer 是 7 字节 回滚指针 roll_pointer 是存储在每个行记录中的一个指针，指向该行记录相关的最近一次undo log 记录。trx_id 是 InnoDB 存储引擎内部用来唯一标识每个事务的标识符，它记录了最近修改该记录的事务。 3. InnoDB 事务trx_idtrx_id 是 InnoDB 存储引擎内部用来唯一标识每个事务的标识符。这个事务ID是一个递增的数字，由 InnoDB 内部自动生成和管理。 trx_id 存储在行记录的隐藏列中。 MySQLserver 层也有一个事务唯一标识叫XID。 InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。 功能和作用 事务的唯一标识：trx_id 为 InnoDB 提供了一种方式来唯一地识别和跟踪每个活动的或已完成的事务。 多版本并发控制（MVCC）：在 InnoDB 的 MVCC 实现中，trx_id 被用来标记每条记录的版本，以此来支持事务的隔离级别。不同事务看到的数据视图依赖于记录的 trx_id 与事务的 trx_id 比较。 回滚和恢复：在事务处理过程中，如果需要回滚，InnoDB 通过 trx_id 来确定哪些更改需要被撤销。此外，在系统崩溃后的恢复过程中，trx_id 也被用来重建活跃事务的状态。","tags":["MySQL","事务"]},{"title":"Intro to 事务","path":"/5b064db6/","content":"1. 什么是事务事务（Transaction）的概念起源于数据库领域，最早由美国计算机科学家 E. F. Codd 在其关于关系数据库（Relational Database）的论文中提出。 他提出了 ACID（原子性、一致性、隔离性和持久性）属性，这些属性成为事务的核心特征。 在今天的软件开发中，事务的概念已不仅仅应用于数据库领域，还拓展到了业务开发的各个领域，包括但不限于数据库、缓存、消息队列等。 1.1 ACID 特性 原子性(Atomicity): 保证事务中的所有操作要么全部完成，要么全部不发生，有助于处理系统错误或故障时的数据恢复，确保事务执行的完整性。 一致性(Consistency)：系统从一个正确态转移到另一个正确态，由应用通过 AID 来保证，可以说是事务的核心特性 隔离性(Isolation): 处理并发事务带来的各种问题，确保每个事务看到的是一致的数据视图，防止交叉事务的干扰。 持久性(Durability): 确保事务一旦提交，其结果就就会被持久化，这保证了数据的稳定性和可靠性。 定义本身不再赘述，这里重点强调一点：一致性是事务的核心特征，或者说最终目的。原子性、隔离性和持久性都是实现一致性的手段，因此这 4 个特性并不是并列关系。 2. 事务的分类下面将把事务按照服务和数据源数量进行分类，这种分类有助于理解事务管理的复杂性以及在不同场景下的设计和实现。 2.1 本地事务-单服务单数据源事务在实际业务开发中，单个服务操作单个数据源的事务被归类为本地事务。这种事务类型是最简单的，因为它直接依赖于数据库本身的事务能力来完成，应用无需进行额外操作 示例：库存服务：当用户下单时，库存服务负责检查和更新商品库存。这个服务可能只与一个库存数据库交互，进行减库存的操作。如果库存足够，事务提交，否则回滚。这个操作只涉及库存数据库，因此是一个典型的本地事务。 2. 2 分布式事务分布式事务可以从跨多个数据源的事务和跨多个服务的事务两个角度理解。它既可以是多个数据库实例之间的分布式事务，也可以是跨不同中间件的业务层面分布式事务。 2.2.1 单服务多数据源这种情况通常发生在单个应用或服务需要同时操作多个数据库或存储系统。 例如，一个电子商务应用可能需要在处理订单的同时，在一个数据库中更新库存信息，在另一个数据库中更新用户账户信息。这要求事务管理机制能够跨越这些数据库，确保所有数据库操作要么全部成功，要么全部失败，以保证数据的一致性 在这种场景下，可以使用如XA协议这样的分布式事务协议，通过2PC等机制来协调和管理跨多个数据源的事务。 2.2.2 多服务多数据源随着微服务架构的发展，单个业务操作往往需要多个微服务协作完成，而这些服务可能各自使用独立的数据库。例如，在电商下单过程中，订单服务、库存服务、账务服务、物流服务和优惠服务需要协同处理同一业务请求，并进行交互和数据更新。 在这种场景下，分布式事务的管理比单个服务场景更为复杂，因为它不仅涉及数据一致性，还涉及网络调用的可靠性和服务间的协调。这类分布式事务通常可以通过可靠消息队列、TCC 和 SAGA 等模式来实现。 2.3 共享事务-多服务单数据源在微服务架构下，通常不允许多服务共享同一数据源。理想的微服务架构是每个微服务都有其专属数据库（即服务与数据源一一对应），这种设计被称为数据库隔离。 因此，本文及本系列不会涉及该类型事务。 3. 两种分布式事务的区别在事务分类中，单服务多数据源 和 多服务多数据源 都被归类为分布式事务，那么这两种分布式事务有什么区别呢？ 首先，单服务多数据源事务是多个数据库实例之间的分布式事务， 也被称为全局事务。当它被称为分布式事务时，这里的“分布式”是相对于数据源而言的，并不涉及服务。 而多服务多数据源事务是跨不同中间件的业务层面分布式事务。 这两种分布式事务的一个重要区别在于一致性的实现方式不同： 单服务多数据源事务通常可以追求 强一致性。 多服务多数据源事务由于其复杂性和分布式特性，通常只能追求 最终一致性。 下面将详细解释这两种情况及其原因。 3.1 单服务多数据源 与 强一致性在单服务多数据源的场景中，尽管涉及多个数据源，但所有操作都由一个单一服务控制。这种配置允许使用两阶段提交（2PC）等传统的分布式事务协议来确保强一致性，即在任何时刻，所有数据源都能反映出相同的事务状态。 为什么可以实现强一致性： 集中式协调：单个服务可以作为事务的中央协调者，管理所有数据源的事务提交或回滚。 锁定资源：事务处理过程中可以在各个数据源上锁定必要的资源，直到事务完成，确保事务的原子性和一致性。 同步更新：所有数据源的更新操作可以同步进行，确保在事务提交时，所有的变更都能一次性反映出来。 3.2 多服务多数据源 与 最终一致性多服务多数据源事务涉及多个独立的服务，每个服务可能管理自己的数据源。在这种架构下，实现强一致性变得非常复杂和成本高昂，因此通常采用最终一致性模型。 为什么通常只能实现最终一致性： 服务自治：每个服务都是自治的，独立管理自己的数据源，它们之间的通信可能是异步的，不能立即反映其他服务的状态变更。 复杂的协调机制：需要跨服务协调复杂的事务可能涉及网络延迟和服务间通信失败，使得同步更新所有数据源变得不切实际。 使用补偿事务：多服务事务常采用如SAGA等模式，通过一系列的本地事务和补偿事务来处理业务流程，每个事务独立提交，仅通过补偿机制来撤销错误操作，逐步达到数据的一致性。 4. 强一致性 vs 最终一致性4.1 一致性的分类4.1.1 强一致性（Strong Consistency）强一致性意味着系统在更新数据后，任何随后的访问都将立即看到这一更新。在强一致性模型中，所有节点上的数据在任何时间点都是一致的。这通常要求在数据更新过程中进行严格的协调，确保所有副本在继续操作前都同步更新。 优点： 数据一致性和用户体验最为理想。 易于理解和使用，因为它模拟了单个系统的行为。 缺点： 可能严重影响系统的可用性和性能，尤其在网络延迟较高的情况下。 在 CAP 定理中，通常需要在遇到网络分区时牺牲可用性。4.1.2 线性一致性（Linearizability） 线性一致性是强一致性的一个特例，它不仅保证所有节点看到相同的数据，还要求系统表现得就像所有操作都是顺序发生的。这意味着如果操作A在操作B之前完成，那么系统中的所有节点都应该首先看到A的结果，然后是B的结果。优点： 提供了强一致性的最高标准，适用于需要严格数据顺序的应用。 简化了系统的编程模型。缺点： 对系统性能和可用性的影响比一般的强一致性还要大。 4.1.3 弱一致性（Weak Consistency）弱一致性不保证在数据更新后立即反映这一变化。在更新操作和其影响被所有用户观察到之间，存在一个不确定的时间窗口。这种模型通常用于对实时一致性要求不高的系统。优点： 提高了系统的可用性和性能。 在处理高并发操作时更加有效。缺点： 用户可能会读到旧数据。 应用逻辑可能需要处理数据不一致的问题。4.1.4 最终一致性（Eventual Consistency） 最终一致性保证，在没有新的更新的情况下，所有的数据副本最终将会是一致的。系统不保证达到一致状态的具体时间。优点： 高度可用和可扩展。 适用于分布广泛的系统，可以容忍数据在短时间内的不一致。缺点： 应用需要能够处理数据一段时间内的不一致。 开发者需要设计有效的数据同步和冲突解决策略。4.2 CAP 与 ACID的微妙平衡-分布式系统只能追求最终一致性 根据 CAP 定理，一个分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）三个属性，最多只能满足其中两个，必须牺牲一个。 一致性（Consistency）：在任何时刻，任何分布式节点中看到的数据都保持一致。 可用性（Availability）：系统能够不间断地提供服务的能力。 分区容忍性（Partition Tolerance）：在分布式环境中，当部分节点因网络原因失联（即形成“网络分区”）时，系统仍能正确提供服务的能力。 4.2.1 为什么说 分布式系统 必须接受 分区容忍性理解为什么分区容忍性在分布式环境下必然存在，需要从分布式系统的基本构成和网络通信的不可靠性两个角度探讨。 分布式系统的基本构成 分布式系统由多个相互协作的独立组件组成，这些组件可能位于物理上分散的不同位置。该架构的主要优势是提高系统的可扩展性、容错性和资源利用率。然而，这也意味着系统的各个部分必须通过网络通信。 网络通信的不可靠性 网络本身存在不可靠性，可能因多种原因导致通信失败： 网络故障：网络设备或连接可能出现故障，如路由器故障、连接断开等。 网络延迟：消息在传输过程中可能遭遇不可预测的延迟。 带宽限制：网络的带宽限制可能导致数据包延迟到达或丢失。 网络安全：网络攻击（如分布式拒绝服务攻击，DDoS）可能导致网络部分或完全不可用。 如果一个系统设计选择不接受网络分区，那么一旦网络分区发生，系统将无法正常工作，这在大多数业务场景中是不可接受的。 因此，在分布式系统中，分区容忍性（Partition Tolerance）是必然存在的特性。 基于分区容忍性必须满足的现状以及 CAP 理论，系统只能在一致性和可用性之间做出选择。通常，系统会选择高可用性，强一致性因此被牺牲，系统只能追求最终一致性。 5. 理解分布式事务中的各种协议5.1 DTP 模型和 XA 规范5.1.1 DTP 模型DTP（Distributed Transaction Processing，分布式事务处理）模型是由 X/Open（后来的 Open Group）提出的一种分布式事务处理架构模型。它定义了一套标准，使得不同厂商的分布式事务处理系统能够互操作。 在标准的 DTP 模型中，定义了以下四个主要组件： Application Program（AP，应用程序）： 发起分布式事务的主体，由最终用户或开发者编写。 通过调用事务管理器的接口（例如 TX 接口）开始、提交或回滚事务。 应用程序与事务管理器和资源管理器交互。 Transaction Manager（TM，事务管理器）： 负责管理分布式事务的开始、提交和回滚等操作。 维护事务的状态，并使用两阶段提交协议（2PC）协调所有参与的资源管理器。 提供对外的 TX 接口供应用程序使用，并通过 XA 接口与资源管理器交互。 Resource Manager（RM，资源管理器）： 负责管理和控制对特定资源的访问，例如数据库管理系统（DBMS）、文件系统、消息队列等。 接收事务管理器的请求以进行资源操作，并确保数据一致性。 实现 XA 接口与事务管理器通信。 Communication Resource Manager（CRM，通信资源管理器）： 可选组件，负责管理与外部系统的通信资源。 在分布式事务中协调和同步事务状态，确保跨系统的事务一致性。 管理跨网络的事务传播，确保分布式环境中的事务处理一致性。 主要接口： TX 接口： 应用程序 AP 与事务管理器 TM 之间的桥梁，负责事务的开始、提交和回滚等操作。 例如，在 Java EE 中，TX 接口通常对应 javax.transaction.UserTransaction。 XA 接口： 事务管理器 TM 与资源管理器 RM 之间的接口，协调资源管理器在两阶段提交协议中的操作。 常见的 XA 接口方法包括 xa_open、xa_start、xa_end、xa_prepare、xa_commit、xa_rollback 等。 CRM 接口： 事务管理器与通信资源管理器之间的接口，确保分布式事务在网络通信中保持一致性。 没有明确的标准接口，由各系统厂商自行实现。 5.1.2 XA规范XA 规范是 X/Open 组织在 DTP（Distributed Transaction Processing）模型中定义的，用于描述事务管理器（TM）和资源管理器（RM）之间交互的接口标准。 接口标准：XA 规范定义了一套标准接口，包括 xa_start、xa_end、xa_prepare、xa_commit、xa_rollback 等。 2PC 协议：XA 接口实现了两阶段提交协议（2PC），以确保分布式事务的一致性和完整性。 5.1.3 XA 事务XA事务是一种分布式事务。通过两阶段提交协议和XA接口标准，事务管理器和资源管理器能够可靠地协同工作，实现跨系统的事务处理，确保多个独立资源的一致性。 实际应用 数据库系统： 大多数主流数据库系统都支持XA事务，如Oracle、MySQL、DB2、SQL Server等。 通过实现XA接口，数据库可以参与分布式事务并与事务管理器协同工作。 消息中间件： 一些消息队列和消息中间件也支持XA事务，如IBM MQ、ActiveMQ等。 能够确保消息发送与其他资源操作的一致性。 Java EE环境： 在Java EE应用程序中，javax.transaction.UserTransaction和javax.transaction.TransactionManager接口提供了对XA事务的支持。5.2 两阶段提交（2PC） 两阶段提交是一种具体的事务协议，用于在分布式系统中协调多个事务参与者的行为，以确保事务的原子性。它包含以下两个阶段： 准备阶段：协调者询问所有参与者，是否准备好提交事务。 提交/回滚阶段：基于各参与者的答复和超时情况，协调者决定是否全局提交或回滚， 只有全部参与者回答了prepared 才会commit; 若有一个参与者回答和non-prepared 或者超时未回答，则rollback 5.2.1 协调者宕机：单点问题，参与者阻塞在2PC中，一个重要特点是参与者缺乏超时机制。因此，在第一阶段结束后，他们必须原地等待协调者的第二阶段指令。一旦协调者宕机，所有参与者都会受到影响。如果协调者长时间未恢复或未发送正常的提交或回滚指令，所有参与者都将被阻塞。 为何参与者缺乏超时处理机制呢？因为这可能引发数据一致性问题。当参与者迟迟未收到提交或回滚指令时，无论其默认为提交还是回滚，都可能导致全局数据不一致。 这也给了我们业务开发一些启示：在任何不确定情况下，都不应随意指定默认操作，最佳做法是启动警报，让人工介入处理。 5.2.2 回滚性能差所有的操作都已经完成，回滚需要全部推翻。 5.2.3 一致性问题5.2.4.1 协调者宕机如上面单点问题中描述，协调者宕机后，由于参与者没有超时处理机制，会一直阻塞等待，直到协调者宕机恢复后， 根据持久化的数据判断该事务状态，进而发送commit 或者 rollback ， 所以在协调者宕机恢复前 协调者和参与者的数据是不一致的 5.2.3.2 参与者宕机如果参与者收到commit后，宕机了。此时数据也是不一致的参与者宕机恢复后，可以检查自己的持久化信息，来判断事务的状态。 5.2.3.3 网络问题有的参与者收到了commit,有的参与者收不到；参与者的ack 消息，协调者有的收到了，有的没收到。其中参与者收不到第二阶段的消息，自然不会有ack, 表现上也是协调者收不到ack。这里的解决方案就是 协调者超时处理机制-重试，在重试成功之前，数据是不一致的。 5.2.4 梳理下 DTP、XA、2PC 之间的关系DTP（Distributed Transaction Processing，分布式事务处理）模型是由X/Open（后来的Open Group）提出的一种分布式事务处理的体系结构模型。它定义了一套标准，使得不同厂商的分布式事务处理系统能够互操作。 XA规范是X/Open组织 在DTP（Distributed Transaction Processing）模型中定义的，用于描述事务管理器（TM）和资源管理器（RM）之间的交互的接口标准。 XA 规范基于2PC 实现。 但是 2PC协议是一种通用的事务提交协议，可以在任何实现中使用。除了XA规范，2PC协议还可以用于其他事务管理协议和框架，如： Seata：阿里巴巴开源的分布式事务框架，提供全局事务管理服务，支持2PC但不直接使用XA接口。 Atomikos：支持两阶段提交协议的独立事务管理器。 Bitronix：另一个独立事务管理器，也支持2PC协议。 在某些场景下，可以直接在应用程序代码中实现简化版的2PC协议，而无需遵循XA规范。 5.3 三阶段提交（3PC）3PC 的3个阶段， CanCommit PreCommit DoCommit 3PC 相比2PC 的变化 3PC提交把2PC的prepare 阶段细分为两个阶段，分别称为 CanCommit、PreCommit 参与者增加了超时处理机制，超时默认会提交事务 3PC 的提出是为了改进2PC 存在的问题 5.3.1 CanCommit 优化回滚操作性能新增的 CanCommit 是一个询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。这可以解决提高precommit 阶段的成功率，万一失败了，回滚操作也比较轻，因为还没开始做实质性的操作 但是这里要注意一个性能问题，在事务需要回滚的场景中，三段式的性能通常要比两段式好很多，但在事务能够正常提交的场景中，两段式和三段式提交的性能都很差，三段式因为多了一次询问，性能还要更差一些。 5.3.2 解决协调者单点问题通过增加参与者超时处理机制，默认会提交事务，相当于解决了协调者宕机参与者阻塞等待的单点问题 5.3.3 加重数据一致性问题在2PC中已经讨论过,为什么2PC参与者没有超时处理机制？因为超时处理机制可能引发数据一致性问题，当 参与者迟迟收不到commit or rollback 指令时， 参与者不论是 默认提交 还是默认回滚，都有可能导致全局数据不一致。 3PC 增加了超时机制， 会默认提交事务，这会加重数据一致性的问题 5.4 TCC（Try-Confirm/Cancel）TCC是一种应用层事务协议，它分为三个阶段：Try（尝试）、Confirm（确认）、Cancel（取消）。在Try阶段，每个参与者尝试执行事务并锁定必要资源；在Confirm阶段，如果所有参与者的Try操作都成功，那么执行Confirm操作提交事务；如果任何Try失败，则执行Cancel操作回滚事务。TCC适用于业务逻辑复杂，需要长时间运行的事务。 个人认为，TCC可以被理解为是2PC的一种变体，具有两阶段的结构，但它在实施和操作上更适合处理复杂的业务逻辑和提高系统的灵活性与效率。 5.5 可靠消息队列使用可靠消息队列来解决分布式事务问题是一种被称为“最终一致性”的策略，它通过异步消息传递的方式，确保在分布式系统中多个服务之间的数据一致性。 使用可靠消息队列解决分布式事务的核心思想在于： 异步与最终一致性：通过异步的方式处理分布式事务，并确保最终一致性。 可靠消息传递：确保消息传递的可靠性，包括重试机制、幂等处理等。 5.6 SAGASAGA是一种将长期事务分解为一系列较小的、独立的子事务的方法。每个子事务都可以单独提交或回滚。如果某个子事务失败，SAGA通过执行补偿事务（即逆操作）来恢复之前的状态。SAGA降低了资源锁定的时间，适用于微服务架构中的事务管理。 参考文章《周志明的软件架构课》https://www.51cto.com/article/648668.html","tags":["事务"]},{"title":"使用github page+hexo 创建个人网站","path":"/5fe6baa/","content":"关于使用 github page + hexo 创建个人网站， hexo官网上的步骤已经非常详细，网上也有非常多相关的文章， 所以基础步骤就不写了。 这里记录一些个性化过程中遇到的问题。 1. TOC 锚点失效文章目录正常生成了，但是点击目录无法跳转到文章对应位置。解决办法点这里查看 2. 文章的短链接生成hexo 文章标题默认的格式是:year/:month/:day/:title/,这个格式的标题在我看来有2个主要问题 太长，可以考虑只取默认格式中的一部分，如:title/ 易变化， 写文章时有可能会修改标题,所以文章的url就会发生变化。 url 一旦发生变化就会对网站排名产生负面影响 综上，我希望每篇文章都有一个 固定且短的 url。 hexo-abbrlink:create one and only link for every post for hexo 插件可以实现该功能， 它根据文章标题和创建时间为文章生成一个abbrlink， 如果文章已经有该属性则不会重复生成。 3. custom domain 消失记在github pages 配置了custom domain ，但是我发现每次deploy新内容后，配置好的custom domain 都会消失，经过排查发现是缺失来 CNAME文件。 3.1 CNAME是什么CNAME（Canonical Name）记录是一种DNS（Domain Name System）记录类型，用于将一个域名别名映射到另一个真正的域名。它的作用是简化域名管理、实现负载均衡、支持CDN集成等。CNAME记录的工作流程包括DNS查询、递归查询、权威DNS服务器响应和IP地址返回等步骤。通过正确配置CNAME记录，可以有效管理和优化网站的域名解析。 3.2 CNAME记录的作用 域名重定向：允许多个域名指向同一个目标域名，简化了域名管理。例如，将www.example.com和blog.example.com都指向example.com。 负载均衡：通过CNAME记录可以将流量分布到不同的服务器，实现负载均衡。 内容分发网络（CDN）集成：CDN提供商通常要求将用户的子域名（如cdn.example.com）CNAME到他们的CDN域名（如cdn.provider.com），以便进行流量管理和内容分发。 3.3 CNAME记录的工作流程CNAME记录的工作流程可以分为两个主要阶段：解析CNAME记录本身和解析CNAME记录指向的目标域名，直到最终得到一个IP地址。 DNS查询开始：用户在浏览器中输入域名，如www.example.com，并发送DNS查询请求。 递归DNS服务器处理请求：用户的计算机向递归DNS服务器（通常由ISP提供）发送请求。递归DNS服务器查询根DNS服务器，获取顶级域名服务器（如.com的服务器）的信息。 递归查询过程：递归DNS服务器查询顶级域名服务器，获取该域的权威DNS服务器信息（如example.com的DNS服务器）。递归DNS服务器接着查询权威DNS服务器。 权威DNS服务器响应：权威DNS服务器查找www.example.com的DNS记录。如果www.example.com有一个CNAME记录指向example.com，权威DNS服务器返回这个CNAME记录。 CNAME解析：递归DNS服务器接收到CNAME记录后，再次进行DNS查询，以解析CNAME记录指向的目标域名example.com。递归DNS服务器最终获取目标域名example.com的A记录（IP地址）。 返回IP地址：递归DNS服务器将目标域名example.com的A记录返回给用户的计算机。用户的计算机使用该IP地址与目标服务器建立连接，加载网站内容。3.4 Hexo 中CNAME 文件的作用 当你使用自定义域名而不是username.github.io来访问网站时，需要在在source目录中创建一个文件CNAME 文件，并写入自定义域名 CNAME文件的存在和内容会告知GitHub Pages你希望通过哪个自定义域名访问你的网站。 例如，如果你的自定义域名是www.example.com，你需要在CNAME文件中写入www.example.com。 4. 数学公式的支持可参考 在任意的hexo主题支持数学公式"},{"title":"chatGPT是如何被训练出来的","path":"/8cb014c5/","content":"本文内容基于 Andrej Karpathy 的视频 State of GPT，并加入了个人理解，进行总结。 该部分的主题是how to train your GPT assistants， 在chatGPT 的语境中，Assistant 特指能回答问题，像助手一样可以帮我们做很多事。 0. GPT训练的四个阶段 目前我们能够使用到的chatGPT 都是RLFH 模型，该模型的训练可以分为3个阶段 pretraining 预训练 Supervised finetuning 监督微调 Reinforcement Learning from Human Feedback， 包括reward modeling 和Reinforcement Learning， 因为reward modeling 不能独立起作用，也不能独立部署，必须Reinforcement Learning结合使用，所以把它们归类为一个阶段。 在以上每个阶段中，都有各自训练需要的数据集、算法、和训练输出结果 1. pre-training 预训练pre-trainin 预训练阶段是一切的起点，它需要最多的数据，最多的计算资源GPU，最长的训练时间。 总的特点如下 大规模数据：预训练使用的大规模数据集包含了来自互联网的各种文本，这些数据集规模庞大，通常包含数十亿甚至数百亿个token。 无监督学习：预训练通常采用无监督学习方法，即不需要人为标注的数据。模型通过预测文本中的下一词（或下一个token）来学习语言结构和模式。 通用性：预训练模型具有通用性，因为它并没有针对特定任务进行优化，而是广泛地学习各种语言模式。这种通用性使得模型可以适应多种下游任务。1.1 Dataset 预训练使用的大规模数据集包含了来自互联网的各种文本，这些数据集规模庞大，不过目前chatGPT 没有公开具体的数据， 上图是meta 开源的LLaMA的训练数据集 67.0%的Common Crawl，也就是常规网络爬取的数据集，这部分数据集的特点是内容涉及的类型很全面，但是因为内容可能是任何人写的，质量一般偏低，也会包含大量不相关，例如广告、导航条、版权声明等。 15.0%是C4数据集 (Colossal Clean Crawled Corpus, “庞大的清洁语料库”)，这个数据集包含了大量的网页文本，这些文本已经过清理，移除了广告、重复内容、非英语文本、和其他不适合训练的元素。这个数据集的目标是提供一个大规模、高质量、多样性强的英语文本数据集，以支持自然语言处理任务。尽管C4经过清理，但仍然包含了来自互联网的各种文本，因此可能包含一些质量不高的信息的信息。 剩余18%的训练数据来源主要是来自Github、维基百科、书籍、Arxiv论文、交易所等， 可以认为是高质量的数据。 这些训练数据有以下特点 规模庞大：训练数据的数量非常大，包含数十亿条文本记录。这种大规模的数据量帮助模型学会语言的复杂性和细微差别。 多样性：训练数据涵盖了广泛的主题和领域，包括科学、艺术、历史、文学、技术、日常生活等。这种多样性使得模型能够应对各种类型的问题和对话。 广泛覆盖：涵盖了从基础知识到专业知识的广泛范围，使得模型在回答问题时既能处理简单的日常问题，也能应对复杂的专业问题。 . 开放获取：所有数据都来自公开可获取的资源，没有使用私人或受保护的数据，确保了数据的合法性和道德性。 根据以上特点，可以总结认为像chatGPT 这样的LLM, 学习了人类在互联网上发表过所有知识。不过由于高质量的数据只占18%， 如果你想获取高质量的回答，所以你需要一些chatGPT 沟通的技巧， 即prompt 技巧，才能获取高质量的回答。 1.2 preprocess dataset-Tokenization针对从互联网上获取到的大量数据，chatGPT 并不是直接拿来训练，而是要经过tokenization 标记化，将文本转换成模型可以理解的整数序列。 1.2.1 什么是Tokenization？Tokenization是将文本拆分成较小的单元（称为tokens）的过程。这些tokens可以是单词、子词、字符或其他文本片段，，并将其映射到特定的标记或整数的过程。 从图中可以看出，GPT 并不是直接使用从互联网上获取的原始数据进行训练， 而是先讲数据分解成token,再将token 转化成整数数列。最终进入到神经网络/Transformer 进行训练的是这些整数数列。 以下Tokenization的步骤： 文本清理：在进行Tokenization之前，文本可能需要清理，比如去掉多余的空格、标点符号的处理等。这一步骤视具体应用而定。 拆分文本：将文本拆分成tokens。例如，对于句子“ChatGPT is great.”，可以拆分为“ChatGPT”、“is”和“great”。 子词级别的Tokenization：现代语言模型（如GPT-3）通常使用子词（subword）级别的Tokenization，如Byte Pair Encoding（BPE）或WordPiece。这些方法可以将罕见词分解为更常见的子词片段。例如，单词“unhappiness”可以分解为“un”、“happiness”或进一步分解为“un”、“happi”、“ness”。 分配唯一ID：每个token被分配一个唯一的整数ID，模型内部使用这些ID而不是直接使用文本。例如，“ChatGPT”可能被分配ID 12345，“is”被分配ID 6789，依此类推。 1.2.2什么是tokentoken 在自然语言处理（NLP）中扮演着核心角色，尤其是在训练像ChatGPT这样的大型语言模型时，token是模型训练和生成文本的基本单位。 在英语预料中，它可以是是一个词、也可以是一部分词、或者一个字符（虽然演讲中示例对token 的举例基本是都是完整的单词） 那么这里就要思考，为什么不用完整的单词训练呢，既简单又直接。 词汇表大小和稀疏性问题使用完整单词进行训练的一个主要问题是词汇表的大小。英语和其他语言中的词汇量非常庞大，尤其是当考虑到新词、专有名词、不同的词形变化（如复数形式、时态等）时，词汇表的规模可能会变得非常大。 大词汇表问题：一个庞大的词汇表意味着模型需要处理更多的单词，这不仅增加了模型的复杂性，还会显著增加训练和运行模型所需的资源（如内存和计算时间）。 稀疏性问题：当词汇表很大时，很多单词在训练数据中出现的频率可能非常低，导致数据稀疏。稀疏性问题会降低模型对这些单词的学习效率，影响模型的性能和泛化能力。 处理未知词汇的能力直接使用完整单词进行训练面临的另一个挑战是如何处理训练数据中未出现过的单词（即未知词汇或OOV问题）。 未知词汇（OOV）问题：在新的文本中经常会出现训练数据中未见过的单词。如果模型只学习到了完整单词，那么它很难处理这些未知词汇。 泛化能力：通过使用子词（如词干、前缀、后缀等）或更小的单元，模型可以更好地泛化到未见过的单词。例如，通过识别“un-”和“-able”这样的前后缀，模型可以推断出“unbelievable”等单词的含义，即使这个词在训练数据中没有直接出现过。 训练效率和计算资源分词还可以帮助提高训练效率和减少对计算资源的需求。 减少参数数量：较小的词汇表可以减少模型的参数数量，降低过拟合的风险，同时提高模型的训练速度和推理速度。 内存和存储优化：使用更小的词汇表意味着可以更高效地使用内存和存储资源，尤其是在嵌入层中。 适应多样化的语言现象语言中存在大量的变体和创新，直接使用完整单词可能难以适应这些变化。 词形变化：在许多语言中，单词可以有多种形式。使用基于规则或统计的分词方法可以帮助模型理解不同词形之间的关联，提高模型对语言变化的适应能力。 新词创造和网络语言：新词和网络流行语的出现是常态。分词系统可以通过更新词库或调整分词算法来适应这些变化。 1.3 Unsupervised Learning-无监督学习预训练采用无监督学习方法，即不需要人为标注的数据。模型通过预测文本中的下一词（或下一个token）来学习语言结构和模式。 数据会以批次为单位， 输入到Transformer中进行训练，其训练过程就是不断让模型根据前面已经的内容（黄色部分），去猜测当前token(绿色部分)的下一个词是什么（红色部分）， 如果猜测的结果和实际情况不一致，则要调整模型，直至结果一致。 猜测的过程是基于概率进行的。 如果猜错了，那距离正确答案又多远，这就是损失函数的概念。低损失意味着更高的预测正确概率 1.3 base model预训练完成后会得到一个base model ，因为它并没有针对特定任务进行优化，而是广泛地学习各种语言模式。这种通用性使得模型可以适应多种下游任务。 1.3.1 base model are not assistant这句话的含义是base model 并不能回答问题。预训练阶段得到的base model 只是一个文档生成器， 只会根据你输入的内容去预测下一个单词，并不会回答你的问题，所以还起不到assistant 助手 的作用。 如图中，base model 并不会按照你的要求写诗，知识生成相似的内容。 what is the capital of France? 再例如针对以上问题，base model 并不会回答问题，给出“Paris”, 而是会续写内容， 给出以下可能的答案what is France’s largest city?what is France’s population?what is the currency of France? 1.4 如何让 base model 回答问题1.4.1 few-shot LearningFew-shot Learning：指的一种在给模型提供少量示例的情况下让其学习新任务的方法。Few-shot 可以分为零样本学习（zero-shot learning）、一样本学习（one-shot learning）和小样本学习（few-shot learning）。原理：模型在大规模语料上进行预训练，学到了广泛的语言知识和基本任务能力。在新任务上，通过提供少量的示例（输入-输出对），模型可以从中推断出该任务的模式和要求。 few-shot 之所以起作用，是把问题伪装成了一个文档中缺失的内容，让base model 通过完成文档的能力把它补全。但是这一过程非常不稳定， 在实践中总体效果一般。 1.4.2 Supervised finetuning指在base model 的基础上，使用带有标签的数据集对模型进行进一步训练，以提高其在特定任务上的表现。 1.4.3 few-shot vs Supervised finetuning Few-shot Learning： 优点：无需大量标注数据，适应新任务快速。 缺点：在任务复杂或示例较少时，效果可能不如监督微调。 监督微调： 优点：在有足够标注数据时，能够显著提升模型性能。 缺点：需要大量标注数据，成本较高。 2. Supervised finetuning stage 微调指在base model 的基础上，使用带有标签的数据集对模型进行进一步训练，以提高其在特定任务上的表现。 2.1 Dataset相比pre-training 预训练阶段，Supervised finetuning 监督微调阶段使用少量但高质量的数据集。这些数据集包含了成对的输入和期望输出，例如问题与答案（Q&amp;A）、命令与响应、或者其他相关任务的配对。这些数据通常通过以下方式获得： 人工标注：雇佣标注人员根据预设的指导文档（labeling documentation）来创建数据。标注人员可能会根据给定的指令编写问题的答案，或者评估和选择模型生成的候选回答。 众包平台：使用众包服务（如Amazon Mechanical Turk）来收集和标注数据。这种方式可以快速且成本相对较低地获得大量标注数据 合作伙伴：与学术机构、研究组织或其他公司合作，共享或共同创建数据集。 2.2 SFT modelSFT model 已经是一个可以回答问题的assistant 2.4 Pre-training vs fine tuning 以下是预训练（Pre-training）和微调（Fine-tuning）两个阶段的对比表格，从目标、数据集、过程、成本和迭代与改进五个方面进行总结： 特征 预训练（Pre-training） 微调（Fine-tuning） 目标 学习广泛的语言知识和互联网信息，不专注于特定任务。 调整预训练模型以适应特定任务或应用场景。 数据集 来自互联网的大规模、多样化文本数据，可能包含多种语言和主题。 较小但高质量的特定任务相关数据集，如问答对、标注文本等。 过程 通过预测文本序列中的下一个词进行训练，使用大规模数据集进行广泛学习。 在预训练模型的基础上，使用特定任务的数据集进行额外训练。 成本 高，需要大量计算资源（如GPU集群）和时间，成本可能高达数百万至数十亿美元。 相对较低，主要涉及数据标注和模型调整，计算资源需求较小。 迭代和改进 通常在大型公司或研究机构中进行，可能每年或几个月进行一次，取决于资源和需求。 可以频繁进行，根据模型表现和用户反馈不断优化模型。 3. RLHFReinforcement Learning from Human Feedback根据人类反馈进行强化学习这个阶段包含两个步骤， Reward Modeling Reinforcement Learning3. 1 Reward Modeling 3.1.1 Dataset- comparisons 相同的prompt, SFT model 会给出不同版本的回答，即多个候选答案。目前我们在使用 人类评估者会对这些候选回答进行比较打分排名，并选择他们认为最合适或最准确的回答。 模型会根据这些比较结果进行学习，以便对其他问题的多个候选答案的好坏进行预测 3.1.2 RM Training 从图中可以看出， 提示词+ 结果+ 人类评估者反馈作为关联在一起的数据又被打包到batch中进行训练， 如图，可以理解成一个相同的提示词prompt 有3个不同版本的回答，对应的3个不同的reward(可以理解成是分数)， 训练后模型就可以针对一个prompt 的回答预测出一个人类评估者的打分。 所以这个阶段的目的就是构建一个reward model 学习人类打分的规律，以来预测一个回答可能会获得的人类评分。 由于reward model只是学习了人类打分的规律，所以如果单独使用Reward Model 进行打分并不会促进模型生成更好的答案 ， 它需要和Reinforcement Learning 强化学习结合使用才能起作用 3.2 Reinforcement Learning有了reward model 后，就可以对模型的回答进行打分。对于分数高的回答，要提高其出现的概率，如此不断迭代，尽可能生成获得更高分的回答。","tags":["AI","chatGPT"]},{"title":"Intro to chatGPT,从G、P、T的含义解释chatGPT","path":"/60dfe914/","content":"ChatGPT是由OpenAI开发的，一个能够理解和生成自然语言的人工智能（AI）模型，可以和用户进行互动并生成类似人类的对话。 1. chatGPT 的发展历程ChatGPT模型的发展历程是一个不断演进和改进的过程。以下是关键的时间节点和发展阶段： GPT-1（2018年6月）：OpenAI发布了首个生成预训练变换器模型（Generative Pre-trained Transformer，GPT-1）。该模型基于Transformer架构，使用无监督学习方法在大规模文本语料上进行预训练，然后在特定任务上进行微调（Fine-tuning）。 架构：12层Transformer解码器，参数量约为1.17亿。 创新点：引入无监督预训练和有监督微调相结合的训练方法，在多个NLP任务上表现优异。 GPT-2（2019年2月）：OpenAI发布了GPT-2，模型规模和能力大幅提升。最初由于担心模型被滥用，OpenAI仅发布了部分参数的模型，后于2019年11月发布了完整模型。 架构：最大版本有48层，参数量达15亿。 创新点：显著提高了模型的生成质量和连贯性，在文本生成、翻译、问答等任务上表现出色。 GPT-3（2020年6月）：是当时最大和最强大的语言模型，包含1750亿参数。 架构：1750亿参数，96层，采用更大规模的数据进行训练。 创新点：通过超大规模预训练和少量示例（Few-shot Learning），在无需微调的情况下，也能在多个任务上取得惊人的效果。 GPT-3.5（2021年11月）： 是GPT-3的改进版本，模型参数达到2000亿，利用人类反馈进行强化学习，进一步提升模型的交互能力。 增强了处理复杂对话和多轮对话的能力。 GPT-4（2023年2月）： 尚未公开具体参数，但推测远超GPT-3.5，支持多模态输入和输出 提供了更高水平的自然语言理解和生成能力，支持多模态输入与输出 GPT-4o(2024年5月) 工程能力大幅提升， 体现在相应速度更快，且开始能理解语音语调 ChatGPT模型的发展不仅仅是参数的增加，更是算法优化、数据多样化和对用户反馈的持续改进。 目前我们使用的chatGPT 后GPT-3.5、GPT-4、GPT-4o 三个版本可选。 2. G、P、T分别是什么意思GPT 是 Generative Pre-trained Transformer 的缩写。以下内容将重点介绍G、P、T 三个字母各自的含义，以此来更好得理解chatGPT 是什么。 2.1 Generative 生成式ChatGPT是一个Generative AI, 即生成式AI。 AI 作为一个总称，其实包含非常多具体的类型， ChatGPT 所属的Generative AI 是其中一个子类。 日常生活中会用到的siri、小度、小爱、识别图片中动物是小猫、医院的专家诊断系统、和你国际象棋对战的机器人，这些都是AI 。 但是这些AI 都是规则驱动的系统，只能根据预设规则进行回答，一旦超出预设范围，就会表现的人工智障。 chatGPT作为一个Generative AI, 其最大的特点就是根据输入生成新内容。它不仅能回答问题，还能进行创意写作、故事生成、诗歌创作等多种任务。 Generative AI 也有自己具体的分类 Natural language generationchatGPT 就是 NLG, 可以说是目前最著名的AI 应用 text to image根据文字生成图片 Midjourney DALL-E Stable Diffusion Generative Adversarial Networks (GANs)生成对抗网络，其核心是两个相互对抗的网络：生成器（Generator）和判别器（Discriminator）。这两个网络在训练过程中相互竞争，从而不断提升自身的性能。 生成器（Generator） - 这个网络的任务是捕捉训练数据的分布，并生成尽可能接近真实数据的新数据。生成器接受一个随机噪声向量作为输入，通过这个噪声向量构造出新的数据实例。 判别器（Discriminator） - 判别器的任务是区分输入给它的数据是来自训练集（即真实数据）还是生成器生成的假数据。基本上，判别器是一个二分类模型，输出一个标量表示输入数据是真实数据的概率。这两个模型在训练过程中进行对抗。生成器试图产生越来越真实的数据以“欺骗”判别器，而判别器则试图变得更好地区分真假数据。通过这种对抗过程，生成器学会生成高质量的数据。 VAEs可用于异常检测，方法是在正常数据的数据集上训练模型，然后使用经过训练的模型来识别偏离正常数据的实例。这可用于检测各种情况下的异常情况，例如发现金融交易中的欺诈行为、发现制造中的缺陷或发现网络中的安全漏洞。例如，Uber 在其金融交易中使用 VAE 进行异常检测，以检测欺诈行为。 2.2 Pre-trained 预训练预训练 是chatGPT训练 的第一个阶段。 chatGPT 的 训练可以分为以下几个阶段 pre-training supervised fine-tuning reward modeling reinforcement learning 其中pre-training是第一个阶段, 在预训练阶段使用的数据集通常是从互联网上收集的大量文本，这些文本可能包含多种语言、主题和格式。 预训练的目标是让模型在大量的文本数据上进行了广泛的训练学习了语言的结构、语法以及大量的知识。学习结束后， 预训练 阶段会产出一个base model, base model 可以根据 用户的输入， 去续写文本， 注意， 这个阶段的chatGPT 还不能回答你的问题。 针对以下问题输入，，比如， 它只能给出这样的回答。what is the capital of China? base model 并不会回答问题，给出“beijing”, 而是会续写内容， 给出以下可能的答案 what is China’s largest city?what is China’s population?what is the currency of China? 如果想让模型“理解”人类的问题并进行回答， 还需要进行第二阶段的训练 supervised fine-tuning。 2.3 TransformerChatGPT的核心技术是Transformer架构，这是一种深度学习模型，擅长处理序列数据。Transformer通过自注意力机制（self-attention mechanism）来捕捉输入文本中的重要特征和上下文关系。这种架构使得模型在处理长文本和复杂上下文时，能够保持较高的准确性和连贯性。 要理解Transformer在ChatGPT中的应用，我们可以用一个简单的类比来说明。想象一下，你在读一本书，并试图理解每一段的意思。你的大脑不仅仅是逐字逐句地阅读，还会结合前后的内容，理解整段的意义。Transformer在ChatGPT中的作用就像你大脑的这种理解机制。 3. chatGPT 使用场景发挥你的想象，能用的具体场景是在太多了。后面这里会陆续补充我使用的场景","tags":["AI","chatGPT"]},{"title":"GPTs开发-Best English Name，你找到最合适、最满意的英文名","path":"/209fa7d3/","content":"最近开发了一个用来取英文名的GPTs Best English Name。作为GPTs 开发者，虽然离openai 给我发钱还远着呢，但是没关系，我可以自己先用GPTs 变现，虽然变现的钱还只够cover 一个月plus 的费用。 Best English Name 是什么 Best English Name 是一个起名助手，它可以帮助你找到气质相符且满足各种要求的英文名，并且会对英文名有详细且深入的解释，让你充分了解自己的英文名。这个气质可以是你通过图片上传告诉chatGPT, 也可以自己描述给chatGPT,同时你也可以有其他定制化要求，包括但不限于 和中文读音/拼写类似 特定长度 特定开头字母 女性化/中性化/男性化 MBTI 我为什么要开发Best English Name我的痛点本人在工作、生活中均有需要用到英文名的场景， 记得第一次需要取英文名是入职新公司，我花了一下午的时间在豆瓣上翻找曾经看过的英文影视剧，试图找到一个喜欢的英文名， 但最后选定的名字总让我觉得“这不是我”。 我自己在确定英文名的过程中，有这样的担忧 这个名字听起来非常“不像我” 这个名字适合女生吗 这个名字在英语国家奇怪吗，会不会根本就没人起这个名字 这个名字会不会太大众化了，会不会有点过时了 这个名字会不会有什么不好的寓意，到时候引起不必要的误会 同时我对那个我将要喜欢且适合的英文名也有一定的要求 我希望这个英文名中性化一点 我希望我的名字以A 开头 我希望这个名字有美好的寓意且我能够了解这个美好的寓意，这样当别人问我为什么取这个名字的时候，我就可以清楚地向ta 介绍我的名字 开始使用chatGPT 后， 我发现它可以很好的提供一些满足我要求的英文名，同时规避掉我的担忧。 痛点的大众化在小红书闲逛时，我发现有很多人都在为选择一个英文名困扰， ta 们通常会发出一张照片让网友根据第一眼印象帮忙起名，有时候会有一些额外的需求。 同时我还发现有很多人经常向网友询问自己的英文名是什么意思。 我认为这两种情况和我起名字时遇到的问题是一样的，chatGPT 能帮助我找到满意的英文名，那么它也可以帮助其他人找到满意的英文名， 所以我把自己取英文的过程做成了一个可复用的GPTs, 希望可以帮助更多人找到满意适合的英文名 GPTs 的工程开发一个不懒的GPTs回答详细深入。 一个抗攻击的GPTs不会泄漏该GPTs 的instruction","tags":["AI","chatGPT"]},{"title":"Intro to AI","path":"/81fcff81/","content":"在学习AI 过程中，发现专业名词相当多，初学者可能会感到而混乱，所以本篇内容是对该领域内的一些“大词”进行简单介绍， 做一些概念扫盲， 以保证在接下来的学习中心中有框架。 正式内容会按照下图框架介绍 1. 人工智能 (Artificial Intelligence)人工智能（Artificial Intelligence，简称AI）是一门研究和开发用于模拟、扩展和扩展人类智能的理论、方法、技术及应用系统的科学技术。 简单来说，AI指的是使计算机系统能够执行通常需要人类智能才能完成的任务。这些任务包括学习、推理、解决问题、感知、语言理解和生成等。 人工智能（AI）的发展历史可以追溯到20世纪中期，它的发展经历了多个重要阶段，每个阶段都有其独特的特点和里程碑事件。下面来简单介绍其发展历程 1.1 早期阶段：基础理论和初步探索（1950s-1960s）1956年达特茅斯会议：AI正式诞生。1956 年，John McCarthy、Marvin Minsky、Allen Newell 和 Herbert A. Simon 等研究者在达特茅斯会议上首次提出了“人工智能”这一术语，标志着AI研究正式成为一个独立的学科。 1950年代末：艾伦·图灵提出了“图灵测试”，成为判断机器是否具备智能的基准。 这一时期，由于技术和硬件的限制，早期的AI系统主要关注于简单任务的自动化，如象棋和跳棋游戏。例如，IBM 的 Deep Blue 和 MIT AI Lab 的 MacHack VI 等系统在象棋游戏中取得了显著的成就。这些系统虽然在处理复杂模式方面受限，但它们的成功展示了AI在规则清晰、限定环境中的潜力。 1.2 专家系统与机器学习（1970s-1990s）1970年代：专家系统（Expert Systems）开始兴起，如MYCIN用于医疗诊断，DENDRAL用于化学分析。这些系统能够储存、解释和推理知识,可以用来解决特定领域的问题。 1980s：反向传播算法（Backpropagation）的提出使神经网络重新受到关注。尽管计算能力仍有限，但理论和方法上的突破为未来的发展奠定了基础。 1990s: 随着更多的数据可用和计算能力的增加，机器学习方法，特别是基于统计的方法开始主导AI研究。支持向量机和随机森林等技术的发展，为AI在图像识别、自然语言处理和其他复杂模式识别任务中的应用打开了新的可能性。 1.3 现代AI：大数据与深度学习时代（2000s-至今） 计算能力和数据的提升： 2000s：互联网和大数据的发展，为AI提供了大量训练数据。计算能力的提升，特别是GPU的使用，使得复杂的模型训练成为可能。 深度学习的崛起： 2010s：深度学习（Deep Learning）在图像识别、语音识别、自然语言处理等领域取得突破。AlexNet在2012年ImageNet竞赛中的成功，标志着深度学习的重大胜利。 广泛应用： 2010s-至今：AI在自动驾驶、医疗诊断、金融分析、智能客服等领域得到广泛应用。2016年，AlphaGo击败围棋冠军李世石，展示了AI在复杂博弈中的强大能力。 自然语言处理：GPT-3等大型语言模型的推出，使得AI能够生成逼真的自然语言文本，应用于翻译、对话系统、内容创作等多个领域。 2. 机器学习 与 深度学习机器学习（Machine Learning）和深度学习（Deep Learning）是现代人工智能（Artificial Intelligence）领域的核心技术。它们的发展极大地推动了从图像识别到自然语言处理的各种应用。 2.1 机器学习（Machine Learning）机器学习是一种使计算机能够通过经验自动改进的技术。它依赖于算法和统计模型，使得计算机系统可以识别数据中的模式并做出决策，无需明确编程。 主要类别： 监督学习（Supervised Learning）：模型在带有标签的数据集上进行训练，学习输入与输出之间的映射关系。应用包括分类（Classification）和回归（Regression）。 无监督学习（Unsupervised Learning）：模型在没有标签的数据集上工作，目标是发现数据的内在结构。常见的任务有聚类（Clustering）和降维（Dimensionality Reduction）。 半监督学习（Semi-supervised Learning）：使用部分标记的数据进行训练，结合监督学习和无监督学习的特点。 强化学习（Reinforcement Learning）：模型通过与环境的交互学习策略，目标是最大化某种数值奖励（Reward）。 2.2 深度学习（Deep Learning）深度学习是机器学习中的一个子集，它使用称为人工神经网络（Artificial Neural Networks）的模型，特别是具有多个层（Layers）的深层网络，以学习数据的高级抽象特征。 核心概念： 神经网络（Neural Networks）：一个由节点（或称为神经元，Neurons）组成的网络，节点在层中组织并通过激活函数（Activation Functions）处理信息。 卷积神经网络（Convolutional Neural Networks, CNNs）：特别适合处理图像数据。 循环神经网络（Recurrent Neural Networks, RNNs）：优秀的处理序列数据如时间序列或自然语言的工具。 长短期记忆网络（Long Short-Term Memory, LSTM）和门控循环单元（Gated Recurrent Units, GRU）：是RNN的变体，解决了传统RNN长期依赖问题。 Transformer：一种基于自注意力机制（Self-attention Mechanism）的架构，广泛用于自然语言处理领域。 2.3 区别与联系联系： 深度学习是机器学习的一种特殊形式，利用复杂的神经网络结构来解决广泛的问题。 两者都依赖数据来学习，并通过迭代过程改进模型性能。 区别： 机器学习包括一系列不仅限于神经网络的技术和方法。 深度学习通常需要更大量的数据和更强的计算能力。 3. 神经网络 (Neural Networks)神经网络是实现AI 的一种技术手段，一种广泛用于机器学习（Machine Learning）和深度学习（Deep Learning）领域的计算模型/算法架构。 它受到人类大脑神经元（Neurons）和它们的互动方式的启发，它由多个层（Layers）组成，每层包含多个神经元，这些神经元通过权重（Weights）连接传递信息。 神经网络的训练过程基于机器学习的基本前提，即能够从数据中学习。通过向网络提供大量的数据样本（包括输入和期望的输出），神经网络可以学习到如何映射输入到输出，这种能力是通过调整内部结构（即权重）来实现的。 这一学习过程使用了机器学习中的核心概念，如损失函数（Loss Functions）、梯度下降（Gradient Descent）和反向传播算法（Backpropagation Algorithms）。这些都是机器学习领域的基本工具，用于训练模型以改进其性能。 4. TransformerTransformer（变换器）是一种革命性的神经网络架构，它在自然语言处理（Natural Language Processing, NLP）和其他序列建模任务中取得了显著的成就。Transformer 最初由 Vaswani 等人在 2017 年的论文 “Attention Is All You Need” 中提出，其核心思想是完全依靠注意力机制（attention mechanisms），摒弃了之前常用的循环神经网络（Recurrent Neural Networks, RNNs）和卷积神经网络（Convolutional Neural Networks, CNNs）中的结构。 5. NLP自然语言处理（Natural Language Processing，简称NLP）是人工智能的一个分支，致力于让计算机理解、解释和生成人类语言。它结合了计算机科学、人工智能和语言学的知识与技术，用于处理和分析大量的自然语言数据。 NLP使用各种技术来处理和理解语言。这些方法从规则基础的方法到基于机器学习的方法，特别是深度学习，都有涵盖。随着时间的推移，深度学习在NLP中变得越来越重要，因为它能够在处理自然语言的复杂性方面提供显著的改进。 传统方法： 基于规则的系统：使用预定义的语言规则来解释文本。 统计模型：基于大量语料库数据，使用统计方法推断和预测。 现代方法 神经网络：使用多层神经网络模型处理语言任务，如循环神经网络（RNN）、长短期记忆网络（LSTM）和最近的变换器模型（如BERT、GPT）。 NLP技术被广泛应用于各种现实世界的场景和产品中，例如： 聊天机器人和虚拟助手（如Apple的Siri、Google Assistant、Amazon Alexa）。 文本分析工具，帮助企业监测和分析社交媒体上的消费者情绪。 电子邮件过滤和反垃圾邮件技术。 语音到文本服务，如在法庭记录或医疗记录系统中自动转录口述内容。 5. LLMLLM（Large Language Models，大型语言模型）是自然语言处理（Natural Language Processing, NLP）领域的一种先进技术，主要依赖于深度学习（Deep Learning）技术，特别是基于 Transformer 架构的神经网络模型。这些模型因其规模庞大和在多种语言任务上的出色表现而得名。 LM 是设计用来理解、生成、翻译、摘要等处理文本的大规模神经网络模型。它们通常包含数十亿至数万亿个参数，并在大量多样化的文本数据上进行训练，以学习语言的深层次结构和语义。核心组件 Transformer 架构（Transformer Architecture）： LLM 多使用基于 Transformer 的模型，这种模型依靠自注意力机制（Self-Attention Mechanism）来处理文本数据，优于传统的循环神经网络（Recurrent Neural Networks, RNNs）或卷积神经网络（Convolutional Neural Networks, CNNs）。 预训练与微调（Pre-training and Fine-tuning）： 预训练（Pre-training）：在大规模未标记数据上进行，模型学习语言的通用特征。 微调（Fine-tuning）：在特定任务的较小标记数据集上进行，调整模型以适应具体应用。 自监督学习（Self-supervised Learning）： LLM 通常通过自监督学习预训练，这意味着它们使用输入数据的不同部分作为自己的监督信号，例如，预测文本中被遮蔽（Masked）的单词。","tags":["AI","chatGPT"]},{"title":"TrustMessage-基于2PC+MySQL+泛化调用实现的可靠消息中心","path":"/99d433fa/","content":"0. 项目结构介绍 Module Description trustmessage-mysql 基于2PC+MySQL表实现的可靠消息中心，业务操作+消息表操作均存在于同一个项目中 turstmessage-middleware 可靠消息中心中间件，基于RPC接口提交消息+2PC+MySQL 表实现 turstmessage-middlewareapi 可靠消息中心中间件， 回查接口定义 Turstmessage-middlewareclient 可靠消息中心中间件， 消息生产者，提供了HTTP回查接口、Dubbo泛化回查接口的示例 以下是项目正式介绍。 在业务处理中，经常会有重要但没那么紧急的数据需要同步给下游，比如 订单侧完成消息后给优惠侧发一个消息，优惠侧做一个单向对账的功能，确保券被正确核销 在这种场景中，需要把本地业务操作 + 消息发送当成一个事务处理，即满足原子性， 一般常见的解决方案会有两种 本地事务+本地消息表 RocketMQ 本项目将从本地事务+本地消息表 出发， 一步步探讨如何用 MySQL 实现一个支持分布式事务的可靠消息中心，即TrustMessage。 项目github链接，点击可查看代码 1. 本地事务+ 本地消息表由于Spring 的事务机制只保证数据库操作的原子性，所以当涉及到 数据库的业务操作 和 其他中间件如kafka操作 具有原子性的时候，就要用其他的方案来保证。 本地事务+ 本地消息表 这种方案是把 需要发送的消息作为数据库操作的一部分，保存到数据库中的一个表里，然后通过另外的逻辑，将消息的真正发送 稍后异步进行，比如用一个定时任务将消息异步发送到Kafka。 这种方法确保了数据库操作和消息发送在逻辑语义上的原子性，因为它们都在同一个数据库事务中处理。 这里需要注意，这种方案的实时性是比较差的，所以你需要判断的业务场景场景是否能够容忍这样的异步操作。 1.1 业务流程 以上流程中，在本地事务提交后，有一个定时任务轮询消息表将需要发送的消息消息发送出去。有4个点需要注意一下 事务提交后了，消息发送失败， 定时任务的重试机制，会找出这条消息进行异步补发 事务提交后了，消息发送成功，但是消息状态修改状态， 定时任务会找出这条再次发送 重试异步补发过程中，如果消息依然发送失败，那么会继续重试补发 重试异步补发过程中，消息发送成功，但是数据库消息已发送状态修改失败，那么定时任务又会再次找到这条消息再发一遍 以上 2和4 均会面临消息重复的情况， 个人认为在业务常见中消息重复是一种可接受的情况，有时候业务自己甚至会消息重放， 所以消息消费者做好幂等逻辑就可以了。 1.2 消息发送重试次数消息发送不能无限次重试 浪费资源，重试了那么多次都未成功，可能是逻辑出现问题了或者宕机了，赶紧去查问题吧 上下游业务数据迟迟无法达到最终一致性 ， 本身我们使用消息其终极目的就是为了让系统数据达到最终一致性， 如果一直无限制发送，这个目的是无法达到的, 所以赶紧停下去查问题吧 基于以上两个考虑，系统对于重试都应该有个次数限制，达到次数限制后就应该告警让人工介入处理。 1.3 消息表设计在本地事务+ 本地消息表 方案中，其消息表的设计一般如下， 1234567891011CREATE TABLE message (\tid bigint unsigned NOT NULL AUTO_INCREMENT,\tmessage text COMMENT &#x27;消息内容&#x27;,\tsend_status INT DEFAULT 0 COMMENT &#x27;0-投递中 1-投递成功 2-投递失败&#x27;,\tsend_try_count INT DEFAULT 0 COMMENT &#x27;commit 消息发送 当前重试次数&#x27;,\tsend_next_retry_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;消息发送 下次重试时间&#x27;,\tcreate_time DATETIME DEFAULT CURRENT_TIMESTAMP,\tupdate_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\tPRIMARY KEY (id),\tUNIQUE INDEX idx_messageKey(message_key)) ENGINE=InnoDB; 2. 如果消息表和业务表操作是分布式事务但是如果保证不了这两个表不在同一个库 /数据库实例中，那就会在业务操作和消息表写入两个操作中遇到分布式事务。这在分库分表的业务中是很容易出现的情况。 针对对分布式事务，常见的解决方案就是 2PC、3PC、TCC、SAGA。 接下来将讲解以 2PC+MySQL消息表 实现的可靠消息中心 2.1 业务流程以MySQL消息表+ 2PC 来实现可靠消息中心， 其整体实现流程如下 2.2 消息可见性消息可见性， 在涉及分布式事务的场景中，消息增加了一个可见性概念， 这是因为在引入2PC 后，写入消息表的消息不再像本地事务+本地消息表一样写入即可见，必须是commit后才对消费者可见， 所以在数据表的设计中需要增加一个状态字段来维护消息可见性。1message_status INT COMMENT &#x27;消息状态 1-prepare 2-commit 3-rollback 4-unknown&#x27;, 其状态流转如图所示 2.3 如果业务执行消息commit or rollback 失败怎么办-消息回查如流程图中所示，在2PC 阶段，拿到业务执行结果修改消息状态失败有可能是失败。 一个操作执行失败后，一种常见的解决方案方案就是重试，尽最大努力交付。 但是对于业务处理来讲，一般有超时时间的限制，因为这种同步重试可能并不适用，即使可以，一般重试次数都会限定在3次。 除了同步重试，还有一种方案就是 消息回查，我个人理解这相当于一种异步重试。 在本项目中，消息回查指的就是开启一个定时任务去全表扫描，找出insert一定时间后，其状态仍然是 prepare的消息 ，通过业务逻辑判断该条消息是否已经执行完成 or 失败，对应地把消息状态更改为 commit or rollback。 为了进行消息回查，肯定要有一个业务唯一标识来识别该条消息需要对应业务数据，从而判断对应业务是否执行完成。1message_key VARCHAR(255) COMMENT &#x27;消息唯一键，用于做回查的标识&#x27;, 2.4 消息回查不能无限次 浪费资源，回查了这么多次的都没拿到结果，一种可能就是业务逻辑出现问题了，适可而止赶紧去查问题吧 系统数据迟迟无法达到最终一致性 ， 本身我们使用消息其终极目的就是为了让系统数据达到最终一致性， 如果一直无限制查询，这个目的是无法达到的, 所以赶紧停下去查问题吧 所有消息回查应该有个次数限制， 这就是表中以下两个字段的作用12verify_try_count INT COMMENT &#x27;消息状态回查 下次重试次数&#x27;, verify_next_retry_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;消息状态回查 下次重试时间 1-未发送 2-已发送&#x27;, 2.5 消息回查次数达到上限怎么办有两种参考方案 默认修改消息状态为commit 或者 rollback， 将消息状态置为回查失败状态 ， 告警人工介入处理 默认修改消息状态为commit 或者 rollback 这个方案，一个最大的问题就是针对状态不确定的消息，不论将其默认修改为那种状态， 都是有可能引起业务上下游数据不一致问题。 一旦上下游数据产生了数据不一致性，必然导致很长的排查链路和大量的数据修复工作。 所以本项目中我选择第二种方案，消息回查达到上限后直接告警，让消息生产者这一方人工介入处理。 此处说明一下，这种方案当然也会有数据不一致的问题，因为下游业务始终还未拿到消息修改自己的状态，但是相比拿到了随机确定的的状态 导致的数据不一致性，此时问题还被控制在消息生产者这一环，问题排查会相对简单。 2.6 消息发送重试与本地事务+本地消息表方案一致 2.7 消息表设计123456789101112131415CREATE TABLE message (\tid bigint unsigned NOT NULL AUTO_INCREMENT,\tmessage_key VARCHAR(255) COMMENT &#x27;消息唯一键，用于做回查的标识&#x27;,\tmessage text COMMENT &#x27;消息内容&#x27;,\tmessage_status INT DEFAULT 1 COMMENT &#x27;消息状态 1-prepare 2-commit 3-rollback 4-unknown&#x27;,\tverify_try_count INT DEFAULT 0 COMMENT &#x27;消息状态回查 当前重试次数&#x27;,\tverify_next_retry_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;消息状态回查 下次重试时间&#x27;,\tsend_status INT DEFAULT 0 COMMENT &#x27;0-投递中 1-投递成功 2-投递失败&#x27;,\tsend_try_count INT DEFAULT 0 COMMENT &#x27;commit 消息发送 当前重试次数&#x27;,\tsend_next_retry_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;消息发送 下次重试时间&#x27;,\tcreate_time DATETIME DEFAULT CURRENT_TIMESTAMP,\tupdate_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\tPRIMARY KEY (id),\tUNIQUE INDEX idx_messageKey(message_key)) ENGINE=InnoDB; 2.8 消费者消费消息针对可见， 即已经commit 的消息，消费者该如何获取到消息消费呢，有两种方案 消息者直接查询消息表 消费者从消息队列队列消费 2.8.1 消息者轮训消息表这种方案最大的问题就是，在微服务架构下，上下游两个不同的服务 操作 同一个数据表 是一个不合理且不推荐的做法。 2.8.2 消息队列消费和本地事务+本地消息表一样，已经commit 的消息可以由一个定时任务轮训发送到业务创建的消息队列中供订阅的消费者消费发送过程也可以有一个重试的过程。 3. 如果这是一个公共中间件-基于RPC 接口实现的可靠消息中心以上讨论的方案， 都是基于消息表逻辑和业务逻辑同一个服务中， 如果把该功能做成一个公共中间件，那么在技术方案上会略有变化。 中间件需要提供的功能 两阶段提交功能 回查功能 消息转发 以上3个功能和上一种方案没有本质上的区别， 只是基于一个中间件的定位，支持这3种功能需要更多的封装与数据信息。 3.1 业务流程 3.2 两阶段提交功能提供3个RPC 接口， prepare， commit, rollback, 接口底层封装对数据表的操作 3.3 消息唯一性当作为一个公共中间件，接受多个业务数据的时候，消息的唯一性应该有业务标识 + 消息标识共同确定，即bizId + messageKey 3.4 回查功能相比于直接在业务服务里集成可靠消息的功能时，可以简单直接的在服务内部查询，当作为公共中间件时， 只能通过服务间调用完成，服务间调用有两种形式 HTTP RPC 为了增加可维护性和拓展型， 无论是哪种形式，中间件都应该定义好调用的格式，让消息生产者按照统一格式提供回查接口。 这个格式包括 接口定义 接口入参 接口返回值 其中接口定义信息需要生产消息时提供 在实现消息生产者按照统一格式提供回查接口 这一点是，HTTP接口的回查相对简单， 如果RPC 接口， 要注意使用泛化调用。 本项目实现了HTTP 接口的回查和 Dubbo 协议的泛化调用回查 HTTP接口格式为1http://127.0.0.1:8082/verifyMessage?bizID=1&amp;messageKey=key1 Dubbo RPC 接口定义为12345public interface VerifyMessageService &#123; // 消息回查接口 int verifyMessage(Integer bizID,String messageKey); &#125; 3.5 消息转发在一个公共中间件里实现消息转发，必然也需要生产消息时提供这部分信息12forward_topic VARCHAR(255) COMMENT &#x27;业务转发topic&#x27;, forward_key VARCHAR(255) COMMENT &#x27;业务转发指定key&#x27;, 3.6 消息表设计12345678910111213141516171819CREATE TABLE message (\tid bigint unsigned NOT NULL AUTO_INCREMENT, biz_id INT NOT NULL COMMENT &#x27;业务ID&#x27;, message_key VARCHAR(255) COMMENT &#x27;消息唯一键，用于做回查的标识&#x27;,\tmessage text COMMENT &#x27;消息内容&#x27;,\tmessage_status INT DEFAULT 1 COMMENT &#x27;消息状态 1-prepare 2-commit 3-rollback 4-verify fail&#x27;, forward_topic VARCHAR(255) NOT NULL COMMENT &#x27;业务转发topic&#x27;,\tforward_key VARCHAR(255) COMMENT &#x27;业务转发指定key&#x27;, verify_info VARCHAR(2000) COMMENT &#x27;回查信息&#x27;,\tverify_try_count INT DEFAULT 0 COMMENT &#x27;消息状态回查 当前重试次数&#x27;,\tverify_next_retry_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;消息状态回查 下次重试时间&#x27;,\tsend_status INT DEFAULT 0 COMMENT &#x27;0-投递中 1-投递成功 2-投递失败&#x27;,\tsend_try_count INT DEFAULT 0 COMMENT &#x27;commit消息发送 当前重试次数&#x27;,\tsend_next_retry_time DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;消息发送 下次重试时间&#x27;,\tcreate_time DATETIME DEFAULT CURRENT_TIMESTAMP,\tupdate_time DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,\tPRIMARY KEY (id),\tUNIQUE INDEX idx_message_key_biz_id (message_key, biz_id)) ENGINE=InnoDB; 4. 基于kafka 提交消息实现的可靠事件中心在实现消息回查的可靠消息中心方案中，另外一种常见的方案是 业务代码直接把消息提交给kafka, 然后中间件消费消息并持久化道数据库中，等待消息提交commit 或者rollback , 没有的话就进行回查。如下图，图片源自极客时间专栏 我认为两种技术方案没有本质的区别， 其差异只是消息的prepare 、commit、rollback 的提交是由RPC 接口完成还是由消息生产消费完成， 其他回查的逻辑、发送逻辑、以及需要的信息基本无差异。 不过在使用Kafka 提交时，有以下两种需要考虑 4.1 中间件如何识别一条消息是事务消息 Topic命名约定 一种简单的方法是通过Topic命名来区分。例如，所有需要支持回查的Topic可以遵循一个特定的命名模式，如添加前缀或后缀（例如，replayable-myTopic）。这种方法的优点是简单易实施，但缺点是灵活性较低，且对现有系统可能需要更多的改动。 特定主题或分区 将需要回查的消息发送到Kafka的特定主题或分区中。这样，中间件只需监听这个特定的主题或分区来处理需要回查的消息。这种方法要求生产者在发送消息时知道哪些消息需要回查，并据此发送到正确的主题或分区。 Topic配置属性 Kafka允许为每个Topic设置自定义配置属性。可以引入一个自定义属性（如replayable=true）来标识一个Topic需要支持消息回查。这种方式比命名约定更为灵活和隐蔽，但要求应用层和消息生产者遵循这一约定，并且需要在应用层实现逻辑来处理这些属性。 消息元数据标记 在消息发送时，可以在消息的元数据（Metadata）中添加特定的标记或字段来指示这条消息需要进行回查。 设计考虑： 性能：确定这些方法中哪一种对生产和消费的性能影响最小。 易用性：选择易于实施和维护的方法。 灵活性：评估是否需要对单个消息进行标记，还是以Topic为单位进行区分。 4.2 如何识别消息类型、转发信息、回查信息消息类型包括 prepare、commit、rollback转发信息,需要转发至的真正业务tpoic、 如果需要指定分区的话还包括key信息回查信息，包括回查方式如HTTP、RPC, 回查地址，回查接口等 使用Kafka消息头 优点： 保持了消息体的纯净和独立性。 灵活性高，易于添加或修改额外的控制信息和元数据。 性能考虑，对于小到中等大小的消息，使用消息头的性能开销相对较小缺点： 新版本依赖：较旧版本的Kafka客户端可能不支持消息头功能，这要求生产者和消费者使用支持消息头的Kafka版本。 额外处理：消费者需要额外的步骤来读取和解析消息头。 预先定义消息格式 优点： 直接且简单，易于实现。 不依赖Kafka特定的功能，具有较好的兼容性。缺点： 增加了消息体的大小。 需要在消费端进行消息解析，略微增加了处理的复杂性。 本项目以指定topic+预定义消息格式的方式简单实现了消息的提交，消息格式如下， 大家可以参考。12345678910111213141516171819202122232425262728package com.example.trustmessage.middlewareapi.common;public class MiddlewareMessage &#123; // 要给到业务方的真正消息 private String message; private int bizID; // 用于消息回查的业务唯一标识 private String messageKey; private int messageStatus; private String forwardTopic; // 向业务方转发时需要指定的key，没有则说明按照kafka 默认分区策略进行分区 private String forwardKey; private VerifyInfo verifyInfo; public static class VerifyInfo &#123; private int protocolType; // 1-http, 2-rpc-dubbo private String registryProtocol; private String registryAddress; private String url; private String version; &#125; &#125; 5. 基于RPC接口 vs 基于Kafka提交基于两种不同消息提交方式实现的中间件， 将从以下两方面进行比较 消息的顺序性 流量增加后扩容 5.1 消息的顺序性使用中间件回查机制，由于网络原因，有可能出现 某条业务的commit or rollback 消息比prepare 先到达中间件，面对这种情况,commit or rollback的处理逻辑是需要报错的，client 只能重试或者等待回查机制更新消息状态 但是由于kafka 可以在一个分区内的保证消息的有序性，所以基于Kafka提交的方案可以有一种优雅的方式保证prepare消息和commit/rollback 消息的有序性。 解决方案很简单，生产者在发送消息按照业务 唯一标识指定key ,即指定目标分区即可。 5.2 流量增加后扩容以下比较基于在代码层面已经做好分库分表、异步处理、批量处理、cache 等性能优化的基础上 假设已经分库分表，数据库处理不是瓶颈万一流量激增，基于Kafka提交的方案 可能会产生产生必须要处理的消息积压，针对消息积压常见的解决方案中 增加消费者数量，不过一般来讲，线上生产环境都会已经把消费者数量和分区数量设置成一样的，所以这个方案无法发挥功能 增加分区数量，假设公司的工作流程里允许增加，如果使用场景对消息顺序性有要求，你又要考虑新增分区后对消息顺序性的影响 新建一个更多分区的topic, 涉及到生产者、消费者的代码变更 消费者性能优化， 比如异步处理、批量处理， 但是如果项目已经做好这些措施，面对消息积压，只能回到下面3种方式 综合以上，我个人认为基于RPC接口的方案可以用自动扩容策略直接应对， 简单直接优雅。 6. 作为中间件的技术设计6.1 性能提升 线程池异步处理 cache 存储回查接口 基于bizID + messageKey 的分库分表 6.2 幂等性 prepare 消息的幂等性， 唯一索引","tags":["事务"]},{"title":"深入解析bloom filter的原理与实现","path":"/b4fa673f/","content":"0.什么场景下会用到bloom filter 缓存穿透 爬虫重复 URL 检测， 避免爬虫过程形成环 假设有 10 亿条手机号，然后判断某条手机号是否在列表内 唯一昵称判断 这些场景可以用什么方式解决 hashmap, hashset MySQL：正常情况下，如果数据量不大，我们可以考虑使用 mysql 存储。将所有数据存储到数据库，然后每次去库里查询判断是否存在。但是如果数据量太大，超过千万，mysql 查询效率是很低的，特别消耗性能。 bitmap bloom filter 1.bloom filter 是什么？布隆过滤器是一种概率性数据结构，它提供了一种空间效率极高的方法来测试一个元素是否属于一个集合。 其基本原理是使用多个不同的哈希函数对元素进行哈希，然后将得到的哈希值对应到位数组上。一个元素被加入到集合中，那么所有哈希函数计算出的位置都会被置为1。检查元素是否存在于集合中时，使用这些哈希函数计算哈希值，并检查对应的位是否都是1。如果都是1，那么元素可能存在于集合中；如果任何一个位不是1，那么元素肯定不在集合中。 其主要特点是： 高空间效率：相比于传统的集合数据结构，布隆过滤器使用极少的空间来处理大量数据。 误报率/假阳：布隆过滤器有一定的误报概率，这意味着它可能会错误地认为某个不在集合中的元素存在于集合中。 零漏报率：不会遗漏集合中真正存在的元素 不可删除：标准的布隆过滤器不支持从集合中删除元素，尽管存在变种（如计数布隆过滤器）支持这一操作。 多哈希函数：布隆过滤器通过多个哈希函数来减少误报率，每个元素被多个哈希函数映射到位数组的多个位置。 1.1 为什么空间效率高bloom filter 采用 位数组（bit array）作为核心的数据结构。 位数组是一个非常紧凑的数据结构，它可以有效地表示大量的布尔值（true或false），每个值只占用一个位（bit），而不是使用更传统的数据类型会占用更多的空间。 比如在爬虫场景中，假设有1亿个URL，每个URL算4字节, 如果用hashmap 实现，一个URL所占空间至少4bytes;如果用位数组实现，每个URL 所占的空间仅1bit，空间效率提升了32倍（存储空间不考虑误判率的前提下）。不可谓不高效。 1.2 为什么会有误报率/假阳既然用到了哈希函数，肯定会遇到哈希冲突。所以一个元素对应 的n 个位置， 可能因为其他元素的哈希冲突 而导致判断时发现等于1， 从而产生假阳现象。 1.3 误报如何解决假阳问题无法被避免，只能尽可能减少。 减少的途径是选择合适的哈希函数以及指定合适的空间大小 1.4 为什么需要多个哈希函数布隆过滤器的设计使用多个哈希函数来解决单个哈希函数可能带来的局限性，提高其效率和准确性。具体来说，使用多个哈希函数的原因包括： 降低误报率 通过使用多个哈希函数独立地映射每个元素到位数组中的多个位置，并在所有这些位置上标记为1，可以显著降低不同元素映射到相同位置（即产生冲突）的概率，从而降低误报率 均匀分布 多个哈希函数可以将元素更均匀地分布在位数组上，减少了集中冲突的可能性。如果只使用一个哈希函数，即使其分布性质良好，也难以保证对于所有可能的输入集合都能保持良好的均匀性。多个哈希函数的组合，如果设计得当，可以相互补偿，实现更为均匀的分布。 1.5 为什么数据不可删除在布隆过滤器中，元素的存在是通过多个位的“1”状态来表示的，而将这些位重置为“0”可能会错误地影响其他元素的存在检测。 如果需要支持删除，可以考虑使用 变体Bloom Filter， 如cuckoo filter 2. bitmap 和 bloom filter 的区别Bitmap（位图）和布隆过滤器都是使用空间效率高的数据结构，它们通过利用位操作来实现存储和查询，但它们的设计目的和应用场景有所不同。 2.1 Bitmap（位图）位图是一种数据结构，用于高效地存储和查询状态信息。在位图中，每个元素的存在或状态是由单独的位来表示的，即使用1位二进制数（0或1）来表示每个元素是否存在或某种特定状态。 主要特点和用途： 简单直接：适用于需要追踪大量元素（如整数）存在与否的场景。 空间效率：对于大规模数据集，位图使用的空间远小于传统的数据结构（如数组或列表）。 随机访问：可以非常快速地检查任何一个元素的存在与否或状态。 固定大小：位图的大小在创建时由最大元素值决定，因此其空间效率依赖于数据的分布。 BitMap 的实现java BitSetredis setbit、getbit 2.2 区别 用途：位图主要用于精确表示一个大型数据集中元素的存在与否或状态信息，而布隆过滤器用于以极小的空间成本判断元素是否可能存在于集合中。 错误率：位图提供了100%准确的结果（假设足够的空间来表示所有元素），而布隆过滤器允许一定的误报率。 操作：位图支持添加、查询和删除（通过位反转）操作，而标准布隆过滤器不支持删除操作。 空间效率与数据规模：布隆过滤器在表示大型集合成员资格时通常比位图更加空间效率，尤其是当元素范围非常大但实际元素数量相对较少时。 总之，位图和布隆过滤器各有优势和应用场景，选择哪种数据结构取决于具体需求，包括对空间效率、准确率和操作类型的要求。 3. 单机版本Guava Cache 源码解析3.1 create1234567public static &lt;T&gt; BloomFilter&lt;T&gt; create(Funnel&lt;T&gt; funnel, int expectedInsertions /* n */, double falsePositiveProbability) &#123; int numBits = optimalNumOfBits(expectedInsertions, falsePositiveProbability); int numHashFunctions = optimalNumOfHashFunctions(expectedInsertions, numBits); return new BloomFilter&lt;T&gt;(new BitArray(numBits), numHashFunctions, funnel, BloomFilterStrategies.MURMUR128_MITZ_32); &#125; 3.1.1 参数解释 funnel：Funnel类型的参数，用于将任意类型的数据转化成布隆过滤器内部使用的一种形式。Funnel定义了如何把对象转换成二进制流，然后布隆过滤器使用这个二进制流来计算元素的哈希值。 expectedInsertions：这个参数指定了预期要插入布隆过滤器的元素数量。这个数值是为了优化布隆过滤器内部数据结构的大小。 falsePositiveProbability（false positive probability）：误判率。这是指一个不存在集合中的元素被判断为存在的概率。值得注意的是，随着实际插入数量的增加，实际的误判率可能会上升。 3.1.2 optimalNumOfBits123static int optimalNumOfBits(int expectedInsertions, double falsePositiveProbability) &#123; return (int) (-n * Math.log(p) / LN2_SQUARED); &#125; optimalNumOfBits通过计算,可以得到一个在满足特定假阳性率（falsePositiveProbability）要求下，对于给定数量的元素预期插入量（expectedInsertions），所需的最少位数。这使得布隆过滤器能够在保证误判率的前提下，使用最少的空间。这种计算对于设计高效且空间节约的布隆过滤器至关重要 3.1.3 计算逻辑optimalNumOfBits函数的计算基于以下公式，这个公式可以从布隆过滤器的理论误判率公式推导而来： m 是位数组的长度（即函数的返回值）。 n 是expectedInsertions，即预期的插入数量。 p 是falsePositiveProbability，即期望的假阳性概率。 ln⁡2 表示自然对数。这个公式利用了布隆过滤器的误判率特性，通过指定的假阳性率和预期插入数量来计算出一个最优的位数组长度。这个长度能够在满足误判率要求的同时，尽可能地减小布隆过滤器所需的空间。 3.1.4 实现注意实际实现时，可能还需要对计算结果进行取整处理，并确保结果是一个正整数。此外，实现可能还会考虑到性能和存储效率的平衡，比如通过限制位数组的长度为2的幂等。 3.1.5 optimalNumOfHashFunctions123static int optimalNumOfHashFunctions(int n, int m) &#123; return Math.max(1, (int) Math.round(m / n * LN2)); &#125; optimalNumOfHashFunctions(expectedInsertions, numBits)这个函数用于计算给定条件下布隆过滤器的最优哈希函数数量。这个计算基于预期要插入的元素数量（expectedInsertions）和布隆过滤器内部位数组的大小（numBits）。目的是为了平衡空间使用和误判率，确保布隆过滤器在给定条件下工作得最有效率。 计算逻辑 布隆过滤器的效率和误判率与使用的哈希函数数量有很大关系。太少的哈希函数会增加碰撞的概率，导致误判率升高；而太多的哈希函数又会导致位数组快速填满，同样增加误判率，同时还会增加计算的开销。 最优哈希函数数量的计算公式是：这个公式基于以下原理：给定一个固定大小的位数组，存在一个最优的哈希函数数量，可以最小化给定元素数量条件下的误判率。这个最优数量直接关联于位数组的大小和要处理的元素数量。 其中： k 是最优的哈希函数数量， m 是位数组的大小（numBits）， n 是预期插入的元素数量（expectedInsertions）， ln⁡(2) 是自然对数2的值，大约等于0.693。 3.1.6 new BitArray(numBits)Guava cache bloom filter 在实现位数组是采用创建long[] + 位移操作 1234567891011121314151617181920212223242526static class BitArray &#123; final long[] data; BitArray(int bits) &#123; this(new long[IntMath.divide(bits, 64, RoundingMode.CEILING)]); &#125; // Used by serialization BitArray(long[] data) &#123; checkArgument(data.length &gt; 0, &quot;data length is zero!&quot;); this.data = data; &#125; void set(int index) &#123; data[index &gt;&gt; 6] |= (1L &lt;&lt; index); &#125; boolean get(int index) &#123; return (data[index &gt;&gt; 6] &amp; (1L &lt;&lt; index)) != 0; &#125; /** Number of bits */ int size() &#123; return data.length * Long.SIZE; &#125; &#125; 3.2 put12345678910111213141516MURMUR128_MITZ_32() &#123; @Override public &lt;T&gt; void put(T object, Funnel&lt;? super T&gt; funnel, int numHashFunctions, BitArray bits) &#123; // TODO(user): when the murmur&#x27;s shortcuts are implemented, update this code long hash64 = Hashing.murmur3_128().newHasher().putObject(object, funnel).hash().asLong(); int hash1 = (int) hash64; int hash2 = (int) (hash64 &gt;&gt;&gt; 32); for (int i = 1; i &lt;= numHashFunctions; i++) &#123; int nextHash = hash1 + i * hash2; if (nextHash &lt; 0) &#123; nextHash = ~nextHash; &#125; // up to here, the code is identical with the next method bits.set(nextHash % bits.size()); &#125; &#125; 首先，这行代码使用MurmurHash3算法生成一个128位的哈希值，然后将其转换成一个long类型的数值hash64。 funnel是一个函数式接口，用于将对象转换为字节流，以便哈希函数可以处理。 hash64实际上包含两个32位的哈希值，它们可以从hash64的高32位和低32位分别提取。从hash64中提取两个32位的哈希值hash1和hash2。hash1是低32位，hash2是高32位。 接下来，代码遍历从1到numHashFunctions（布隆过滤器要求的哈希函数数量），每次循环计算一个新的哈希值nextHash。这个新的哈希值是通过hash1 + i * hash2计算得到的，其中i是当前的迭代次数。 如果nextHash为负数，通过位取反操作（~nextHash）将其转换为正数，以保证能够正确地映射到位数组的索引上。 最后，使用nextHash % bits.size()计算得到的索引值在位数组（BitArray）中对应的位置上设置位。bits.size()返回位数组的大小，这确保了计算得到的索引值不会超出位数组的范围。 3.2.1 哈希函数Guava cache 采用了非加密的单向散列函数Murmur3.MurmurHash 由Austin Appleby设计，因其高性能和良好的分布特性而广泛应用。MurmurHash有多个版本，如MurmurHash2、MurmurHash3等。 根据最开始对bloom filter 的定义，它需要多个哈希函数对数据进行哈希映射， 但Guava Cache bloom filter 实现中其实没有使用多个不同的哈希函数，而是采用了一种叫做“双哈希技术”的方法。 “双哈希技术”的基本思想是利用两个哈希函数h1(x)和h2(x)生成任意数量的哈希值，对于第i个哈希位置，使用h1(x) + i*h2(x)的方式来生成。这种方法只需要两次哈希操作，就可以模拟出多个哈希函数的效果，且生成的哈希序列具有很好的均匀分布性，既保证了布隆过滤器的效率，又避免了寻找多个好的哈希函数的复杂性，是一种在实际应用中非常实用的解决方案。 效率和复杂性具体指 性能和效率：使用单个哈希函数后通过算法变换生成多个哈希值，可以大大减少计算的复杂度和时间。多个独立的哈希函数意味着每个元素都需要被多次独立哈希，这会增加计算成本和时间。通过使用单个哈希函数并通过数学方法派生出多个伪随机的哈希值，可以在保持布隆过滤器错误率不变的前提下，显著提高效率。 简化实现：多个不同的哈希函数难以选取，而且还需保证它们相互之间的独立性和分布的均匀性，这在实践中是非常挑战性的。 3.3 mightContains和put 处理过程保持一致 3.4 guava cache 误报率-位数组长度固定在使用Guava的布隆过滤器时，预先估计将要插入的数据量非常重要。布隆过滤器在创建时会根据这个预估的数据量和指定的误判率来决定位数组的大小和使用的哈希函数数量。这些参数共同决定了布隆过滤器的性能和准确性。 如果实际插入的元素数量超过了最初的预估，过滤器的实际误判率会高于预期的误判率。这是因为当位数组变得过于饱和时，不同元素的哈希值更有可能映射到已经被设置为1的位上，从而增加了误判的几率。 Guava的文档明确指出了这一点，强调在创建布隆过滤器时应该准确预估元素数量，并考虑到这一点在其API设计中。BloomFilter.create()方法允许开发者在创建过滤器时指定预期插入的元素数量和可接受的误判率。 https://guava.dev/releases/20.0/api/docs/com/google/common/hash/BloomFilter.html 为了保证布隆过滤器的效果，应该根据实际使用场景仔细估算元素数量。如果预计数据量存在不确定性，建议预估一个上限，或者在实际元素数量超过预估时重新创建一个新的布隆过滤器。这当然会带来额外的成本，因此在设计初期做出准确估计非常关键。 总结来说，正确估计将要处理的数据量对于使用Guava布隆过滤器来说是非常重要的。如果实际数据量超过了预估，将会导致高于预期的误判率，可能影响到应用的准确性和可靠性。 4. 分布式 Redis bloom filter1BF.RESERVE &#123;key&#125; &#123;error_rate&#125; &#123;capacity&#125; [EXPANSION expansion] [NONSCALING] 4.1 参数解释4.1.1 EXPANSION expansionBF.RESERVE命令是RedisBloom模块中用来创建一个新的布隆过滤器的命令。这个命令允许用户预先为布隆过滤器指定参数，以便在插入元素之前就确定其大小和其他重要的行为特性。以下是BF.RESERVE命令各个参数的含义： &#123;key&#125;：这是将要创建的布隆过滤器的名称或键值。在Redis中，每个数据结构都通过一个唯一的键来标识和访问。 &#123;error_rate&#125;：预期的误报率。这是一个0到1之间的浮点数，表示允许的误判概率的上限。误报率越低，布隆过滤器所需的空间就越大。 &#123;capacity&#125;：布隆过滤器预期要存储的元素的数量。这个数值用于在保持误报率不变的情况下，预先计算布隆过滤器所需的最小大小。 [EXPANSION expansion]（可选）：这个可选参数用于指定当布隆过滤器的容量不足以容纳更多元素时，自动扩展的行为。expansion是一个大于1的整数，表示每次扩展增加的比例或容量。如果未指定，布隆过滤器可能会使用默认的扩展策略。 [NONSCALING]（可选）：这个可选标志用来指示创建的布隆过滤器不应自动扩展。这意味着一旦达到其容量上限，就不会尝试扩大过滤器以容纳更多的元素。这通常用于那些对空间使用有严格限制的应用场景。 作用：这个参数用于设置布隆过滤器在达到容量限制并需要扩展时，新创建的布隆过滤器层的大小。expansion的值决定了新层的容量是前一层容量的多少倍。这是一种自动扩展布隆过滤器容量的机制，以适应不断增长的元素数量，同时控制误报率。 场景：适用于那些元素数量不确定或可能会超出初始设定容量的场合。通过适当设置expansion参数，可以在维持误报率的同时动态增加布隆过滤器的容量。 举例：如果设置[EXPANSION 2]，那么每次扩展时，新的布隆过滤器层的容量将是前一层的两倍。 4.1.2 NONSCALING 作用：指定创建的布隆过滤器为非扩展型（Non-scaling）。即，一旦创建，布隆过滤器的容量固定，不会根据元素的增加而自动增加新的层。这意味着所有元素都将被添加到这个固定大小的布隆过滤器中，不管其容量是否已满。 场景：适用于元素数量预先已知且不会超出初始设定容量的场合。这种方式可以避免因为扩展而可能带来的额外内存使用，但要求用户必须更准确地预估所需的容量和误报率。 注意：当使用[NONSCALING]参数时，[EXPANSION expansion]参数将无效，因为非扩展型的布隆过滤器不会进行任何扩展操作。 4.2 可拓展特性是如何实现redis 可扩展布隆过滤(Scalable Bloom Filters)可以理解成是由多个位数组/子过滤器（布隆过滤器实例）链接在一起形成的链表(SBChain)。 每个子过滤器都有其自己的容量和误报率设置。当前的子过滤器达到容量限制时，就会动态地添加一个新的子过滤器。 这种方法的关键优势是，它可以在不断增加元素的情况下，动态地扩展总容量，同时控制整体误报率。 然而，这种动态扩展的能力也意味着查询操作可能需要遍历链表中的多个布隆过滤器实例，这可能会对性能产生一定影响。 redis bloom filter 的整体上的基本逻辑，比如位数组的大小、选择的哈希函数、哈希函数的数量、多个哈希函数的模拟与Guava cache bloom filter基本保持一致， 接下来只重点分析其可拓展性是如何实现的 4.2.1 bloom 结构体123456789101112131415bloom.hstruct bloom &#123; uint32_t hashes; uint8_t force64; uint8_t n2; uint64_t entries; double error; double bpe; unsigned char *bf; uint64_t bytes; uint64_t bits; &#125;; 这个struct bloom定义了一个布隆过滤器的基本数据结构，用于在RedisBloom模块中表示一个布隆过滤器实例。下面是对各个成员变量的详细解释： uint32_t hashes;：这表示布隆过滤器使用的哈希函数的数量。在布隆过滤器中，元素的存在是通过多个哈希函数映射到位数组的不同位置来表示的。因此，哈希函数的数量直接影响布隆过滤器的误判率和效率。 uint8_t force64;：这是一个标志位，用于指示是否强制使用64位哈希函数。在某些情况下，为了保证在不同平台上的一致性和性能，可能需要强制使用64位哈希函数。 uint8_t n2;：这个成员可能用于表示与位数组大小相关的一个参数，具体含义取决于实现细节。在一些布隆过滤器的实现中，这个参数可能与位数组大小为2的幂次方有关。 uint64_t entries;：这表示预期存储在布隆过滤器中的元素数量。这个数值对于计算位数组的大小和哈希函数数量非常重要。 double error;：这是预期的误判率（false positive rate），是设计布隆过滤器时的一个关键参数。误判率越低，所需的位数组大小和哈希函数数量就越多。 double bpe;：这表示每个元素平均占用的位数（Bits Per Entry）。这个值是根据预期的误判率和元素数量计算得出的，用于确定位数组的大小。 unsigned char *bf;：这是一个指向位数组的指针。位数组是布隆过滤器的核心，用于存储元素的哈希值映射。unsigned char类型被用来表示位数组，每个字节包含8位。 uint64_t bytes;：这表示位数组占用的字节数。由于位数组是以字节为单位进行分配的，因此这个数值表示整个位数组的大小。 uint64_t bits;：这表示位数组中的位数。这个数值是根据entries、error和bpe计算得出的，决定了布隆过滤器可以有效存储的元素数量和误判率。 4.2.2 SBLink结构体123456sb.h/** Single link inside a scalable bloom filter */ typedef struct SBLink &#123; struct bloom inner; //&lt; Inner structure size_t size; // &lt; Number of items in the link &#125; SBLink; SBLink代表了可扩展布隆过滤器中的单个链接，即单个布隆过滤器实例。 struct bloom inner;：这是一个嵌套的结构体，表示单个布隆过滤器的内部结构。这个inner结构体可能包含了实现布隆过滤器所需的所有数据，如位数组、哈希函数数量等。 size_t size;：表示当前链接（即单个布隆过滤器实例）中的元素数量。这是为了快速访问单个过滤器内元素的数量，而无需遍历整个位数组。 4.2.3 SBChain结构体123456789sb.h /** A chain of one or more bloom filters */ typedef struct SBChain &#123; SBLink *filters; //&lt; Current filter size_t size; //&lt; Total number of items in all filters size_t nfilters; //&lt; Number of links in chain unsigned options; //&lt; Options passed directly to bloom_init unsigned growth; &#125; SBChain; SBChain代表了一系列（一个或多个）SBLink结构体的链表，构成了一个可扩展的布隆过滤器。 SBLink *filters;：这是一个指向SBLink数组的指针，表示当前所有的过滤器链。每个SBLink代表链中的一个布隆过滤器实例。 size_t size;：表示所有过滤器中元素的总数量。这个数字是所有单个SBLink中size成员的总和。 size_t nfilters;：表示链中SBLink实例的数量，即当前有多少个布隆过滤器被链接在一起。 unsigned options;：这是传递给每个布隆过滤器初始化函数bloom_init的选项。这些选项可能控制如布隆过滤器的误报率、是否自动扩展等行为。 unsigned growth;：这个成员变量控制链的增长行为。它可能指定当当前的布隆过滤器填满时，如何增加新的SBLink实例，例如，增加的大小或比例等。 4.3 可扩展bloom filter的工作流程 初始化：当创建一个新的可扩展布隆过滤器时，会指定初始容量、误报率等参数。基于这些参数，创建第一个子过滤器。 添加元素：向布隆过滤器添加元素时，会从当前子过滤器开始尝试添加。如果当前子过滤器已满（即达到了其容量限制），则创建一个新的子过滤器，并在新的子过滤器中添加元素。每个新添加的子过滤器都可以根据配置的规则调整大小和误报率，以适应不断增加的元素。 检查元素：检查一个元素是否存在时，需要查询所有的子过滤器。如果任何子过滤器表示元素可能存在（即对应的位都为1），则认为元素可能存在于布隆过滤器中。虽然可扩展布隆过滤器可以动态增加容量，但查询操作的成本随之增加，因为可能需要检查多个布隆过滤器实例。 参数调整：随着子过滤器的增加，每个新的子过滤器通常会有更大的容量。这是通过调整如比特数、哈希函数数量等参数来实现的。这种方法旨在平衡误报率和内存使用，即使在不断添加元素的情况下也能维持相对稳定的误报率。 5. 可删除 bloom filter5.1 哪些场景使用布隆过滤器时需要删除以上， guava 和 redis 的bloom filter 都没有实现删除功能，不能删除的原因已经解释过，元素的存在是通过多个位的“1”状态来表示的，而将这些位重置为“0”可能会错误地影响其他元素的存在检测。 但是在某些场景还是需要删除，比如，查看一张优惠券是否已被使用？创建一个包含所有存在但还未被使用优惠券的filter。每次校验时 如果否，则优惠券不存在。 如果是，则优惠券有效。检查主数据库。如果有效，则使用后从 Cuckoo 过滤器中删除。 5.2 实现删除布隆过滤器的思路5.2.1 计数型布隆过滤器（Counting Bloom Filter）这是最直接的方法之一，它通过为每个位使用一个计数器而不是简单的布尔标记来实现。当插入一个元素时，它经过多个哈希函数映射到多个计数器上，并将这些计数器的值增加。相应地，删除一个元素时，这些计数器的值会被减少。如果任何计数器的值达到零，则表示没有任何元素映射到这个位上。这种方法的缺点是需要更多的空间来存储计数器。 5.2.2 双布隆过滤器这种方法涉及到使用两个独立的布隆过滤器：一个用于添加操作，另一个用于删除操作。当添加一个元素时，它被添加到第一个布隆过滤器中；当删除一个元素时，该元素被添加到第二个布隆过滤器中。检查元素是否存在时，如果它在第一个布隆过滤器中并且不在第二个布隆过滤器中，则认为该元素存在。这种方法的问题是误报率会增加，因为删除过滤器中的元素也可能错误地阻止对实际存在于集合中的元素的正确判断。 5.2.3 d-left 计数哈希d-left计数哈希是一种高效的数据结构，它将元素映射到固定数量的桶中，并在每个桶内维护一个计数器。这种方法可以实现快速的插入、查询和删除操作，并且相比于计数型布隆过滤器，它可以更有效地利用空间。不过，实现起来比较复杂，且当桶填满时性能会下降。 5.2.4 布谷鸟过滤器（Cuckoo Filter）布谷鸟过滤器是另一种支持删除操作的布隆过滤器变种，它基于布谷鸟哈希和部分键存储。每个元素通过哈希函数映射到一个或多个位置，并存储其“指纹”。插入、查询和删除操作都基于这些指纹。布谷鸟过滤器相比计数型布隆过滤器在空间效率上有所提高，且支持删除操作，但在极端情况下可能需要重建过滤器。 总体上可以看出可删除bloom filter 的实现都是需要额外的空间去存储额外的信息， 那么其实现方式的好坏的评判标准就是 额外空间的大小、性能 以及对误报率的影响。 以下是一张表格，总结了几种支持删除操作的布隆过滤器变体的优点和缺点： 过滤器类型 优点 缺点 计数型布隆过滤器 - 直接支持删除操作- 实现相对简单 - 更多空间需求- 计数器溢出问题 双布隆过滤器 - 实现简单- 通过额外布隆过滤器跟踪删除操作 - 增加空间需求- 误判率增加 布谷鸟过滤器 - 高效的插入、删除和查询- 空间效率高 - 实现复杂- 负载因子高时性能可能下降 d-left计数哈希过滤器 - 高空间效率- 性能优于传统计数型布隆过滤器 - 实现复杂，需要精心设计 如果应用对空间效率要求不是特别高，且需要频繁进行删除操作，计数型布隆过滤器是一个简单有效的选择。 对于需要最小化误报率而且对空间有一定要求的应用，布谷鸟过滤器提供了一个较好的平衡点。 在需要极致空间效率且能够接受实现复杂度的高性能应用场景中，d-left 计数哈希过滤器可能是最佳选择。 关于空间的使用，有如下比对效果 redis 实现了cuckoo 变体bloom filter， 下面来讲一下 cuckoo filter 的原理 6. Cuckoo FilterCuckoo Filter 论文 the basic unit of the cuckoo hash tables used for our cuckoo filters is called an entry. Each entry stores one fingerprint. The hash table consists of an array of buckets, where a bucket can have multiple entries. 在Cuckoo Filter 中，最基本的存储单元是entry, 每个单元存储一个 fingerprint。cuckoo hashing 哈希表由一组桶（buckets）组成，每个桶可以包含多个条目（entries）。 Cuckoo Filter的关键特性 双哈希函数：对于任何一个给定的键，Cuckoo Hashing使用两个独立的哈希函数 h1 和 h2 来计算两个候选桶的位置。这两个位置是键可能被存储的地方。 指纹存储：与传统的哈希表不同，Cuckoo Hashing不存储完整的键，而是存储键的指纹。这允许在不牺牲太多空间效率的情况下进行高效的查找和删除操作。 动态插入：当插入一个新键时，如果候选桶中没有足够的空间，Cuckoo Hashing会通过一系列置换操作来为新键腾出空间。这涉及到将现有的指纹移动到它们的替代位置，从而为新键腾出空间。已占用位置的元素会被移动到其它哈希函数确定的位置，可能导致一个连锁的重新放置过程。这个算法的名字来源于布谷鸟，因为布谷鸟会将自己的蛋放入其他鸟类的巢中，迫使其他鸟类的蛋被移位或丢弃。 查找操作：给定一个键，Cuckoo Hashing通过检查两个候选桶中的指纹来确定键是否存在于表中。如果任一桶中存在匹配的指纹，则认为键存在于表中。 删除操作：删除操作相对简单，Cuckoo Hashing检查两个候选桶，如果找到匹配的指纹，则移除该指纹。这种删除方法不会影响其他键的存储位置。 高空间效率：Cuckoo Hashing通过存储指纹而不是完整的键来优化空间使用，同时保持较高的表占用率，从而实现高空间效率。 6.1 fingerprint“fingerprint”是存储在Cuckoo Filter中的数据。，一个哈希函数处理数据后得到的哈希串。 6.2 Partial-Key Cuckoo HashingA cuckoo filter is a compact variant of a cuckoo hash table that stores only fingerprints-a bit string derived from the item using a hash function。 在cuckoo filter 中，哈希表中存储的数据发生了变化，由原始数据变成了fingerprint。注意这里的（basic/standard） cuckoo hash tables指的是存储原始数据的做法。 partial-key cuckoo hashing 是一种仅使用指纹，而不需要原始数据就可以在置换操作中来确定元素存储位置的哈希技术。由于仅存储fingerprint 比存储原始数据所占内存空间小，所以 Partial-Key Cuckoo Hashing为优化Cuckoo Filter的空间效率和操作性能而设计。 如上代码所示，Partial-Key Cuckoo Hashing使用两个哈希函数 h1 和 h2 来计算两个候选桶位置。第一个哈希函数 h1 直接作用于元素的指纹，而第二个哈希函数 h2 则是 h1 与指纹的哈希值的异或（XOR）结果。这种XOR的处理结果 可以根据其中任意一个已知的候选桶位置（i）计算出另外一个候选桶位置（j）j = i XOR fingerprint 6.3 Insert cuckoo 哈希的插入过程： 计算元素的指纹。 确定两个候选桶位置 i1 和 i2。 如果 i1 或 i2 有空闲条目，则将指纹插入到该条目中。 如果两个桶都满，则选择一个桶，随机选择一个条目并将其指纹与新元素的指纹交换。 Partial-Key Cuckoo Hashing ，更新候选桶位置 i 为 i XOR 指纹的哈希值。 如果找到空闲条目，则插入指纹；否则继续置换过程，直到找到空闲条目或达到最大置换次数。 6.4 Lookup 6.5 Delete 为什么cuckoo filter 可以删除元素但是又不影响其他元素的判断， 其实就是每个entry 只存储了一个元素的信息，删除后自然不会影响其他元素的判断。 6.6 空间优化Cuckoo Filter进行空间优化（SPACE OPTIMIZATIONS）的方法主要涉及对哈希表参数的选择和配置，以及对桶（buckets）的编码策略。以下是论文中提到的一些关键的空间优化策略： 选择合适的桶大小（Bucket Size）： 桶大小（b）对Cuckoo Filter的空间效率有显著影响。较大的桶可以提高哈希表的占用率（α），但同时也需要更长的指纹来维持相同的误报率。 论文中通过实验确定了对于不同的目标误报率（ϵ），最优的桶大小是不同的。例如，当误报率大于0.002时，每个桶有2个条目可能比4个条目更有效；而当误报率降低到0.00001至0.002时，每个桶有4个条目可以最小化空间使用。 半排序桶编码（Semi-Sorting Buckets）： 对于每个桶中的指纹进行排序，然后使用一个预先计算好的表来编码这些排序后的指纹序列。由于桶内指纹的顺序不影响查询结果，这种方法可以通过索引来节省空间。 例如，如果每个桶有4个指纹，每个指纹是4比特长，那么未压缩的桶将占用16比特。通过排序和编码，可以使用一个12比特的索引来代替原来的16比特桶，因为可以预先计算出所有可能的桶值（例如，3876种），并将每个桶表示为一个索引，从而节省1比特每个指纹。 平衡桶的负载（Balancing Bucket Loads）： 通过合理配置哈希函数和桶大小，可以减少哈希表中的冲突和空桶，从而提高空间利用率。 论文中提到，通过适当的配置，Cuckoo Filter可以以高概率达到95%的表空间占用率。 指纹长度的优化： 指纹长度（f）与桶大小和目标误报率有关。通过调整指纹长度，可以在保持目标误报率的同时，优化空间使用。 论文中的分析表明，对于实际应用中的集合大小，较短的指纹（例如6比特或更长）通常足以确保哈希表的高利用率。 通过这些空间优化策略，Cuckoo Filter能够在保持高效动态操作的同时，实现紧凑的数据存储。这些优化使得Cuckoo Filter在很多实际应用中比传统的Bloom Filter和Counting Bloom Filter更加空间高效 6.7 Redis cuckoo filterredis 实现了 cuckoo filter ，基本实现逻辑和论文中表现一致，有兴趣大家可以自己去看一下 7. 自己如何实现一个布隆过滤器基于以上对3种bloom filter的分析，可以总结出自己实现bloom filter时需要考虑的因素本项目代码可点击这里查看 7.1 位数组的实现首先参考BitSet。BitSet类是Java标准库中提供的一个用于处理位数组的类，基本可以认为是bitmap 在Java 的中的实现，其原理是是long[] 数组+ 位操作。在自己实现布隆过滤器时，可以直接使用BitSet ， 也可以像guava cache 一样，自己用long[] + 位操作自己封装一个bitarray，而不是直接使用的BitSet。 7.2 位数组的大小在简单的自己实现的版本中，可以直接指定bitarray 大小。 但在实际线上生产环境中可用的bloom filter 实现，一般都是根据预期插入的数据量 和 可接受的误报率两个数字通过 一个数学公式算出的，而不是直接用预期插入的数据量。 同时我们在线上生产环境使用布隆过滤器时，根据业务特性和流量去估算预期插入的数据量 和衡量 可接受的误报率 也是非常重要的步骤。 如果估算数据量比实际值大很多，就会浪费内存空间。如果估算数据量比实际值小很多，那么误报率很可能就无法控制在可接受的范围内。 guava cache bloom filter 位数组大小一旦确定时无法修改的，所以实际数据量如果过大，那么误报率肯定会上升 redis bloom filter 位数组大小可以scale, 但是判断元素是否存在的这个步骤性能会受到影响 7.3 用哪个哈希函数这个哈希函数在密码学中叫做单向散列函数。单向散列函数有两类加密与非加密散列，其主要区别如下。 7.3.1 加密散列函数设计用于加密应用，强调安全性。它们需要具备一定的性质，如抗碰撞（两个不同的输入不应该产生同一个输出）、隐藏性（无法从输出推断任何信息关于输入）和抗篡改（对输入的微小变化会在输出中产生不可预测的、大的变化）。 SHA家族（SHA-1、SHA-256、SHA-512等）：安全哈希算法（Secure Hash Algorithm）家族，广泛用于加密、数据完整性校验和数字签名等安全相关的应用。 MD5：消息摘要算法5（Message Digest Algorithm 5），尽管因为安全性问题不再推荐用于加密安全领域，但在一些非安全性要求的场合仍然可以见到其身影。 RIPEMD：一系列的加密哈希函数，包括RIPEMD-160、RIPEMD-256和RIPEMD-320，其中RIPEMD-160设计用于替代MD5和SHA-1。-7.3.2 非加密散列函数设计重点是高效率和均匀分布的输出，以支持快速数据检索、数据分布平衡等，而不是安全性。在某些情况下，允许存在碰撞，但碰撞的概率要尽可能低。 常见的非加密单向散列函数： MurmurHash：由Austin Appleby设计，因其高性能和良好的分布特性而广泛应用。MurmurHash有多个版本，如MurmurHash2、MurmurHash3等。 CityHash：由Google开发，专为哈希字符串数据设计，适用于构建哈希表等数据结构。后续Google又推出了FarmHash，作为CityHash的改进版，提供更好的性能和更广的适用范围。 xxHash：是一种非常快的哈希算法，提供了极高的数据处理速度，同时保持了良好的散列分布特性，适用于需要快速散列大量数据的场景。 Jenkins哈希函数（如一致性哈希）：Bob Jenkins所设计的一系列哈希函数，包括lookup3、SpookyHash等，它们广泛用于软件开发中，特别是在需要快速且分布均匀的哈希算法的场合。 FNV（Fowler-Noll-Vo）：是一系列设计简单、性能良好的哈希函数，特别适合于散列单个文本字符串。FNV-1和FNV-1a是两个最著名的变种。 在以上分析原理分析中，guava cache和Redis 都是用了MurmurHash如果我们自己也想要用MurmurHash，目前Java并没有提供实现，可以引入guava cache 包使用MurmurHash。 7.4 用多少个哈希函数前面说过用多个哈希函数可以减少误报率，那么到底要用多少个哈希函数呢， 这也是可以通过 预期插入的数据量+ 可接受的误报率 通过固定的数学公式计算得出。同时多个哈希结果可以通过像Guava cache一样，用双哈希技术模拟得到。","tags":["Programming"]}]