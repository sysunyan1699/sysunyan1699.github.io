<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sun Yan</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2024-10-26T01:55:02.904Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Sun Yan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SafeInventory-分布式事务下，如何安全操作库存</title>
    <link href="http://example.com/a5120d74/"/>
    <id>http://example.com/a5120d74/</id>
    <published>2024-10-23T15:20:34.000Z</published>
    <updated>2024-10-26T01:55:02.904Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://sunyan.xyz/ca1e509/">SafeInventory-分布式事务下，如何安全操作库存</a>，一文中已经详细说明在本地事务下如何安全操作库存。</p><p>本文将继续讨论在分布式事务下， 如何安全操作库存。</p><p>在购物场景下，库存扣减是一个典型的<strong>分布式事务</strong>，通常涉及三个系统：<strong>订单系统</strong>、<strong>库存系统</strong>和<strong>支付系统</strong>。其交互流程如下：</p><ol><li><p><strong>订单系统请求扣减库存</strong>：在用户下单时，订单系统首先向库存系统请求扣减库存，只有在确认有足够库存的情况下，订单才会创建成功。</p></li><li><p><strong>等待支付结果</strong>：订单创建成功后，用户进入支付流程。此时，库存系统暂时将库存“冻结”，等待支付系统的支付结果。</p></li><li><strong>支付成功或失败的处理</strong>：<ul><li>如果支付成功，库存系统确认并真正扣减库存并 生成对应用户券。</li><li>如果支付失败或超时，库存系统需要将预扣的库存恢复，确保库存不被不必要地扣减。</li></ul></li></ol><p>在分布式事务下，<strong>保证库存不超发</strong>的方式与本地事务相同，仍然可以使用库存条件控制、乐观锁、悲观锁、分布式锁机制。</p><p>然而，在分布式事务中，库存扣减与业务操作的原子性不再能通过数据库事务天然保证。</p><p>库存的实际扣减与用户的支付结果密切相关，需要根据支付成功或失败来决定是否真正扣减库存。</p><ol><li><p>在用户下单时，暂时冻结库存。</p></li><li><p>等到支付成功后，再真正扣减库存；如果支付失败，则释放预扣库存。</p></li></ol><p>这种方案叫做<strong>预扣库存，</strong>确保了库存扣减与支付流程的原子性，这是一个典型的<strong>两阶段提交（2PC）</strong></p><p>项目完整代码，<a href="https://github.com/sysunyan1699/SafeInventory">点击 github-SafeInventory查看</a></p><h1 id="1-预扣库存"><a href="#1-预扣库存" class="headerlink" title="1 预扣库存"></a>1 预扣库存</h1><p>预扣库存方案， 需要增加一个流水表记录每个不重复的请求 需要扣减的数量。</p><p>同时极其重要的一点就是 库存表和流水表 需要在一个数据中， 通过数据库事务保证库存扣减和流水数据插入的原子性</p><h2 id="11-表设计"><a href="#1-1-表设计" class="headerlink" title="1.1 表设计"></a>1.1 表设计</h2><h3 id="111-库存表inventory"><a href="#1-1-1-库存表：inventory" class="headerlink" title="1.1.1 库存表：inventory"></a>1.1.1 库存表：<code>inventory</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> inventory (</span><br><span class="line">    id <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    product_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    total_stock <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;总库存,固定不变&#x27;</span>,</span><br><span class="line">    available_stock <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;当前可用库存，总库存减去了实际已经使用的库存&#x27;</span>,</span><br><span class="line">    reserved_stock <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;预扣库存&#x27;</span>,</span><br><span class="line">    create_time DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    update_time DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    version <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;数据版本号，用作乐观锁控制&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `idx_product_id` (`product_id`),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><strong><code>total_stock</code></strong>：表示券模板配置的总库存，固定不变。</li><li><strong><code>available_stock</code></strong>：当前实际可用的库存数量，减去了实际已经使用和已预扣的库存。</li><li><strong><code>reserved_stock</code></strong>：当前已预扣但尚未确认的库存数量。</li></ul><p>在这种设计下，<strong>当前实际已使用的库存</strong>可以表示为：</p><p>used_stock=total_stock − available_stock − reserved_stock</p><h3 id="112-明细表流水表inventory_reservation_log"><a href="#1-1-2-明细表-流水表：inventory-reservation-log" class="headerlink" title="1.1.2 明细表/流水表：inventory_reservation_log"></a>1.1.2 明细表/流水表：<code>inventory_reservation_log</code></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> inventory_reservation_log (</span><br><span class="line">    id <span class="type">bigint</span> unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    request_id <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;请求唯一标识&#x27;</span>,</span><br><span class="line">    product_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    reservation_quantity <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;本次预扣库存数量&#x27;</span>,</span><br><span class="line">    status <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">1</span> COMMENT <span class="string">&#x27;消息状态 1-pending 2-confirmed 3-rollback 4-unknown&#x27;</span>,</span><br><span class="line">    verify_try_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;状态回查 当前重试次数&#x27;</span>,</span><br><span class="line">    create_time DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    update_time DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">    version <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;数据版本号，用作乐观锁控制&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX idx_request_id (request_id),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><code>request_id</code> 是每次预扣操作的唯一标识符， 在商品购买场景下就是订单id，可以用来追踪每次库存预扣的详细信息。</li><li><code>status</code> 字段用于标记库存预扣的状态，分别为 <code>1-PENDING（预扣中）</code>、<code>2-CONFIRMED（已确认）</code>和 <code>3-CANCELLED（已取消）</code>。</li><li><code>verify_try_count</code> 通过异步定时任务保证数据的一致性,记录被定时任务扫描确定 status 的次数。</li></ul><h2 id="12-方案流程"><a href="#1-2-方案流程" class="headerlink" title="1.2 方案流程"></a>1.2 方案流程</h2><p>库存表和流水表 需要在一个数据中， 通过数据库事务保证库存扣减和流水数据插入的原子性。</p><h3 id="121-本地事务-预扣库存"><a href="#1-2-1-本地事务-预扣库存" class="headerlink" title="1.2.1 本地事务 预扣库存"></a>1.2.1 本地事务 预扣库存</h3><p>以下sql 先只表示流程，不代表具体实际方案， 因为没有把控制并发不超卖的4种方案一一具体写下来。</p><p>预扣操作在 <code>inventory</code> 表中减少 <code>available_stock</code>，并增加 <code>reserved_stock</code>，同时在 <code>inventory_reservation_log</code> 表中插入一条状态为 <code>PENDING</code> 的预扣记录。</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">-- 先检查库存是否足够</span></span><br><span class="line">        <span class="keyword">SELECT</span> id,</span><br><span class="line">               product_id <span class="keyword">AS</span> productId,</span><br><span class="line">               total_stock,</span><br><span class="line">               available_stock,</span><br><span class="line">               reserved_stock,</span><br><span class="line">               version,</span><br><span class="line">               create_time,</span><br><span class="line">               update_time</span><br><span class="line">        <span class="keyword">FROM</span> inventory</span><br><span class="line">        <span class="keyword">WHERE</span> product_id <span class="operator">=</span> #&#123;productId&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果库存足够，则执行预扣操作</span></span><br><span class="line">        <span class="keyword">UPDATE</span> inventory</span><br><span class="line">        <span class="keyword">SET</span> available_stock <span class="operator">=</span> available_stock <span class="operator">-</span> #&#123;quantity&#125;,</span><br><span class="line">            reserved_stock  <span class="operator">=</span> reserved_stock <span class="operator">+</span> #&#123;quantity&#125;,</span><br><span class="line">            version         <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">WHERE</span> product_id <span class="operator">=</span> #&#123;productId&#125;</span><br><span class="line">          <span class="keyword">AND</span> version <span class="operator">=</span> #&#123;version&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 记录预扣明细</span></span><br><span class="line">        <span class="keyword">INSERT</span> <span class="keyword">INTO</span> inventory_reservation_log (request_id,</span><br><span class="line">                                               product_id,</span><br><span class="line">                                               reservation_quantity,</span><br><span class="line">                                               status)</span><br><span class="line">        <span class="keyword">VALUES</span> (#&#123;requestId&#125;,</span><br><span class="line">                #&#123;productId&#125;,</span><br><span class="line">                #&#123;reservationQuantity&#125;,</span><br><span class="line">                #&#123;status&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="122-本地事务-确认扣减"><a href="#1-2-2-本地事务-确认扣减" class="headerlink" title="1.2.2 本地事务 确认扣减"></a>1.2.2 本地事务 确认扣减</h3><p>在确认阶段，将预扣的库存从 <code>reserved_stock</code> 扣减，并标记 <code>inventory_reservation_log</code> 表中的记录为 <code>CONFIRMED</code>。此时，<code>available_stock</code> 不发生变化，因为实际可用库存已经在预扣阶段调整。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新预扣记录状态</span></span><br><span class="line">       <span class="keyword">UPDATE</span> inventory_reservation_log</span><br><span class="line">        <span class="keyword">SET</span> status  <span class="operator">=</span> #&#123;status&#125;,</span><br><span class="line">            version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">WHERE</span> request_id <span class="operator">=</span> #&#123;requestId&#125;</span><br><span class="line">          <span class="keyword">AND</span> version <span class="operator">=</span> #&#123;version&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 更新库存表</span></span><br><span class="line">     <span class="keyword">UPDATE</span> inventory</span><br><span class="line">        <span class="keyword">SET</span> reserved_stock <span class="operator">=</span> reserved_stock <span class="operator">-</span> #&#123;reservedStock&#125;,</span><br><span class="line">            version         <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">WHERE</span> product_id <span class="operator">=</span> #&#123;productId&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="123-本地事务-回滚预扣"><a href="#1-2-3-本地事务-回滚预扣" class="headerlink" title="1.2.3 本地事务 回滚预扣"></a>1.2.3 本地事务 回滚预扣</h3><p>如果预扣的库存在后续操作中失败或超时，需要将 <code>reserved_stock</code> 返还到 <code>available_stock</code> 中，并将 <code>inventory_reservation——log</code> 表中的状态更新为 <code>CANCELLED</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 更新预扣记录状态为已取消</span></span><br><span class="line">       <span class="keyword">UPDATE</span> inventory_reservation_log</span><br><span class="line">        <span class="keyword">SET</span> status  <span class="operator">=</span> #&#123;status&#125;,</span><br><span class="line">            version <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">WHERE</span> request_id <span class="operator">=</span> #&#123;requestId&#125;</span><br><span class="line">          <span class="keyword">AND</span> version <span class="operator">=</span> #&#123;version&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取消预扣库存</span></span><br><span class="line">        <span class="keyword">UPDATE</span> inventory</span><br><span class="line">        <span class="keyword">SET</span> reserved_stock  <span class="operator">=</span> reserved_stock <span class="operator">-</span> #&#123;reservedStock&#125;,</span><br><span class="line">            available_stock <span class="operator">=</span> available_stock <span class="operator">+</span> #&#123;reservedStock&#125;,</span><br><span class="line">            version         <span class="operator">=</span> version <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">WHERE</span> product_id <span class="operator">=</span> #&#123;productId&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于分布式事务分为单服务多数据库 和 多服务多数据库 2种，接下来将分开讨论</p><h1 id="2-多服务多数据库分布式事务-tcc"><a href="#2-多服务多数据库分布式事务-TCC" class="headerlink" title="2 多服务多数据库分布式事务-TCC"></a>2 多服务多数据库分布式事务-TCC</h1><p><strong>商品购买场景中的分布式事务</strong>可以视为典型的<strong>多数据库、多数据源的分布式事务</strong>。</p><p>在处理这种分布式事务时，常用的方案是<strong>TCC</strong>模式，即<strong>Try、Confirm、Cancel</strong>。</p><p>TCC 本质上就是两阶段提交（2PC）类似，但它更具业务属性，更加灵活。与商品购买库存扣减业务逻辑结合的 TCC 模式步骤如下：</p><ol><li><strong>Try</strong>：执行资源预留操作，在这里对应的是<strong>预扣库存</strong>，即暂时冻结库存以等待支付结果。</li><li><strong>Confirm</strong>：在支付成功后，执行<strong>确认扣减库存</strong>的操作。</li><li><strong>Cancel</strong>：如果支付失败或超时，执行<strong>回滚预扣库存</strong>，将冻结的库存释放。</li></ol><h2 id="21-try-预扣库存"><a href="#2-1-Try-预扣库存" class="headerlink" title="2.1 Try - 预扣库存"></a>2.1 Try - 预扣库存</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> public class InventoryService &#123;   </span><br><span class="line">    public <span class="type">boolean</span> reserveInventory(<span class="type">Integer</span> productId, <span class="type">Integer</span> quantity, String requestId) &#123;</span><br><span class="line">        String lockKey <span class="operator">=</span> LOCK_KEY_PREFIX <span class="operator">+</span> productId;</span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span> 模拟获取redis 分布式锁逻辑</span><br><span class="line">        <span class="type">boolean</span> lockAcquired <span class="operator">=</span> redisDistributedLock.acquireLock(lockKey, requestId, EXPIRE_TIME);</span><br><span class="line">        if (<span class="operator">!</span>lockAcquired) &#123;</span><br><span class="line">            logger.info(&quot;未获取到锁 productId: &#123;&#125;, quantity: &#123;&#125;, requestId:&#123;&#125;&quot;, productId, quantity, requestId);</span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span> 获取锁失败，返回或重试</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            <span class="keyword">return</span> inventoryInternalService.reserveInventory(productId, quantity, requestId);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            <span class="operator">/</span><span class="operator">/</span> 如果释放失败则重试或者等待过期</span><br><span class="line">            if (lockAcquired) &#123;</span><br><span class="line">                redisDistributedLock.releaseLock(lockKey, requestId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class InventoryInternalService &#123;</span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> TCC<span class="operator">-</span>try</span><br><span class="line">    <span class="variable">@Transactional</span></span><br><span class="line">    public <span class="type">boolean</span> reserveInventory(<span class="type">Integer</span> productId, <span class="type">Integer</span> quantity, String requestId) &#123;</span><br><span class="line">        InventoryModel inventory <span class="operator">=</span> inventoryMapper.selectByProductId(productId);</span><br><span class="line">        if (inventory.getAvailableStock() <span class="operator">&lt;</span> quantity) &#123;</span><br><span class="line">            logger.warn(&quot;库存不足: productId=&#123;&#125;, requestedQuantity=&#123;&#125;, availableStock=&#123;&#125;&quot;,</span><br><span class="line">                    productId, quantity, inventory.getAvailableStock());</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span>  流水表插入</span><br><span class="line">        InventoryReservationLogModel model <span class="operator">=</span> <span class="keyword">new</span> InventoryReservationLogModel();</span><br><span class="line">        model.setProductId(productId);</span><br><span class="line">        model.setReservationQuantity(quantity);</span><br><span class="line">        model.setRequestId(requestId);</span><br><span class="line">        model.setStatus(ReservationStatus.PENDING.getValue());</span><br><span class="line">        inventoryReservationLogMapper.insertInventoryReservationLog(model);</span><br><span class="line"></span><br><span class="line">        <span class="operator">/</span><span class="operator">/</span> 库存扣减</span><br><span class="line">        <span class="type">int</span> updatedRows <span class="operator">=</span> inventoryMapper.reserveStockWithVersion(productId, quantity, inventory.getVersion());</span><br><span class="line"></span><br><span class="line">        if (updatedRows <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(&quot;库存扣减失败 productId: &#123;&#125;, quantity: &#123;&#125;, requestId:&#123;&#125;&quot;, productId, quantity, requestId);</span><br><span class="line">            throw <span class="keyword">new</span> RuntimeException(&quot;库存扣减失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="211-先插入流水记录-幂等性保证"><a href="#2-1-1-先插入流水记录-幂等性保证" class="headerlink" title="2.1.1 先插入流水记录-幂等性保证"></a>2.1.1 先插入流水记录-幂等性保证</h3><p>流水表中唯一索引索引字段可以用作幂等性的保证， 具体方案可见 <a href="https://sunyan.xyz/c3915fbe/">如何处理重复请求保证幂等</a>。</p><h3 id="212-扣减库存"><a href="#2-1-2-扣减库存" class="headerlink" title="2.1.2 扣减库存"></a>2.1.2 扣减库存</h3><p>使用<a href="https://sunyan.xyz/ca1e509/">SafeInventory-分布式事务下，如何安全操作库存</a>中提到的4种方案，保证库存扣减逻辑在并发请求下的安全操作。</p><p>示例代码使用Redis 分布式锁保证库存不超卖。</p><h3 id="213-本地事务保证原子操作"><a href="#2-1-3-本地事务保证原子操作" class="headerlink" title="2.1.3 本地事务保证原子操作"></a>2.1.3 本地事务保证原子操作</h3><p>本地事务保证库存表变更和流水表插入的原子操作，如果库存表变更失败，则事务回滚。</p><h2 id="22-confirm-确认扣减库存"><a href="#2-2-Confirm-确认扣减库存" class="headerlink" title="2.2 Confirm- 确认扣减库存"></a>2.2 Confirm- 确认扣减库存</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">boolean</span> confirmReservedInventory(<span class="type">Integer</span> productId, String requestId) &#123;</span><br><span class="line">    InventoryReservationLogModel model <span class="operator">=</span> inventoryReservationLogMapper.selectByRequestId(requestId);</span><br><span class="line">    if (model.getStatus() <span class="operator">!=</span> ReservationStatus.PENDING.getValue()) &#123;</span><br><span class="line">        logger.warn(&quot;status is not pending ,can not confirm the reserved stock, requestId:&#123;&#125;&quot;, requestId);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> inventoryInternalService.confirmReservedInventory(productId,</span><br><span class="line">            requestId,</span><br><span class="line">            model.getVersion(),</span><br><span class="line">            model.getReservationQuantity());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable">@Transactional</span></span><br><span class="line">public <span class="type">boolean</span> confirmReservedInventory(<span class="type">Integer</span> productId, String requestId, <span class="type">Integer</span> version ,<span class="type">Integer</span> reservationQuantity) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="operator">/</span><span class="operator">/</span> 指定原始status 做乐观锁</span><br><span class="line">    <span class="type">int</span> updateResult <span class="operator">=</span> inventoryReservationLogMapper.updateStatus(</span><br><span class="line">            requestId,</span><br><span class="line">            ReservationStatus.CONFIRMED.getValue(),</span><br><span class="line">            version);</span><br><span class="line"></span><br><span class="line">    if (updateResult <span class="operator">!=</span> <span class="number">1</span>) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> RuntimeException(&quot;流水状态更新失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> rollbackResult <span class="operator">=</span> inventoryMapper.confirmStock(productId, reservationQuantity);</span><br><span class="line"></span><br><span class="line">    if (rollbackResult <span class="operator">!=</span> <span class="number">1</span>) &#123;</span><br><span class="line">        throw <span class="keyword">new</span> RuntimeException(&quot;库存回滚失败&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="221-本地事务保证原子操作"><a href="#2-2-1-本地事务保证原子操作" class="headerlink" title="2.2.1 本地事务保证原子操作"></a>2.2.1 本地事务保证原子操作</h3><p>本地事务保证库存表变更和流水表变更的原子操作，如果部分失败，则事务回滚。</p><h3 id="222-变更的并发操作"><a href="#2-2-2-变更的并发操作" class="headerlink" title="2.2.2 变更的并发操作"></a>2.2.2 变更的并发操作</h3><p>使用版本号字段，保证状态流转的正确以及防止数据覆盖</p><h2 id="23-cancel-回滚预扣库存"><a href="#2-3-Cancel-回滚预扣库存" class="headerlink" title="2.3 Cancel - 回滚预扣库存"></a>2.3 Cancel - 回滚预扣库存</h2> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Transactional</span></span><br><span class="line"> public <span class="type">boolean</span> rollbackReservedInventory(<span class="type">Integer</span> productId, String requestId) &#123;</span><br><span class="line"></span><br><span class="line">     InventoryReservationLogModel model <span class="operator">=</span> inventoryReservationLogMapper.selectByRequestId(requestId);</span><br><span class="line">     if (model.getStatus() <span class="operator">!=</span> ReservationStatus.PENDING.getValue()) &#123;</span><br><span class="line">         logger.warn(&quot;rollbackReservedInventory is not pending ,can not rollback the reserved stock&quot;);</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="operator">/</span><span class="operator">/</span> 指定原始status 做乐观锁</span><br><span class="line">     <span class="type">int</span> updateResult <span class="operator">=</span> inventoryReservationLogMapper.updateStatus(</span><br><span class="line">             requestId,</span><br><span class="line">             ReservationStatus.ROLLBACK.getValue(),</span><br><span class="line">             model.getVersion());</span><br><span class="line"></span><br><span class="line">     if (updateResult <span class="operator">!=</span> <span class="number">1</span>) &#123;</span><br><span class="line">         throw <span class="keyword">new</span> RuntimeException(&quot;流水状态更新失败&quot;);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> rollbackResult <span class="operator">=</span> inventoryMapper.rollbackStock(productId, model.getReservationQuantity());</span><br><span class="line"></span><br><span class="line">     if (rollbackResult <span class="operator">!=</span> <span class="number">1</span>) &#123;</span><br><span class="line">         throw <span class="keyword">new</span> RuntimeException(&quot;库存回滚失败&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="231-库存回滚的2种场景"><a href="#2-3-1-库存回滚的2种场景" class="headerlink" title="2.3.1 库存回滚的2种场景"></a>2.3.1 库存回滚的2种场景</h3><h4 id="订单超时取消"><a href="#订单超时取消" class="headerlink" title="订单超时取消"></a>订单超时取消</h4><ol><li>监听订单的消息队列，针对状态是cancle 的订单， 找到流水表中预扣记录，执行库存回滚逻辑</li><li>定时任务每隔固定时间扫描一次流水表， 找出pendding 状态的流水记录，执行库存回滚逻辑</li></ol><h4 id="支付失败调用cancel-接口"><a href="#支付失败调用cancel-接口" class="headerlink" title="支付失败调用cancel 接口"></a>支付失败调用cancel 接口</h4><h3 id="232-本地事务保证原子操作"><a href="#2-3-2-本地事务保证原子操作" class="headerlink" title="2.3.2 本地事务保证原子操作"></a>2.3.2 本地事务保证原子操作</h3><p>本地事务保证库存表变更和流水表变更的原子操作，如果部分失败，则事务回滚</p><h3 id="233-变更的并发操作"><a href="#2-3-3-变更的并发操作" class="headerlink" title="2.3.3 变更的并发操作"></a>2.3.3 变更的并发操作</h3><p>使用版本号字段，保证状态流转的正确以及防止数据覆盖</p><h1 id="3-单服务多数据库分布式事务-confirm-阶段加入业务操作"><a href="#3-单服务多数据库分布式事务-Confirm-阶段加入业务操作" class="headerlink" title="3 单服务多数据库分布式事务-Confirm 阶段加入业务操作"></a>3 单服务多数据库分布式事务-Confirm 阶段加入业务操作</h1><p>以上介绍的库存预扣流程，各阶段只涉及库存表和和流水表的操作，可以使用本地事务保证操作的原子性。</p><p>但是如果各阶段加入业务操作，就要考虑库存操作（包括库存表和流水表 2张表的操作）和业务操作之间的原子性。</p><p>以 购买券包场景为例，它需要在在confirm 阶段 ，生成对应的用户券。</p><p>如果用户券表和库存表、流水表在同一个数据库， 那么用户券的生成 和 库存表、流水表 的变更 可以继续通过数据库事务保持原子性， 从而保证库存数据与用户券的一致性。</p><p>如果用户券分库分表， 和库存表、流水表不在同一个数据库，那么用户券的生成 和 库存操作就变成了一个 <strong>单服务多数据库的分布式事务</strong>，无法通过数据库事务保持原子性。</p><p>需要根据用户券插入结果决定库存是否真正扣减，这也是一个典型的<strong>两阶段提交（2PC）</strong>。</p><p>此时如何保证内部数据一致性 和 整体数据一致性需要重点考虑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">confirmReservedInventoryWithBusinessLogic</span><span class="params">(Integer productId, String requestId)</span> &#123;</span><br><span class="line">       <span class="type">InventoryReservationLogModel</span> <span class="variable">model</span> <span class="operator">=</span> inventoryReservationLogMapper.selectByRequestId(requestId);</span><br><span class="line">       <span class="keyword">if</span> (model.getStatus() != ReservationStatus.PENDING.getValue()) &#123;</span><br><span class="line">           logger.warn(<span class="string">&quot;status is not pending ,can not confirm the reserved stock, requestId:&#123;&#125;&quot;</span>, requestId);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//先插入业务数据</span></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">businessResult</span> <span class="operator">=</span> businessService.createBusinessDate();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (!businessResult) &#123;</span><br><span class="line">           logger.warn(<span class="string">&quot;业务逻辑执行失败，requestId:&#123;&#125;，productId:&#123;&#125; &quot;</span>, requestId, productId);</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="type">boolean</span> <span class="variable">confirmResult</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           confirmResult = inventoryInternalService.confirmReservedInventory(productId,</span><br><span class="line">                   requestId,</span><br><span class="line">                   model.getVersion(),</span><br><span class="line">                   model.getReservationQuantity());</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           logger.warn(<span class="string">&quot;业务逻辑执行失败，requestId:&#123;&#125;，productId:&#123;&#125;, error:&#123;&#125;&quot;</span>, requestId, productId, e);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> confirmResult;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="31-先生成用户券再确认扣减库存"><a href="#3-1-先生成用户券，再确认扣减库存" class="headerlink" title="3.1 先生成用户券，再确认扣减库存"></a>3.1 先生成用户券，再确认扣减库存</h2><p>如果库存服务在confirm 接口中，除了扣减库存，还要生成对应用户数据，比如购买券包，用户支付成功后，就应该先生成用户券，再执行库存数据库变更。</p><p>为什么要先生成用户券数据在扣减库存，我们希望 在流水表中的状态一旦是confirm 或者 cancle 就完全是确定不再需要考虑的状态， 如果先扣库存，就会导致cancel 、confirm 也不是确定的状态。</p><h2 id="32-如果库存变更失败如何处理-状态回查"><a href="#3-2-如果库存变更失败，如何处理-状态回查" class="headerlink" title="3.2 如果库存变更失败，如何处理-状态回查"></a>3.2 如果库存变更失败，如何处理-状态回查</h2><p>为了保持数据的最终一致性，有3种方案考虑</p><p>如果库存扣减失败， 此时有2个角度的数据一致性需要考虑</p><ol><li><p>内部数据一致性 ：即库存reserved_stock 与 流水表保持一致</p></li><li><p>整体数据一致性：即整体可用库存数量、订单能拿到的状态、用户能看到的券列表保持一致。</p></li></ol><p>如果此时用户券生成成功、但是库存变更失败，从整体流程上看，数据是一致性。只有内部数据不一致。可以采用状态回查方案保证reserved_stock 与 流水表 数据的最终一致性。</p><p>状态回查就是定期扫描流水表，找出X 分钟前创建但是状态 依然pending 的记录，查询对应的用户券数据，根据业务处理结果流转明细表状态。</p><h2 id="33-流水表不分库分表吗"><a href="#3-3-流水表不分库分表吗" class="headerlink" title="3.3 流水表不分库分表吗"></a>3.3 流水表不分库分表吗</h2><p>流水表记录用户的每个领券请求，其数据量理论上会与分库分表的用户券表的数据量接近，但在业务流程中，<strong>明细表一旦完成状态确认，其业务用途几乎不再重要</strong>。因此，可以通过定期归档这些历史数据来控制明细表的体量，确保流水表和库存表能够位于同一个数据库中，从而利用本地事务机制保证一致性。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://sunyan.xyz/ca1e509/&quot;&gt;SafeInventory-分布式事务下，如何安全操作库存&lt;/a&gt;，一文中已经详细说明在本地事务下如何安全操作库存。&lt;/p&gt;
&lt;p&gt;本文将继续讨论在分布式事务下， 如何安全操作库存。&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="系统设计" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>SafeInventory-本地事务下，如何安全操作库存</title>
    <link href="http://example.com/ca1e509/"/>
    <id>http://example.com/ca1e509/</id>
    <published>2024-10-16T13:26:30.000Z</published>
    <updated>2024-10-26T01:53:18.944Z</updated>
    
    <content type="html"><![CDATA[<p><strong>库存</strong>是许多业务场景中都会涉及的概念，比如购物场景中的商品库存，以及营销场景中的优惠券库存。不同的业务场景有各自的交互流程，后端设计也会随之不同。</p><ul><li><p><strong>购物场景</strong>：用户必须完成支付才能真正拥有商品。因此，库存的扣减需要与支付流程紧密结合，并与其他系统交互协调，确保在支付成功后才正式扣减库存。</p></li><li><p><strong>营销场景</strong>：用户通常只需点击领取按钮即可获得优惠券，而不需要支付。这种情况下，库存的扣减操作可以通过一个简单的接口完成，流程相对简单（支付购买券包则归为购物场景）。</p></li></ul><p>这两个典型场景在后端设计上有明显的差异，营销场景的发券流程更直接，而购物场景则需要处理更多的系统交互来确保库存的准确性。</p><p>不过在设计时均要考虑对库存操作的安全与高效。</p><p>项目完整代码，<a href="https://github.com/sysunyan1699/SafeInventory">点击 github-SafeInventory查看</a></p><h1 id="1-库存的安全操作"><a href="#1-库存的安全操作" class="headerlink" title="1 库存的安全操作"></a>1 库存的安全操作</h1><p>对库存的安全操作可以从以下2个角度理解</p><ol><li>不超卖/超发</li><li>不少发</li></ol><h2 id="11-不超发-并发"><a href="#1-1-不超发-并发" class="headerlink" title="1.1 不超发-并发"></a>1.1 不超发-并发</h2><p>在并发扣减库存时，如果设计不当， 就会出现商品超卖、库存超发问题。</p><p>确保库存不超卖、不超发在系统设计中是一个常见且难处理的问题。</p><p>“不超”的本质是要保证同一时刻只有一个线程在处理库存扣减操作，从而避免多线程或多进程并发操作导致的超发情况。那么常见的解决方案就是加锁， 锁可以是乐观锁、悲观锁、分布式锁</p><h2 id="12-不少发-库存回滚"><a href="#1-2-不少发-库存回滚" class="headerlink" title="1.2 不少发-库存回滚"></a>1.2 不少发-库存回滚</h2><p>“不少发”指的是，当业务操作未成功时，需要将扣减的库存加回去，避免库存凭空消失，导致实际发出的库存量小于设置的总库存，造成数据不一致。</p><p>为了防止这种情况，必须确保<strong>库存扣减操作</strong>和<strong>业务数据操作</strong>的<strong>原子性</strong>，即如果业务操作失败，已扣减的库存必须回滚。</p><p>在库存回滚时也要考虑并发问题，防止库存回滚加多了。</p><p>本文将从发券扣库存、购买商品扣库存2个业务场景， 分别讨论 在本地事务、 分布式事务下如何安全操作库存，  其中分布式事务又分为2种情况，单服务多数据库分布式事务， 多服务多数据库分布式事务</p><p>关于事务的分类及具体介绍， 可以点击阅读<a href="https://sunyan.xyz/5b064db6/">Intro to 事务</a></p><p>下面以发券场景为例，一段典型错误的库存操作代码出发， 分析在本地事务下如何安全操作库存。</p><p>本地事务指的是， 券库存表 和 用户券表在同一个数据库中。</p><h1 id="2-典型错误代码"><a href="#2-典型错误代码" class="headerlink" title="2. 典型错误代码"></a>2. 典型错误代码</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> inventory (</span><br><span class="line">    id <span class="type">BIGINT</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    product_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">UNIQUE</span> COMMENT <span class="string">&#x27;产品 ID，唯一标识&#x27;</span>,</span><br><span class="line">    total_stock <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;总库存，固定不变&#x27;</span>,</span><br><span class="line">    available_stock <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;当前可用库存，总库存减去了实际已经使用的库存&#x27;</span>,</span><br><span class="line">    create_time DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">    update_time DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> KEY `idx_product_id` (`product_id`),</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>基于此表， 代码按照以下流程进行处理<br><img src="/ca1e509/1.png" class></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotSafeInventoryService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(NotSafeInventoryService.class);</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InventoryMapper inventoryMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行不同业务场景下，具体的业务逻辑，商品售卖就是创建订单数据， 营销发券就是生成用户券数</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BusinessService businessService;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">reduceInventory</span><span class="params">(Integer productId, Integer quantity)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;productId: &#123;&#125;, quantity: &#123;&#125;&quot;</span>, productId, quantity);</span><br><span class="line">        <span class="type">InventoryModel</span> <span class="variable">inventoryModel</span> <span class="operator">=</span> inventoryMapper.selectByProductId(productId);</span><br><span class="line">        <span class="keyword">if</span> (inventoryModel.getAvailableStock() &lt; quantity) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 减库存, 并发有可能将库存扣减只小于0，  库存超卖超发</span></span><br><span class="line">       inventoryMapper.reduceAvailableStock(productId, quantity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行业务逻辑</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span>  <span class="operator">=</span> businessService.createBusinessDate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查业务数据是否插入成功</span></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;业务数据插入失败&quot;</span>);</span><br><span class="line">            <span class="comment">// 抛出异常以便事务回滚</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,</span><br><span class="line">    product_id,</span><br><span class="line">    total_stock,</span><br><span class="line">    available_stock,</span><br><span class="line">    version,</span><br><span class="line">    create_time,</span><br><span class="line">    update_time</span><br><span class="line"><span class="keyword">FROM</span> inventory</span><br><span class="line"><span class="keyword">WHERE</span> product_id <span class="operator">=</span> #&#123;productId&#125;        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">UPDATE</span> inventory</span><br><span class="line"><span class="keyword">SET</span> available_stock <span class="operator">=</span> available_stock <span class="operator">-</span> #&#123;quantity&#125;</span><br><span class="line"><span class="keyword">WHERE</span> product_id <span class="operator">=</span> #&#123;productId&#125;</span><br></pre></td></tr></table></figure><h2 id="21-并发操作下快照读引发的库存超卖超发"><a href="#2-1-并发操作下，快照读引发的库存超卖-超发" class="headerlink" title="2.1 并发操作下，快照读引发的库存超卖/超发"></a>2.1 并发操作下，快照读引发的库存超卖/超发</h2><p>通过快照读读取足够的库存， 在修改库存时，库存可能已经被其他事务修改， 不是最初查询到的那个库存了， 在并发情况下有可能将库存扣减至小于0， 导致超卖超发。</p><h2 id="22-库存扣减与业务操作不具有原子性-少发"><a href="#2-2-库存扣减与业务操作不具有原子性-少发" class="headerlink" title="2.2 库存扣减与业务操作不具有原子性-少发"></a>2.2 库存扣减与业务操作不具有原子性-少发</h2><p>reduceInventory 中如果业务代码执行失败， 没有库存回滚逻辑，会导致少发。</p><h1 id="3-用本地事务保证-库存回滚避免少发"><a href="#3-用本地事务保证-库存回滚，避免少发" class="headerlink" title="3  用本地事务保证 库存回滚，避免少发"></a>3  用本地事务保证 库存回滚，避免少发</h1><p>以上这段代码，因为没有任何代码保证库存表与业务表操作的原子性， 如果业务操作失败，已经扣减的库存是没有回滚 -把库存加回去的逻辑</p><p>如果库存表和业务表在同一个数据库中， 可以直接使用数据库的事务机制保证操作的原子性。</p><p>Spring 中提供的事务注解@Transactional ，是基于底层数据库本身的事务处理机制工作提供本地事务功能。</p><p>注意：@Transactional  无法保证 数据库操作和其他中间件操作如kafka操作具有原子性。<br>如果需要保证，可以点击阅读<a href="https://sunyan.xyz/99d433fa/">TrustMessage-基于2PC+MySQL+泛化调用实现的可靠消息中心</a></p><p>所以如果上述代码加上@Transactional ， 即可以保证业务操作失败时，库存正确回滚。</p><p>因此本文以下内容重点讨论在本地事务下已经保证库存回滚不少发的前提下，如何保证不超卖/超发。</p><p>保证并发时库存不被扣减至小于0 有2种思路</p><ul><li><strong>库存条件约束</strong><ul><li>在实际扣减时，只要保证库存扣减后不小于 0 即可。如果当前可用库存大于等于需要扣减的数量，则允许扣减，否则拒绝操作。</li></ul></li><li><strong>库存扣减基于查询时的库存一致性</strong>：<ul><li>实际扣减时必须保证库存还是查询时的那个库存， 如果不是，则不能执行库存扣减操作，避免超卖。</li><li>这种思路对应的就是加锁， 数据库乐观锁、数据库悲观锁、分布式锁</li></ul></li></ul><h1 id="4-库存条件约束"><a href="#4-库存条件约束" class="headerlink" title="4  库存条件约束"></a>4  库存条件约束</h1><p>此方法只需要在修改库存检查库存是否大于扣减数量即可 , 以此保证当前有足够的库存完成此次扣减操作。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> inventory <span class="keyword">SET</span> available_stock <span class="operator">=</span> available_stock <span class="operator">-</span> #&#123;quantity&#125; <span class="keyword">WHERE</span> product_id <span class="operator">=</span> #&#123;productId&#125; <span class="keyword">AND</span> available_stock <span class="operator">&gt;=</span> #&#123;quantity&#125;</span><br></pre></td></tr></table></figure></p><ol><li>MySQL InnoDB 引擎，在可重复读隔离级别下， update 会加行锁，保证针对同一行数据并发写的串行执行， 确保任意时刻只有一个请求修改库存</li><li>通过where 条件中添加available_stock &gt;= #{quantity} 这个库存约束条件，可以保证库存不会扣减至小于0 导致超卖超发</li><li>available_stock &gt;= #{quantity}  也可以是 available_stock - #{quantity} &gt;=0</li></ol><p>虽然通过库存约束条件可以保证不超发超卖，但是这种方案并不适合复杂业务场景，一致性差。</p><p>所以接下来重点讨论“实际扣减时必须保证库存还是查询时的那个库存， 如果不是，即使库存够也不能执行库存扣减操作”的解决方案。</p><p>常见的方案就是 加锁， 数据库乐观锁、数据库悲观锁、分布式锁</p><h1 id="3-乐观锁版本号"><a href="#3-乐观锁，版本号" class="headerlink" title="3. 乐观锁，版本号"></a>3. 乐观锁，版本号</h1><p>为库存记录增加一个 <code>version</code> 字段，每次扣减库存时，都要检查 <code>version</code> 字段是否与期望值一致。 并在成功操作后更新版本号。</p><h2 id="31-表设计"><a href="#3-1-表设计" class="headerlink" title="3.1 表设计"></a>3.1 表设计</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">version <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;数据版本号，用作乐观锁控制&#x27;</span>,</span><br></pre></td></tr></table></figure><p>每次扣减库存时，都要检查 <code>version</code> 字段是否与期望值一致。 并在成功操作后更新版本号。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE inventory <span class="type">SET</span> <span class="variable">available_stock</span> <span class="operator">=</span> available_stock - #&#123;quantity&#125;,version = version + <span class="number">1</span></span><br><span class="line"><span class="type">WHERE</span> <span class="variable">product_id</span> <span class="operator">=</span> #&#123;productId&#125; <span class="type">AND</span> <span class="variable">version</span> <span class="operator">=</span> #&#123;version&#125;</span><br></pre></td></tr></table></figure></p><h2 id="32-处理流程"><a href="#3-2-处理流程" class="headerlink" title="3.2 处理流程"></a>3.2 处理流程</h2><p>整理处理流程不变如下， 只是在扣减库存时的sql 语句上发生了变化<br><img src="/ca1e509/2.png" class></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryWithVersionService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(InventoryWithVersionService.class);</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> InventoryMapper inventoryMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行不同业务场景下，具体的业务逻辑，商品售卖就是创建订单数据， 营销发券就是生成用户券数</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BusinessService businessService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">reduceInventory</span><span class="params">(Integer productId, Integer quantity)</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;reduceInventory productId: &#123;&#125;, quantity: &#123;&#125;&quot;</span>, productId, quantity);</span><br><span class="line"></span><br><span class="line">        <span class="type">InventoryModel</span> <span class="variable">inventory</span> <span class="operator">=</span> inventoryMapper.selectByProductId(productId);</span><br><span class="line">        <span class="keyword">if</span> (inventory.getAvailableStock() &lt; quantity) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;库存不足: productId=&#123;&#125;, requestedQuantity=&#123;&#125;, availableStock=&#123;&#125;&quot;</span>,</span><br><span class="line">                    productId, quantity, inventory.getAvailableStock());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;库存不足，无法扣减库存&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 库存扣减 - 使用乐观锁（版本号）控制</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">updatedRows</span> <span class="operator">=</span> inventoryMapper.reduceAvailableStockWithVersion(</span><br><span class="line">                productId,</span><br><span class="line">                quantity,</span><br><span class="line">                inventory.getVersion()</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (updatedRows == <span class="number">0</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;库存扣减失败  productId: &#123;&#125;, quantity: &#123;&#125;&quot;</span>, productId, quantity);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;库存扣减失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行业务逻辑</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> businessService.createBusinessDate();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">            <span class="comment">// 抛出异常以便事务回滚</span></span><br><span class="line">            logger.warn(<span class="string">&quot;业务逻辑执行失败  productId: &#123;&#125;, quantity: &#123;&#125;&quot;</span>, productId, quantity);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;业务逻辑执行失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，不论是库存条件约束，还是版本号乐观锁，都是适合并发不高的情况， 否则在修改库存时会出现频繁失败的情况， 影响用户体验和性能。</p><h1 id="4-悲观锁-select-for-update"><a href="#4-悲观锁-select…-for-update" class="headerlink" title="4. 悲观锁, select… for update"></a>4. 悲观锁, select… for update</h1><p>数据库<strong>悲观锁</strong> <code>SELECT ... FOR UPDATE</code> 是一种更好的并发控制手段。</p><p>当执行 <code>SELECT ... FOR UPDATE</code> 时，数据库会在查询的行上加上一个<strong>排他锁</strong>（Exclusive Lock，简称 X 锁），这会锁定该行，以防止其他事务对它进行修改或删除操作。</p><ul><li><strong>同一事务内</strong>：在持有行锁的情况下，不会影响同一事务内对该行数据的修改</li><li><strong>其他事务</strong>：对于其他试图修改该行的事务，会被锁阻塞，直到持锁的事务完成并释放锁后，才可以对该行进行修改。</li></ul><h2 id="41-表设计"><a href="#4-1-表设计" class="headerlink" title="4.1  表设计"></a>4.1  表设计</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id,</span><br><span class="line">    product_id,</span><br><span class="line">    total_stock,</span><br><span class="line">    available_stock,</span><br><span class="line">    version,</span><br><span class="line">    create_time,</span><br><span class="line">    update_time</span><br><span class="line"><span class="keyword">FROM</span> inventory</span><br><span class="line"><span class="keyword">WHERE</span> product_id <span class="operator">=</span> #&#123;productId&#125; <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure><h2 id="42-处理流程"><a href="#4-2-处理流程" class="headerlink" title="4.2 处理流程"></a>4.2 处理流程</h2><img src="/ca1e509/3.png" class><p>在查询数据时，使用<code>SELECT ... FOR UPDATE</code>  查询语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InventoryModel</span> <span class="variable">inventory</span> <span class="operator">=</span> inventoryMapper.selectByProductIdForUpdate(productId);</span><br></pre></td></tr></table></figure><h2 id="43-性能瓶颈表现"><a href="#4-3-性能瓶颈表现" class="headerlink" title="4.3 性能瓶颈表现"></a>4.3 性能瓶颈表现</h2><p><code>SELECT ... FOR UPDATE</code>  的使用会受限于数据库的性能瓶颈，在高并发情况下的主要体现在以下两个方面：</p><h3 id="431-对同一个库存的高并发请求"><a href="#4-3-1-对同一个库存的高并发请求" class="headerlink" title="4.3.1  对同一个库存的高并发请求"></a>4.3.1  对同一个库存的高并发请求</h3><ul><li><strong>大量事务等待</strong>：如果多个事务同时请求对同一个库存项进行扣减（即对同一行数据加锁），<code>SELECT ... FOR UPDATE</code> 会在第一个事务获取行锁后，使其他事务处于<strong>等待状态</strong>，直到该事务完成并释放锁。这会导致后续请求大量等待，增加系统的响应时间。</li><li><strong>锁等待队列</strong>：在这种情况下，所有对同一行的请求都会排队等待，直到持有锁的事务完成操作。锁的竞争会使得系统在高并发情况下变得缓慢，出现性能瓶颈。如果事务运行时间较长（如涉及复杂计算或外部请求），等待时间会进一步延长，影响系统吞吐量。</li></ul><p>因此，<strong>同一个库存项上的并发请求</strong>会引发<code>SELECT ... FOR UPDATE</code>的性能问题，因为所有请求都依赖于锁的释放。</p><h3 id="432-对不同库存项的高并发请求"><a href="#4-3-2-对不同库存项的高并发请求" class="headerlink" title="4.3.2 对不同库存项的高并发请求"></a>4.3.2 对不同库存项的高并发请求</h3><ul><li><strong>锁管理开销</strong>：如果数据库表中对多个库存项并发请求频繁，即便这些请求锁定的行不同，数据库仍需处理大量的锁操作、管理和维护。对于大表，数据库会创建多个行锁，增加了系统的锁管理开销。</li><li><strong>锁升级与锁膨胀</strong>：数据库在高并发的情况下，可能会将行锁升级为<strong>表级锁</strong>，特别是某些数据库为了提高性能或减少锁争用而引入的锁优化策略，这种升级会阻塞其他事务对整张表的操作，从而影响性能。</li></ul><p>因此，虽然对不同库存项的并发请求不一定直接引发锁等待问题，但大量的行锁会带来<strong>锁管理的性能开销</strong>。锁膨胀和锁升级在数据库负载较高时也可能导致性能下降。此外，由于表级锁的升级机制，其他对该表的查询和更新操作可能受到影响，导致整体性能下降。</p><p>总结</p><ul><li><strong>同一行的高并发请求</strong>：这种情况直接导致锁等待问题，影响更为显著。对于 <code>SELECT ... FOR UPDATE</code> 而言，这通常是最大的瓶颈来源。</li><li><strong>同一张表不同行的高并发请求</strong>：这种情况下，锁操作的管理开销增加。如果频繁的锁定和释放操作超出数据库的负载能力，数据库的整体性能也会受到影响，导致吞吐量下降。</li></ul><h2 id="44-select-for-update-也是分布式锁"><a href="#4-4-SELECT-FOR-UPDATE-也是分布式锁" class="headerlink" title="4.4  SELECT ... FOR UPDATE 也是分布式锁"></a>4.4  <code>SELECT ... FOR UPDATE</code> 也是分布式锁</h2><p>虽然说在高并发情况下，SELECT … FOR UPDATE 有性能问题，需要使用分布式锁来提升性能，但其实本质上，<code>SELECT ... FOR UPDATE</code> 也是一种分布式锁，只不过它依赖数据库，容易遇到瓶颈问题</p><h1 id="5-redis-分布式锁"><a href="#5-Redis-分布式锁" class="headerlink" title="5. Redis 分布式锁"></a>5. Redis 分布式锁</h1><p>在高并发时，可以使用更高效的<strong>Redis  分布式锁</strong>替代 <code>SELECT ... FOR UPDATE</code> 的行锁</p><h2 id="51-处理流程"><a href="#5-1-处理流程" class="headerlink" title="5.1 处理流程"></a>5.1 处理流程</h2><p>在用户请求发券时，通过一个分布式锁来确保每次只允许一个服务实例去处理该优惠券的库存扣减。具体流程为：</p><ul><li>通过请求的唯一标识，请求获取分布式锁。</li><li>如果获取成功，则该实例可以继续执行库存扣减操作；如果未获取到锁，则表示有其他实例正在处理当前的请求，当前请求需要等待或者直接返回失败（视具体业务需求而定）。<img src="/ca1e509/4.png" class></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryWithRedisService</span> &#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> InventoryMapper inventoryMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行不同业务场景下，具体的业务逻辑，商品售卖就是创建订单数据， 营销发券就是生成用户券数</span></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BusinessService businessService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;product_lock:&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">doBusiness</span><span class="params">(Integer productId, Integer quantity)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_KEY_PREFIX + productId;</span><br><span class="line">        <span class="comment">// 模拟获取redis 分布式锁逻辑</span></span><br><span class="line">        <span class="comment">//boolean acquiredLock = redis.setNx(lockKey, &quot;请求唯一id&quot;)</span></span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">acquiredLock</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!acquiredLock) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 获取锁失败，返回或重试</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">InventoryModel</span> <span class="variable">inventory</span> <span class="operator">=</span> inventoryMapper.findByProductId(productId);</span><br><span class="line">            <span class="keyword">if</span> (inventory.getAvailableStock() &lt; quantity)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">updatedRows</span> <span class="operator">=</span> inventoryMapper.reduceAvailableStock(</span><br><span class="line">                    productId,</span><br><span class="line">                    quantity</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (updatedRows == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存扣减失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行业务逻辑</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">result</span>  <span class="operator">=</span> businessService.createBusinessDate();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查用户券数据是否插入成功</span></span><br><span class="line">            <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;业务数据插入失败&quot;</span>);</span><br><span class="line">                <span class="comment">// 抛出异常以便事务回滚</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// todo 释放redis锁</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="52-在spring事务管理下注意正确加锁"><a href="#5-2-在Spring事务管理下，注意正确加锁" class="headerlink" title="5.2 在Spring事务管理下，注意正确加锁"></a>5.2 在Spring事务管理下，注意正确加锁</h2><p>如果你了解Spring 事务的工作原理的话，应该能发现 上面这段代码其实是有问题的。<br>它的实际工作效果时 开启事务-加锁-业务逻辑-释放锁-提交事务。</p><p>在事务提交前，Redis 锁就会释放， 这会导致并发问题。具体原因可以阅读 <a href="https://sunyan.xyz/2a483461/">在Spring事务管理下，使用Synchronized 为什么会出现并发问题</a></p><p>一般我们可以采用将锁移出事务管理范围的解决方案， 修改后的代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryWithRedisService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(InventoryWithRedisService.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RedisDistributedLock redisDistributedLock;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    InventoryWithVersionService inventoryWithVersionService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EXPIRE_TIME</span> <span class="operator">=</span> <span class="number">5</span> * <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_KEY_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;product_lock:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">reduceInventory</span><span class="params">(Integer productId, Integer quantity, String requestId)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> LOCK_KEY_PREFIX + productId;</span><br><span class="line">        <span class="comment">// 模拟获取redis 分布式锁逻辑</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">lockAcquired</span> <span class="operator">=</span> redisDistributedLock.acquireLock(lockKey, requestId, EXPIRE_TIME);</span><br><span class="line">        <span class="keyword">if</span> (!lockAcquired) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;未获取到锁 productId: &#123;&#125;, quantity: &#123;&#125;&quot;</span>, productId, quantity);</span><br><span class="line">            <span class="comment">// 获取锁失败，返回或重试</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> inventoryWithVersionService.reduceInventory(productId, quantity);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 如果释放失败则重试或者等待过期</span></span><br><span class="line">            <span class="keyword">if</span> (lockAcquired) &#123;</span><br><span class="line">                redisDistributedLock.releaseLock(lockKey, requestId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="53-redis-分布式锁是如何提升性能的"><a href="#5-3-Redis-分布式锁是如何提升性能的" class="headerlink" title="5.3 Redis 分布式锁是如何提升性能的"></a>5.3 Redis 分布式锁是如何提升性能的</h2><p>根据以上设计可以看出，使用Redis 分布式锁后，依然要先查询库存库存，但是使用的是快照读，而不必加锁，这样可以显著提升性能。</p><p>因为快照读不会造成数据库层面的锁等待和阻塞。以避免传统行锁导致的锁争用问题，从而显著提升性能。因此，在高并发和分布式场景中，Redis 锁和快照读是非常高效的组合方式。这种方式既保证了数据一致性，又减少了数据库的负载，能够有效提升系统的响应速度。</p><h2 id="54-性能提升了但也更复杂了"><a href="#5-4-性能提升了，但也更复杂了" class="headerlink" title="5.4 性能提升了，但也更复杂了"></a>5.4 性能提升了，但也更复杂了</h2><h3 id="541-未获取到锁该怎么处理"><a href="#5-4-1-未获取到锁该怎么处理" class="headerlink" title="5.4.1 未获取到锁该怎么处理"></a>5.4.1 未获取到锁该怎么处理</h3><p>在高并发系统中，使用 Redis 锁虽然性能更高，但未获取锁的请求管理需要更多的业务代码支持。</p><p>具体来讲就是，</p><p>在使用 <code>SELECT ... FOR UPDATE</code> 时，数据库的行锁等待机制能够自动阻塞请求，直到锁可用或超时。这种机制由数据库内核管理，开发人员无需额外处理等待逻辑。</p><p>但是 Redis 不提供内置的等待机制，因此在未能获取锁时，业务代码需要自行决定处理未获取到锁的请求，这为业务代码带来了额外的复杂性，因为需要显式地管理这些请求，例如重试、返回错误、或采用其他处理逻辑。</p><p>Redis 锁未获取到时的常见处理方式</p><h4 id="5411-重试机制"><a href="#5-4-1-1-重试机制" class="headerlink" title="5.4.1.1 重试机制"></a>5.4.1.1 重试机制</h4><p>在未获取到锁时稍微休眠一段时间（如 100 毫秒），然后再次尝试获取锁，重复该操作直至成功或达到最大重试次数。</p><p>适用于对实时性要求较高，但可以容忍短暂延迟的场景，例如库存扣减、秒杀等业务。</p><ul><li><strong>优点</strong>：可以在短时间内提高锁获取成功率，减少请求失败次数。</li><li><strong>缺点</strong>：如果并发量过大或锁占用时间较长，重试可能导致系统频繁轮询，增加服务器负担。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">retryCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxRetry</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (retryCount &lt; maxRetry) &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">acquiredLock</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(lockKey, <span class="string">&quot;locked&quot;</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    <span class="keyword">if</span> (acquiredLock) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 成功获取锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    retryCount++;</span><br><span class="line">    Thread.sleep(<span class="number">100</span>); <span class="comment">// 短暂休眠后重试</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5412-返回错误提示用户稍后重试"><a href="#5-4-1-2-返回错误提示用户稍后重试" class="headerlink" title="5.4.1.2 返回错误提示用户稍后重试"></a>5.4.1.2 返回错误提示用户稍后重试</h4><p>在未获取到锁的情况下，立即返回“系统繁忙，请稍后重试”的提示给用户。</p><p>适用于实时性要求高、无法容忍用户等待的场景，例如访问量巨大的电商秒杀、抢购场景。</p><ul><li><strong>优点</strong>：实现简单，不需要额外处理等待逻辑；避免了因频繁轮询带来的系统开销。</li><li><strong>缺点</strong>：用户体验可能不佳，尤其在并发量较大时，大量请求直接被拒绝。</li></ul><h4 id="5413-排队机制"><a href="#5-4-1-3-排队机制" class="headerlink" title="5.4.1.3 排队机制"></a>5.4.1.3 排队机制</h4><p>在业务逻辑中模拟等待机制，例如将未获取到锁的请求存入队列，并在锁可用时通过队列逐个处理。这样可以模拟类似于数据库行锁的等待机制。<br>总体来讲，实现成本高</p><p>一般来说，<strong>重试机制</strong>和<strong>立即返回错误</strong>更为常用、合理，可以根据具体的业务需求灵活选择适合的处理方式。这两种方式可以满足大多数应用的并发控制需求，既实现了 Redis 分布式锁的性能优势，又能在大多数场景下提供良好的用户体验。</p><h3 id="542-请求唯一标识"><a href="#5-4-2-请求唯一标识" class="headerlink" title="5.4.2 请求唯一标识"></a>5.4.2 请求唯一标识</h3><p>在使用分布式锁，最好可以有一个请求唯一标识，例如orderId, 这有助于做重复请求的幂等判断 以及锁的安全释放（防止锁被其他线程释放）</p><h3 id="543-锁的高可用"><a href="#5-4-3-锁的高可用" class="headerlink" title="5.4.3 锁的高可用"></a>5.4.3 锁的高可用</h3><p>如果 Redis 崩溃，锁信息可能丢失。在关键业务场景中，需要搭配使用高可用 Redis 集群。</p><h3 id="544-锁的过期时间"><a href="#5-4-4-锁的过期时间" class="headerlink" title="5.4.4 锁的过期时间"></a>5.4.4 锁的过期时间</h3><p>避免因服务器崩溃或请求超时而引发的死锁， 需要锁设置一个过期时间。<br>这样即使在某些请求未正常释放锁的情况下，锁也会在过期后自动释放，确保不会出现“死锁”现象，系统始终能够继续处理其他请求。</p><p>使用 <strong>Redis 分布式锁</strong> 可以有效解决并发情况下的超卖问题，但存在一个潜在风险：如果锁的<strong>过期时间设置不合理</strong>，在业务操作未完成时，锁就自动过期并释放，其他并发请求可能会错误地获得锁并操作库存，最终导致<strong>超卖问题</strong>。</p><h2 id="55-分布式锁版本号"><a href="#5-5-分布式锁-版本号" class="headerlink" title="5.5 分布式锁+版本号"></a>5.5 分布式锁+版本号</h2><p>在高并发场景中，仅使用 Redis 分布式锁可能不足以完全保证库存的一致性，尤其在遇到锁过期、网络故障等问题时，都可能出现并发导致库存超卖。</p><p>在使用 Redis 锁的基础上，引入版本号控制，可以更好地防止超卖、并发冲突和过期锁带来的数据不一致问题。</p><p><strong>Redis 锁与版本号</strong>的组合方案 能够为系统带来更高的可靠性和一致性保障，防止超卖</p><h3 id="551-表设计"><a href="#5-5-1-表设计" class="headerlink" title="5.5.1 表设计"></a>5.5.1 表设计</h3><p>与单独使用版本号乐观锁保持一致</p><h1 id="6-方案比较"><a href="#6-方案比较" class="headerlink" title="6 方案比较"></a>6 方案比较</h1><ol><li><p><strong>库存条件控制和版本号机制</strong>：适用于并发量不高的情况。通过检查库存是否满足扣减条件，或者使用版本号控制更新时的一致性。然而，在高并发场景下，这些方法可能会频繁失败，导致用户体验和系统性能下降。</p></li><li><p><strong><code>SELECT ... FOR UPDATE</code></strong>：通过数据库行锁确保在任意时刻只有一个线程能够修改库存。这种方式能有效避免并发问题，但在高并发场景下可能导致性能瓶颈，因为大量线程会等待锁释放。</p></li><li><p><strong>Redis 分布式锁</strong>：通过 Redis 实现分布式锁，避免数据库行锁，确保同一时刻只有一个线程可以修改库存。这种方式能提高并发处理能力，但引入了第三方中间件，增加了系统的复杂性，需要设计更多的细节来确保锁的有效性和健壮性。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;库存&lt;/strong&gt;是许多业务场景中都会涉及的概念，比如购物场景中的商品库存，以及营销场景中的优惠券库存。不同的业务场景有各自的交互流程，后端设计也会随之不同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;购物场景&lt;/strong&gt;：用户必须完成支付才</summary>
      
    
    
    
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="系统设计" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>如何处理重复请求保证幂等</title>
    <link href="http://example.com/c3915fbe/"/>
    <id>http://example.com/c3915fbe/</id>
    <published>2024-10-15T13:33:55.000Z</published>
    <updated>2024-10-26T01:52:24.451Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是幂等"><a href="#1-什么是幂等" class="headerlink" title="1. 什么是幂等"></a>1. 什么是幂等</h1><p>在系统设计中，“幂等”是一种非常重要的概念。</p><p>幂等性（Idempotency）指的是一个操作无论执行多少次，其结果都应保持一致，和只执行一次的结果相同。</p><p>这在分布式系统、网络请求和服务接口中尤为重要，因为它可以确保系统的数据一致性。</p><h1 id="2-为什么会出现重复请求"><a href="#2-为什么会出现重复请求" class="headerlink" title="2. 为什么会出现重复请求"></a>2. 为什么会出现重复请求</h1><p>重复请求在系统设计中是一个常见的问题，尤其是在高并发和分布式环境中。</p><p>出现重复请求的原因有多种，包括用户操作、业务逻辑重试、以及消息队列的特性。下面从这几个角度来详细解释重复请求的原因及其对系统的影响。</p><h2 id="21-用户重复点击"><a href="#2-1-用户重复点击" class="headerlink" title="2.1 用户重复点击"></a>2.1 用户重复点击</h2><p>用户点击按钮后，页面或系统可能响应缓慢。用户可能因为没有立即收到反馈，认为操作未成功，从而重复点击。每次点击都会触发一个新的请求，导致服务器收到多次请求。</p><h2 id="22-业务逻辑重试"><a href="#2-2-业务逻辑重试" class="headerlink" title="2.2  业务逻辑重试"></a>2.2  业务逻辑重试</h2><p>在分布式系统和网络请求中，为了保证请求成功执行，通常会有业务逻辑上的重试机制。</p><ul><li><p><strong>网络故障</strong>：在请求过程中，如果发生了网络超时、连接丢失或服务器未响应等问题，客户端可能会自动重试以确保请求最终成功。每次重试都将生成新的请求，导致服务器可能收到多个相同的请求。</p></li><li><p><strong>服务容错</strong>：有时服务器端在处理请求时，内部某个组件可能失败。为了提高可靠性，系统设计可能会重新触发该操作，使请求最终完成。这种设计用于容错，但也可能导致请求被多次重复。</p></li></ul><h2 id="23-消息队列消息重复"><a href="#2-3-消息队列消息重复" class="headerlink" title="2.3 消息队列消息重复"></a>2.3 消息队列消息重复</h2><p>在分布式系统中，消息队列用于异步处理任务并解耦服务。由于消息队列的工作机制，可能会引发重复消息：</p><ul><li><p><strong>消息确认机制</strong>：在一些消息队列系统（如 RabbitMQ 或 Kafka）中，消费者需要对消息进行确认。如果消费者处理完消息，但未能正确地向队列发送确认信息，队列会认为消息未被消费，因而重新发送。这种机制用于确保消息不会丢失，但可能会导致重复消费。</p></li><li><p><strong>消息回溯</strong> ：可能是服务出现了问题，需要手动回溯一段时间内的消息修复数据</p></li><li><p><strong>消息重新丢回消息队列</strong>： 消息消费时，业务逻辑处理失败，重新丢回队列等待下次处理，起到一个重试的作用</p></li></ul><h1 id="3-如何判断请求是重复的-唯一标识"><a href="#3-如何判断请求是重复的-唯一标识" class="headerlink" title="3. 如何判断请求是重复的-唯一标识"></a>3. 如何判断请求是重复的-唯一标识</h1><h2 id="31-请求要有唯一标识"><a href="#3-1-请求要有唯一标识" class="headerlink" title="3.1 请求要有唯一标识"></a>3.1 请求要有唯一标识</h2><p>在处理上游请求时， 需带有唯一标识， 比如营销系统在用券过程中处理订单系统的请求中，订单号就是唯一标识</p><h2 id="32-服务要记录唯一标识"><a href="#3-2-服务要记录唯一标识" class="headerlink" title="3.2 服务要记录唯一标识"></a>3.2 服务要记录唯一标识</h2><p>只要记录才能判断。</p><h1 id="4-处理重复请求保证幂等的通用流程"><a href="#4-处理重复请求保证幂等的通用流程" class="headerlink" title="4. 处理重复请求保证幂等的通用流程"></a>4. 处理重复请求保证幂等的通用流程</h1><p>幂等处理重复请求的逻辑基本如下</p><ol><li><p><strong>判断请求是否处理过</strong>：通过检查请求的唯一标识在系统中是否已存在。如果已存在，说明该请求是重复请求。</p></li><li><p><strong>执行处理逻辑并记录结果</strong>：如果请求未处理过，系统会执行请求的处理逻辑（例如写入数据库、扣款等），然后将处理结果记录下来，同时保存该请求的唯一标识符，以便后续识别重复请求。</p></li><li><p><strong>返回之前的处理结果</strong>：如果请求已经处理过，直接返回之前保存的处理结果，不再重复执行业务逻辑。这样可以防止由于重复请求导致的副作用，比如多次扣款或重复创建资源。</p></li></ol><h2 id="41-判断请求是否处理过"><a href="#4-1-判断请求是否处理过" class="headerlink" title="4.1 判断请求是否处理过"></a>4.1 判断请求是否处理过</h2><p>通过检查请求的唯一标识在系统中是否已存在。</p><p>注意这里的检查不一定非得是select,  毕竟在并发的情况下， 你直接用快照读select 大概率时无法保证幂等的。</p><p>所以其实在判断重复时最常见解决方式其实是用数据库唯一索引， 通过数据是否插入的结果来做“检查”工作。</p><p>选择唯一索引，是借助其唯一性约束的特性。在MySQL 中， 具有唯一性约束的索引有2个</p><ol><li>主键索引</li><li>唯一索引</li></ol><p>但是一般在处理重复请求保证幂等时，都是选择唯一索引</p><p>除唯一索引外，本文还将讨论Redis 分布式锁 + 快照读select 的方式如何保证幂等</p><h2 id="42-如果请求未处理过"><a href="#4-2-如果请求未处理过" class="headerlink" title="4.2 如果请求未处理过"></a>4.2 如果请求未处理过</h2><p>如果请求未处理过，系统会执行请求的处理逻辑，并记录下该请求供之后的重复请求判断</p><h2 id="43-如果请求已经处理过"><a href="#4-3-如果请求已经处理过" class="headerlink" title="4.3 如果请求已经处理过"></a>4.3 如果请求已经处理过</h2><p>如果请求已经处理过， 则不再重复处理， 直接返回请求结果。</p><p>在这个步骤中需要探讨的是返回什么结果， 是直接返回失败，还是返回重复请求提示， 还是查询处理后的结果根据处理结果返回。</p><p>下面详细说明在不同业务场景下，可能的返回方式</p><h3 id="431-直接返回失败"><a href="#4-3-1-直接返回失败" class="headerlink" title="4.3.1 直接返回失败"></a>4.3.1 直接返回失败</h3><ul><li><strong>适用场景</strong>：在某些需要严格保证每次请求都是独立处理的场景，比如数据库操作严格要求一次性完成。</li><li><strong>优点</strong>：这种方式简单直接，适合不需要告知重复请求或不关心前次请求结果的场景。</li><li><strong>缺点</strong>：这种处理方式可能在一些场景下引起用户疑惑，特别是用户不清楚请求已被处理时。</li></ul><h3 id="432-返回重复请求提示"><a href="#4-3-2-返回重复请求提示" class="headerlink" title="4.3.2 返回重复请求提示"></a>4.3.2 返回重复请求提示</h3><ul><li><strong>适用场景</strong>：适用于需要告诉用户请求已被处理，且不需要返回具体结果的场景，比如某些通知、确认请求。</li><li><strong>优点</strong>：这种方式能简洁地提示用户请求状态，避免重复处理。</li><li><strong>缺点</strong>：如果用户需要获取具体的处理结果（例如订单详情），则这种提示可能不够充分，影响体验。</li></ul><h3 id="433-查询并返回处理后的结果"><a href="#4-3-3-查询并返回处理后的结果" class="headerlink" title="4.3.3 查询并返回处理后的结果"></a>4.3.3 查询并返回处理后的结果</h3><ul><li><strong>适用场景</strong>：最常用的方式，适用于用户需要知道请求具体处理结果的场景，比如支付、订单、操作确认等需要精确返回的业务。</li><li><strong>优点</strong>：这种方式可以有效避免重复请求给用户带来的疑惑，同时返回详细结果，让用户更清楚操作状态。</li><li><strong>缺点</strong>：若数据库读取操作频繁且请求量大，可能对数据库性能造成一定压力。</li></ul><p>我觉得最好的方案应该是根据实际业务场景 确定返回值，而不是一概而论。</p><ul><li>对于关键业务场景（如支付、订单）推荐返回已处理的结果，以确保用户获得准确的反馈。</li><li>对于简单的幂等操作（如确认请求），可以返回重复请求提示，快速回应用户。</li><li>而对于更严格的操作需求，可以选择直接返回失败，提示用户请求冲突或错误。</li></ul><p>下面将介绍具体的技术方案</p><h1 id="5-基于唯一索引-本地事务如何保证幂等"><a href="#5-基于唯一索引-本地事务如何保证幂等" class="headerlink" title="5. 基于唯一索引-本地事务如何保证幂等"></a>5. 基于唯一索引-本地事务如何保证幂等</h1><p>使用唯一索引的前提下， 以上处理重复请求的通用流程可以具体描述为，</p><ol><li>将带有唯一标识的请求插入数据库</li><li>如果插入成功， 则代表数据未处理过， 可以继续执行处理业务逻辑</li><li>如果数据插入失败， 代表数据已经处理过， 直接返回结果即可</li></ol><img src="/c3915fbe/1.png" class><p>在很多情况下，<strong>唯一标识符</strong>的插入操作往往是业务操作的一部分，这使得唯一索引方案更加直接和高效。</p><p>但是，如果唯一标识符本身不是业务数据的一部分，而只是用于控制重复请求，则确实需要单独建立一张表来记录请求 ID 及其处理状态。</p><p>要注意一点的是， 以上看起来完美简洁的处理过程，其实需要建立在一个非常重要的前提下。</p><p>==那就是数据插入和业务逻辑需要用本地事务保证原子性。</p><img src="/c3915fbe/2.png" class><p>如果数据插入和业务执行不用本地事务保证原子性的话，就有可能出现部分失败的情况， 即业务执行失败，但是唯一索引插入成功了， 这会引发数据不一致的问题。</p><p>如果业务选择重复请求直接返回error 或者重复请求提示， 那这个实际业务逻辑并未执行的请求将永远无法得到处理，则数据不一致问题一直存在。当然如果你有合理的对账机制还是可以发现问题的。</p><p>如果重复请求返回之前的处理结果， 那还是可以发现问题的， 可以重新处理，但是这无疑违背了数据存在则代表已经处理过的逻辑，  也增加了代码复杂度。</p><p>所以，在能够使用本地事务保证数据插入和业务逻辑 原子性的时候， 要注意务必使用。</p><p>不能使用本地事务保证原子性的时候， 看下面这种方案</p><h1 id="6-基于唯一索引-分布式事务下如何保证幂等"><a href="#6-基于唯一索引-分布式事务下如何保证幂等" class="headerlink" title="6. 基于唯一索引-分布式事务下如何保证幂等"></a>6. 基于唯一索引-分布式事务下如何保证幂等</h1><p>其实在分布式系统下，很容易出现唯一标识数据插入和 业务逻辑 无法用本地事务保证原子性的情况</p><p>比如， 业务操作的数据有分库分表的情况<br>再比如，业务逻辑有调用第三方服务的情况。</p><p>面对这种分布式事务， 可以使用2PC + 异步检查的方案</p><p>所谓2PC ,具体来讲就是 唯一标识数据表要增加一个状态字段（如 <code>PENDING</code>、<code>PROCESSING</code>、<code>FAILED</code>、<code>COMPLETED</code> 等）。<br>初次请求插入时，标记为 <code>PROCESSING</code>。 插入时默认是初始态，然后执行业务逻辑， 根据业务逻辑执行结果，更改状态。</p><p>异步检查则用来处理部分失败的情况来保证数据的最终一致性</p><p>分布式事务下，数据插入和业务逻辑要分成 3 步处理，</p><ol><li>把数据插入到唯一索引，但是这个时候状态被标记为初始状态。注意这一步一定要先执行，这是避免重复处理的关键。</li><li>执行业务操作。</li><li>将唯一索引对应的数据标记为完成状态。</li></ol><p>出问题的地方就是第二步成功了，但是第三步失败了，即分布式事务部分失败的情况。这时候就需要使用一个异步检测逻辑，定时扫描唯一索引的表，然后再去扫描业务表， 判断对应的业务处理结果来更新唯一索引的状态。这个时候会有两种情况。</p><ol><li>根据业务表数据判断对应请求已经处理完成， 可以将对应唯一索引更新为成功状态。</li><li>根据业务表数据判断对应请求处理失败，可以直接发起重试或者等待重复请求</li></ol><h2 id="61-如果请求已经处理过-返回什么数据"><a href="#6-1-如果请求已经处理过，-返回什么数据" class="headerlink" title="6.1 如果请求已经处理过， 返回什么数据"></a>6.1 如果请求已经处理过， 返回什么数据</h2><p>在可以用本地事务保证数据插入和业务操作的原子性时， 查询到数据就默认业务逻辑已经执行成功了， 但是在分布式事务中， 数据插入增加了状态字段， 这时候该如何处理重复请求呢，一般有以下做法</p><h3 id="1-只要数据存在就按照业务场景返回值不关心状态"><a href="#1-只要数据存在就按照业务场景返回值，不关心状态" class="headerlink" title="1. 只要数据存在就按照业务场景返回值，不关心状态"></a>1. <strong>只要数据存在就按照业务场景返回值，不关心状态</strong></h3><ul><li><strong>适用场景</strong>：对于非关键性业务，重复请求只需要返回之前处理的结果，而不关心操作是否真正成功。这种方式适合场景是：即使业务逻辑未完全执行完毕或存在部分失败，对用户体验的影响不大。</li><li><strong>实现逻辑</strong>：重复请求到来时，只要数据库中存在该请求的唯一标识记录，系统就返回之前的结果或默认提示（例如“请求处理中”）。</li><li><strong>优点</strong>：这种方式能快速响应重复请求，不必等到业务逻辑完全完成，适合对状态不敏感的操作，减少请求处理延迟。</li><li><strong>缺点</strong>：如果业务逻辑执行失败或未完成，可能会误导用户，以为请求已完全处理成功。</li></ul><h3 id="2-只有标记为业务执行成功的数据返回结果其他状态继续执行"><a href="#2-只有标记为“业务执行成功”的数据返回结果，其他状态继续执行" class="headerlink" title="2. 只有标记为“业务执行成功”的数据返回结果，其他状态继续执行"></a>2. <strong>只有标记为“业务执行成功”的数据返回结果，其他状态继续执行</strong></h3><ul><li><strong>适用场景</strong>：适用于对请求结果准确性要求较高的场景，如支付、订单处理等。重复请求时，需要确保业务操作真正完成，才能返回相应的处理结果。</li><li><strong>实现逻辑</strong>：<ul><li>请求初次到达时，将数据状态设置为“处理中”或“待完成”，并执行相应业务逻辑。</li><li>若逻辑成功，更新状态为“成功”并返回结果。</li><li>若重复请求到来，系统检查状态字段。若状态为“成功”，直接返回结果；若状态为“处理中”或“失败”，则继续尝试完成未执行的操作。</li></ul></li><li><strong>优点</strong>：确保请求的业务逻辑完整执行，能准确返回最终处理结果，避免部分成功或未完成的情况影响用户体验。</li><li><strong>缺点</strong>：系统会对未完成的请求重复尝试，可能会导致重复执行，尤其是“处理中”的状态容易增加数据库负担。</li></ul><h3 id="3-判断状态并执行相应操作"><a href="#3-判断状态并执行相应操作" class="headerlink" title="3. 判断状态并执行相应操作"></a>3. <strong>判断状态并执行相应操作</strong></h3><ul><li>在这种模式下，根据数据状态做不同的处理，实现更精确的控制逻辑：<ul><li><strong>状态为“成功”</strong>：直接返回处理结果，避免重复执行。</li><li><strong>状态为“处理中”</strong>：根据业务场景，选择返回“正在处理中”的信息，或检查是否超过超时时间，决定是否重试。</li><li><strong>状态为“失败”或其他中间状态</strong>：可以自动重试，或者根据业务逻辑决定是否返回错误信息，让用户选择重试。</li></ul></li><li><strong>适用场景</strong>：复杂业务场景，特别是有多种中间状态的操作（如支付、物流等），需要确保业务逻辑完成。</li><li><strong>优点</strong>：灵活性强，根据状态精准控制逻辑，提高处理的准确性。</li><li><strong>缺点</strong>：代码复杂度增加，并且可能需要额外的状态管理和清理逻辑。</li></ul><p>最佳方案一般是 <strong>根据状态来判断如何处理</strong>，特别是在关键业务场景中（如支付、订单）。使用状态字段来明确请求的处理进度和结果状态，可以确保系统准确返回处理结果，同时避免因部分操作失败或未完成而影响业务一致性和用户体验。具体实现方案：</p><ol><li><strong>状态管理表设计</strong>：<ul><li>为请求表增加状态字段（如 <code>PENDING</code>、<code>PROCESSING</code>、<code>FAILED</code>、<code>COMPLETED</code> 等），记录每次请求的状态。</li><li>初次请求插入时，标记为 <code>PROCESSING</code>。</li></ul></li><li><strong>重复请求的状态判断</strong>：<ul><li><strong>成功状态（<code>COMPLETED</code>）</strong>：直接返回最终处理结果，避免重复执行。</li><li><strong>处理中状态（<code>PROCESSING</code>）</strong>：根据业务场景，选择返回“正在处理中”的信息，或检查是否超过超时时间，决定是否重试。</li><li><strong>失败状态（<code>FAILED</code>）</strong>：可以尝试重试业务逻辑，也可以根据业务需求返回错误提示，避免用户等待。</li></ul></li></ol><p><strong>适用场景</strong>：复杂业务场景，特别是有多种中间状态的操作（如支付、物流等），需要确保业务逻辑完成。</p><p><strong>优点</strong>：灵活性强，根据状态精准控制逻辑，提高处理的准确性。</p><p><strong>缺点</strong>：代码复杂度增加，并且可能需要额外的状态管理和清理逻辑。</p><h2 id="62-异步补偿任务的重试策略"><a href="#6-2-异步补偿任务的重试策略" class="headerlink" title="6.2 异步补偿任务的重试策略"></a>6.2 异步补偿任务的重试策略</h2><p>补偿任务的重试策略若未控制好，可能会导致大量重复操作，比如不断对同一条记录尝试补偿操作，从而对数据库造成不必要的压力。</p><p>补偿任务设定合理的<strong>重试次数和时间间隔</strong>，并在一定次数的重试后，应该告警通知人工处理，避免无限重试的情况。</p><h2 id="63-重试下的并发"><a href="#6-3-重试下的并发" class="headerlink" title="6.3 重试下的并发"></a>6.3 重试下的并发</h2><p>从前面的描述中可以看出， 在异步补偿机制中可能执行一个请求的业务逻辑，上游重复请求如果状态不是成功也可能触发业务逻辑执行，导致同一数据被并发处理，从而造成数据不一致或重复操作。 可以考虑以下方案</p><p><strong>分布式锁</strong>：确保针对某条请求或记录的操作只会被单一实例处理。这样，即使前端请求和异步补偿同时触发操作，也能确保只有一个线程/实例在执行，避免重复处理问题。</p><p><strong>乐观锁或版本号控制</strong>：在数据库记录中加入版本号或时间戳，通过比较版本号来确保只有最新的更新才会被接受。如果某个操作发现记录版本号已变更，则跳过操作或重新加载最新数据。</p><h1 id="7-使用-redis-分布式锁控制重复请求-不用唯一索引"><a href="#7-使用-Redis-分布式锁控制重复请求-不用唯一索引" class="headerlink" title="7. 使用 Redis 分布式锁控制重复请求-不用唯一索引"></a>7. 使用 Redis 分布式锁控制重复请求-不用唯一索引</h1><p>可以将唯一请求标识作为key ,使用setnx 来控制重复请求，只有获取到锁的请求，才能到数据库中判断请求是否处理过具体处理流程如下</p><ul><li><strong>获取 Redis 锁</strong>：每次请求到达时，首先尝试获取 Redis 分布式锁（例如基于请求 ID 或业务 ID）。</li><li><strong>成功获取到锁</strong>：成功获取锁后，系统可以使用select快照读查询数据库，判断业务数据是否已存在。<ul><li>如果数据存在，说明请求已处理过，可以直接返回结果。</li><li>如果数据不存在，执行数据插入和后续业务逻辑， 具体就是上文中本地事务和分布式事务的方案。</li></ul></li><li><strong>未获取到锁</strong>：如果在尝试获取 Redis 锁时发现锁已被持有，可以直接根据场景返回合适的信息（例如“请求处理中”或上一次请求的结果），避免重复处理。</li></ul><h2 id="71-优点"><a href="#7-1-优点" class="headerlink" title="7.1 优点"></a>7.1 优点</h2><ul><li><strong>无需使用唯一索引</strong>：使用分布式锁可以有效防止并发重复请求，而不依赖数据库唯一索引来判断请求的唯一性。</li><li><strong>减少数据库压力</strong>：这种方式减少了对数据库唯一索引的依赖，不需要额外的索引检查，有助于在高并发场景下降低数据库的索引负载。</li></ul><h2 id="72-潜在问题和解决方法"><a href="#7-2-潜在问题和解决方法" class="headerlink" title="7.2 潜在问题和解决方法"></a>7.2 潜在问题和解决方法</h2><ol><li><strong>锁的过期时间与任务执行时间的同步问题</strong>：<ul><li><strong>问题描述</strong>：如果业务逻辑执行时间较长，而 Redis 锁的过期时间较短，锁可能在业务逻辑执行完之前被释放。其他请求可能会在锁过期后重新获取锁，从而导致重复处理。</li><li><strong>解决方法</strong>：可以动态设置锁的过期时间，或者在长时间任务中定期刷新锁，确保锁在业务逻辑执行完毕前不会过期。</li></ul></li><li><strong>锁竞争导致延迟</strong>：<ul><li><strong>问题描述</strong>：在高并发场景中，多个请求可能会同时尝试获取锁，未能获取锁的请求会直接被返回处理结果或默认值。这可能导致某些请求延迟或未能成功触发业务逻辑。</li><li><strong>解决方法</strong>：可以在获取锁失败时增加简单的重试机制（例如短暂等待后再尝试获取锁），提高锁的获取成功率。不过，这会带来少量额外的延迟，需要根据业务场景衡量利弊。</li></ul></li><li><strong>锁的可靠性问题</strong>：<ul><li><strong>问题描述</strong>：在 Redis 实例重启或网络故障的情况下，锁有可能被意外释放或丢失，导致多个请求进入业务逻辑，从而导致重复处理。</li><li><strong>解决方法</strong>：为提升锁的可靠性，可以将锁的管理迁移到 Redis 集群中，使用多节点的 Redis 实例，增强锁的持久性。此外，可以在业务逻辑中实现<strong>幂等性</strong>，即使在锁失效的情况下，重复执行也不会影响最终结果。</li></ul></li><li><strong>锁释放与数据一致性</strong>：<ul><li><strong>问题描述</strong>：在极端情况下，业务逻辑执行成功但未能释放锁（例如服务器崩溃或进程被强制中断），可能导致锁保持被持有的状态，阻止后续请求正常执行。</li><li><strong>解决方法</strong>：可以设置锁的过期时间，并在锁释放之前检查操作是否已经完成，以确保状态一致。此外，可以通过 Redis 事务或 Lua 脚本确保锁的获取和释放都在 Redis 内部完成，避免锁释放的潜在不一致问题。</li></ul></li></ol><h1 id="8-唯一索引-vs-redis"><a href="#8-唯一索引-vs-Redis" class="headerlink" title="8. 唯一索引 vs Redis"></a>8. 唯一索引 vs Redis</h1><h2 id="81-原子性和一致性"><a href="#8-1-原子性和一致性" class="headerlink" title="8.1 原子性和一致性"></a>8.1 原子性和一致性</h2><ul><li><strong>数据库唯一索引</strong>提供了天然的幂等性保障：对于同一个请求 ID，数据库在插入时会自动校验唯一性，这意味着一旦插入成功，后续重复插入将自动被拒绝。</li><li><p>因此，<strong>原子性</strong>操作由数据库控制，避免了额外的状态检查和分布式锁逻辑，且不依赖于外部系统（如 Redis），从而保证操作在并发下的一致性。</p><h2 id="82-可靠性"><a href="#8-2-可靠性" class="headerlink" title="8.2 可靠性"></a>8.2 可靠性</h2></li><li><p>数据库的唯一约束是持久性的，避免了 Redis 分布式锁在极端情况下失效的问题。Redis 分布式锁的可靠性依赖于 Redis 的稳定性，而数据库的唯一约束则不受外部条件的影响。</p></li><li>唯一索引依赖于数据库，且数据库天然具备持久性，适合需要保证操作绝对正确的关键业务（如订单生成、支付扣款等）。</li></ul><h2 id="83-简化的代码和逻辑"><a href="#8-3-简化的代码和逻辑" class="headerlink" title="8.3 简化的代码和逻辑"></a>8.3 简化的代码和逻辑</h2><ul><li>使用数据库唯一索引方案能够减少代码复杂度，因为请求的判断和插入是一个原子性操作，不需要额外控制并发或同步机制。</li><li>而在 Redis 分布式锁方案中，需要额外处理锁的获取、释放、超时和潜在的异常情况，增加了业务逻辑的复杂性和管理成本。</li></ul><p>对于多数业务场景，<strong>数据库唯一索引</strong>是最佳选择，它更可靠、简洁、适合大多数数据库能够支撑的高并发操作。<br>在极端高并发场景或复杂业务场景下，可以考虑<strong>Redis 分布式锁</strong>方案，尤其是当业务需要灵活性时。</p><p>另外，如果希望充分利用二者的优点，可以结合<strong>数据库唯一索引和 Redis 锁</strong>：使用唯一索引作为主幂等保障，Redis 锁作为并发控制辅助，以提升系统的扩展性和稳健性。</p><h1 id="9-高并发高重复下-如何提升唯一索引的性能-redis-唯一索引"><a href="#9-高并发高重复下-，-如何提升唯一索引的性能：-Redis-唯一索引" class="headerlink" title="9. 高并发高重复下 ， 如何提升唯一索引的性能： Redis + 唯一索引"></a>9. 高并发高重复下 ， 如何提升唯一索引的性能： Redis + 唯一索引</h1><p>使用唯一索引时，性能瓶颈完全取决于数据库。</p><p>如果短时间重复请求非常多，可以使用 Redis 存储已处理过的请求来拦截短时间内的重复请求，以有效减少数据库层面的重复请求判断，避免数据库频繁执行唯一索引检查，从而提升系统性能。</p><p>Redis 的value  类型是 set，用户存储处理过的请求</p><p>注意：这里的redis 不再是第7小节中的分布式锁功能</p><p>注意：如果不是高并发或者重复率很高的情况下， 这种方案和直接使用唯一索引相比，并不会提高性能，甚至更慢， 因为多了一层判断。</p><p>处理流程如下<br><img src="/c3915fbe/3.png" class></p><p>该方案需要考虑以下问题</p><h2 id="91-redis-更新逻辑-辅助性组件"><a href="#9-1-Redis-更新逻辑-辅助性组件" class="headerlink" title="9.1 Redis 更新逻辑 -辅助性组件"></a>9.1 Redis 更新逻辑 -辅助性组件</h2><p>使用唯一索引的具体方案，依然是前面介绍过的分为本地事务、分布式事务2种情况。<br>Redis 在这个方案中确实作为一个辅助性工具，用于快速判断短时间内的重复请求，以减轻数据库负载并加快响应速度，而不是作为请求处理过程中的核心事务性组件。即Redis 操作均不在其事务范围内， 即使redis操作失败也不影响业务结果。</p><p>将 Redis 作为重复请求的辅助性判断工具，而不是事务的一部分，这种设计思路非常合理且符合分布式系统的最佳实践。具体表现为：</p><ul><li><strong>提高了系统性能</strong>：通过 Redis 辅助缓存，减少了频繁的数据库访问量。</li><li><strong>保障了业务核心的一致性</strong>：核心事务逻辑依然依赖数据库，而不是 Redis，从而避免了因 Redis 操作失败导致请求失败的风险。</li><li><strong>增强了系统的容错性</strong>：Redis 操作失败时系统依然可以正常处理请求，确保了系统的高可用性。</li></ul><h3 id="本地事务后更新redis"><a href="#本地事务后更新Redis" class="headerlink" title="本地事务后更新Redis"></a>本地事务后更新Redis</h3><p>比较简单，成功后就就把对应唯一标识加入到Redis 中即可</p><h3 id="分布式事务后更新redis"><a href="#分布式事务后更新Redis" class="headerlink" title="分布式事务后更新Redis"></a>分布式事务后更新Redis</h3><p>分布式事务环境下的唯一索引存在多种状态和部分失败的情况，因此确实需要根据具体的业务场景来决定哪些状态下的唯一标识可以放入 Redis，并且在异步补偿逻辑中合理处理 Redis 相关逻辑。</p><p>在分布式事务下，业务操作的执行可能会导致请求的状态多样化，例如PENDING<code>、</code>PROCESSING、COMPLETED 等状态。将所有状态都放入 Redis 并不一定合适，需要基于业务场景做出选择。</p><p>可以考虑选择将“成功”或“最终完成”状态的请求放入 Redis，这样能够过滤掉短时间内的重复请求，而不影响系统的幂等性。如果请求仍在“处理中”或“部分成功”，则避免直接加入 Redis，以免误导其他请求判断。</p><h2 id="92-redis-的过期时间"><a href="#9-2-Redis-的过期时间" class="headerlink" title="9.2 Redis 的过期时间"></a>9.2 Redis 的过期时间</h2><p>可以根据业务需要设置 Redis 中记录的过期时间。例如，如果系统常见的重复请求会在几分钟内重新到达，则可以在 Redis 中为每个处理记录设置一个合理的过期时间（如 5 分钟）。这样，过期的请求自动失效，不会长期占用缓存空间。<br>注意过期时间应该做成可配置的， 方便根据业务的实际重复请求频率动态调整过期时间，以找到适合的平衡点，减少缓存失效对数据库的冲击。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-什么是幂等&quot;&gt;&lt;a href=&quot;#1-什么是幂等&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是幂等&quot;&gt;&lt;/a&gt;1. 什么是幂等&lt;/h1&gt;&lt;p&gt;在系统设计中，“幂等”是一种非常重要的概念。&lt;/p&gt;
&lt;p&gt;幂等性（Idempotency）指的</summary>
      
    
    
    
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="系统设计" scheme="http://example.com/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>从HTTP到HTTPs, 如何实现加密传输</title>
    <link href="http://example.com/79674443/"/>
    <id>http://example.com/79674443/</id>
    <published>2024-09-13T11:36:38.000Z</published>
    <updated>2024-09-22T11:51:12.024Z</updated>
    
    <content type="html"><![CDATA[<p>本文参考《图解密码技术》， 从HTTPs 为什么比HTTP 安全的角度梳理多个和密码相关的知识点， 希望对你有帮助。</p><p>以下内容介绍，均基于Alice 向Bob 发送邮件为基础进行介绍<br><img src="/79674443/1.png" class></p><h1 id="1-前置知识"><a href="#1-前置知识" class="headerlink" title="1. 前置知识"></a>1. 前置知识</h1><h2 id="11-计算机网络"><a href="#1-1-计算机网络" class="headerlink" title="1.1 计算机网络"></a>1.1 计算机网络</h2><p>在了解密码具体知识前，需要先了解一下传输信息的计算机网络。<br>主要有2点</p><ol><li>计算机网络是分层的</li><li>网络传输依赖一系列中间设备 网络传输并不是简单的A点到B点的直接通信，而是依赖于一系列中间设备。</li><li>当我们在互联网上发送数据时（例如发送一封电子邮件），数据不会以单一的整体方式进行传输。相反，它会被拆分成许多小的“数据包”（packets），每个数据包包含发送方、接收方以及数据本身的一部分。这些数据包会经过复杂的路径传输，最终在目标设备处重新组合，恢复成完整的消息。</li></ol><h3 id="111-计算机网络是分层的"><a href="#1-1-1-计算机网络是分层的" class="headerlink" title="1.1.1 计算机网络是分层的"></a>1.1.1 计算机网络是分层的</h3><img src="/79674443/2.png" class><h3 id="112-网络传输依赖于一系列中间设备"><a href="#1-1-2-网络传输依赖于一系列中间设备" class="headerlink" title="1.1.2 网络传输依赖于一系列中间设备"></a>1.1.2 网络传输依赖于一系列中间设备</h3><p>网络传输并不是简单的A点到B点的直接通信，而是依赖于一系列中间设备。这些中间设备包括路由器、交换机、服务器、网关等，它们共同协作以确保数据包能够从源点传输到目标点。</p><p>在此过程中，每个中间设备都有可能成为窃听的切入点。为了理解这些中间设备如何导致窃听的可能性，我们先从网络的工作原理开始，然后逐步深入探讨中间设备如何影响数据的安全性。</p><p>为了使数据从A点传输到B点，它必须经过多个中间设备，这些设备主要包括：</p><ul><li><strong>路由器（Router）</strong>：路由器在不同网络之间转发数据，它通过读取数据包中的目标地址来决定数据包应该被发送到哪个下一跳路由器。路由器实际上是决定数据传输路径的关键设备。</li><li><strong>交换机（Switch）</strong>：交换机通常在局域网（LAN）中使用，它负责根据数据包中的MAC地址在局域网内部的设备之间转发数据。</li><li><strong>防火墙（Firewall）</strong>：防火墙用于监控网络流量，阻止不安全或未经授权的通信。虽然防火墙并不负责路由，但它是数据包在传输时必须经过的设备之一，它在数据包进入或离开网络时检查流量。</li><li><strong>网关（Gateway）</strong>：网关是网络中的特殊设备，它负责在不同网络协议或不同网络之间转换数据。它们通常位于不同类型网络的边界上。</li><li><strong>服务器</strong>：在某些情况下，数据包可能会通过中间服务器进行处理。例如，当你发送电子邮件时，邮件首先被发送到邮件服务器，然后服务器根据接收者的地址将其传送到目标邮件服务器。</li></ul><p>数据包在互联网中传输时，必须经过这些中间设备，依靠它们来找到最终的目标地址。因此，网络传输并不是简单的两台设备直接通信，而是通过一系列中间设备和多次转发实现的。</p><h2 id="12-加密安全特性"><a href="#1-2-加密安全特性" class="headerlink" title="1.2 加密安全特性"></a>1.2 加密安全特性</h2><p>现代加密系统关注的一些安全特性：</p><ol><li>消息的机密性（Confidentiality）：指确保消息在传输过程中不会被未授权的第三方窃取，即使被窃取，也无法解读消息的真正含义。</li><li>消息的完整性/防篡改（Integrity）： 是指确保消息在传输过程中没有被修改。如果消息被篡改，接收方应该能够识别出这一点。</li><li>消息的认证（Authentication）：认证是指确认消息的发送者是谁，确保接收方能够识别消息的合法发送者。这意味着接收方可以确信消息确实是来自声称的发送者，而不是来自其他未授权的第三方。</li><li>消息发送者的认证与防止否认（Non-repudiation）：指一旦确定消息来自某个发送者，发送者就不能否认自己发送了这条消息。也就是说，发送方在发送消息后，无法声称自己没有发送过该消息。</li></ol><h2 id="13-密码学工具箱"><a href="#1-3-密码学工具箱" class="headerlink" title="1.3 密码学工具箱"></a>1.3 密码学工具箱</h2><ol><li>对称加密</li><li>非对称加密</li><li>消息认证码</li><li>数字签名</li><li>单向散列函数</li><li>伪随机数</li></ol><h2 id="14-加密算法-机密性"><a href="#1-4-加密算法-机密性" class="headerlink" title="1.4 加密算法-机密性"></a>1.4 加密算法-机密性</h2><p>加密与摘要的本质区别就在于，摘要是不可逆的，而加密是可逆的，逆过程就是解密。</p><p>在经典密码学时代，加密的安全主要是依靠机密性来保证的，也就是依靠保护加密算法或算法的执行参数不被泄露，来保障信息的安全。而现代密码学并不依靠机密性，加解密算法都是完全公开的，信息的安全是建立在特定问题的计算复杂度之上。具体来说，就是算法根据输入端计算输出结果，这里耗费的算力资源很小；但根据输出端的结果反过来推算原本的输入，耗费的算力就极其庞大。</p><h3 id="141-对称加密算法"><a href="#1-4-1-对称加密算法" class="headerlink" title="1.4.1 对称加密算法"></a>1.4.1 对称加密算法</h3><p>加密、解密使用同一个密钥 称之为对称加密。</p><p>就像我们用保险箱存取贵重物品一样，存的时候用一把钥匙打开门把贵重物品放进去，取的时候 也是用同一把钥匙打开门把贵重物品取出来。</p><h4 id="常见的对称加密算法"><a href="#常见的对称加密算法" class="headerlink" title="常见的对称加密算法"></a>常见的对称加密算法</h4><p><strong>DES</strong></p><p>DES 是一种分组加密算法，采用64位的明文分组进行加密，并且使用56位的密钥进行加密操作（虽然密钥的实际长度是64位，但其中8位用于校验）。<br>现代计算能力可以在短时间内通过暴力破解尝试所有可能的密钥，从而解密DES加密的数据。因此，DES在现代已被视为不安全的加密算法。</p><p><strong>三重DES</strong><br>3DES是为了增强DES的安全性而设计的。它通过重复DES加密过程三次来提高加密强度，从而克服了DES密钥过短的问题。<br>3DES使用三个不同的56位密钥，进行三轮DES加密解密操作：首先使用第一个密钥加密数据，然后用第二个密钥解密，最后再用第三个密钥加密。这个过程可以有效地增强DES的加密强度。</p><p>虽然3DES比DES安全，但是计算速度也更慢，所以在现代应用中，除一些遗留系统外，它已经被更新的加密标准AES所取代</p><p><strong>AES</strong><br>AES是目前最常用的对称加密算法，并被广泛用于政府、金融、军事和商业应用中。它已经取代了DES和3DES，成为主流的加密标准。</p><p>AES是一种分组加密算法，支持128位、192位或256位的密钥长度，且使用128位的固定分组大小。</p><h4 id="分组加密"><a href="#分组加密" class="headerlink" title="分组加密"></a>分组加密</h4><p>从前面的描述中可以看到，DES 和AES 都属于分组加密算法，他们只能加密固定长度的明文， 如果需要加密任意长度的明文，就需要将明文分组然后加密迭代。</p><p>分组加密算法有多种工作模式，包括ECB、CBC、CFB、OFB、CTR</p><h3 id="142-非对称加密算法"><a href="#1-4-2-非对称加密算法" class="headerlink" title="1.4.2 非对称加密算法"></a>1.4.2 非对称加密算法</h3><p>加密、解密使用不同的密钥 称之为非对称加密。<br>加密过程使用的密钥通常称之为私钥，解密过程使用的密钥通常称之为公钥</p><p>公钥和私钥确实是通过特定的数学算法生成的密钥对，它们紧密相连</p><ul><li><strong>公钥加密、私钥解密</strong>：在典型的加密场景中（如RSA加密），公钥用于加密数据，私钥用于解密数据。这使得任何拥有公钥的人都可以加密数据，但只有拥有私钥的人可以解密。</li><li><strong>私钥签名、公钥验证</strong>：在数字签名场景中，私钥用于对数据进行签名，公钥用于验证签名的真实性。也就是说，私钥生成的签名可以被公钥验证，而不泄露私钥。</li><li><ol><li><strong>公钥加密，私钥解密，这种就是加密</strong>，用于向私钥所有者发送信息，这个信息可能被他人篡改，但是无法被他人得知。举个例子，如果甲想给乙发一个安全保密的数据，那么应该甲乙各自有一个私钥，甲先用乙的公钥加密这段数据，再用自己的私钥加密这段加密后的数据，最后再发给乙。这样确保了内容既不会被读取，也不能被篡改。</li></ol></li></ul><ol><li><strong>私钥加密，公钥解密，这种就是签名</strong>，用于让所有公钥所有者验证私钥所有者的身份，并能用来防止私钥所有者发布的内容被篡改。但是它不用来保证内容不被他人获得。</li></ol><p><strong>缺点</strong></p><ol><li>加密效率低且不能直接用于大量数据的加密。因此非对称加密算法，并不适合直接用户加密传输大量明文</li><li>无法解决中间人攻击，具体内容放在下面说</li></ol><p><strong>密传输问题</strong><br>公钥的传输依然有可能被第三方获取， 从而导致中间人攻击，后面会具体介绍。</p><h3 id="143-单向散列函数-识别篡改"><a href="#1-4-3-单向散列函数-识别篡改" class="headerlink" title="1.4.3 单向散列函数-识别篡改"></a>1.4.3 单向散列函数-识别篡改</h3><p>一般这个性质叫做防篡改， 我觉得叫做识别篡改更准确。</p><p><strong>单向散列函数</strong>（也称为哈希函数）不能<strong>主动</strong>防止内容的篡改，但它可以通过生成固定长度的哈希值来<strong>检测</strong>内容是否被篡改。</p><p>单向散列函数的主要特点：</p><ol><li><strong>固定长度输出</strong>：无论输入数据的长度如何，散列函数生成的哈希值长度总是固定的。比如SHA-256总是输出256位的哈希值。</li><li><strong>单向性</strong>：散列函数是单向的，意味着很难从哈希值反推原始数据。</li><li><strong>相同输入相同输出</strong>：如果两次输入的数据相同，那么散列函数的输出也一定相同。</li><li><strong>微小的输入变化会导致完全不同的输出</strong>：称为“雪崩效应”，即使输入数据只有一个比特的变化，生成的哈希值也会完全不同。</li></ol><p><strong>单向散列函数</strong>是一种将任意长度的输入（如文件、消息）映射为固定长度输出（称为哈希值、消息摘要）的算法。常见的单向散列函数有：</p><ul><li><strong>MD5</strong>（虽然已经被认为不安全）</li><li><strong>SHA-1</strong>（也已不推荐使用）</li><li><strong>SHA-256</strong>、<strong>SHA-3</strong> 等较新的哈希算法</li></ul><h3 id="144-消息认证码-识别篡改-amp-认证"><a href="#1-4-4-消息认证码-识别篡改-amp-认证" class="headerlink" title="1.4.4 消息认证码-识别篡改 &amp; 认证"></a>1.4.4 消息认证码-识别篡改 &amp; 认证</h3><p><strong>消息认证码（MAC, Message Authentication Code）</strong> 是一种通过共享的对称密钥生成的固定长度的校验值，用于确保消息的<strong>完整性</strong>和<strong>认证性</strong>。MAC的主要功能是：</p><ul><li><strong>完整性</strong>：指的是数据在传输过程中是否被篡改。MAC通过计算消息的哈希值并结合共享密钥生成一个认证码（MAC值）。接收方使用同样的密钥计算MAC值并与接收到的MAC值进行对比，从而确认消息是否被篡改。</li><li><strong>认证性</strong>：由于MAC是基于双方共享的对称密钥生成的，只有持有该密钥的合法发送者才能生成正确的MAC值，因此接收方可以通过验证MAC值来确认消息的发送者是持有密钥的合法参与者。</li></ul><p><strong>消息认证码（MAC）</strong> 的两个主要特性都是基于<strong>共享密钥的安全性</strong>来实现的。如果共享的密钥被第三方窃取，MAC的这两个特性就不复存在。</p><p>尽管在密钥安全的前提下，MAC能够识别篡改和认证消息的发送者身份，但它存在一个明显的局限性：<strong>无法防止消息发送者的否认</strong>，这在密码学中称为<strong>不可否认性（Non-repudiation）</strong>。</p><p>在使用MAC时，发送方和接收方都持有相同的对称密钥，这意味着：</p><ul><li>接收方和发送方都可以生成和验证相同的MAC值。由于双方共享相同的密钥，任何一方都可以计算出有效的MAC。</li><li>如果发送方之后否认曾发送过某条消息，接收方没有办法证明发送方确实发送了这条消息，因为接收方自己也可以生成相同的MAC值。</li></ul><p>因此，消息认证码不能提供<strong>不可否认性</strong>。在法律或信任系统中，接收方无法向第三方（如法庭）证明某个特定消息是由发送方发出的，因为双方共享同一个密钥，任何一方都可以生成有效的MAC。这使得发送者有可能否认曾发送消息，或者接收方可能伪造消息并声称是发送方发送的。</p><h3 id="145-数字签名-认证-amp-防止否认"><a href="#1-4-5-数字签名-认证-amp-防止否认" class="headerlink" title="1.4.5 数字签名-认证 &amp; 防止否认"></a>1.4.5 数字签名-认证 &amp; 防止否认</h3><p>数字签名依赖于非对称加密的核心机制，即使用<strong>私钥</strong>进行签名、使用<strong>公钥</strong>进行验证，从而能够完成认证不可否认两个特性。</p><p>如果签名验证通过，接收方可以确认消息确实来自持有该私钥的发送者。这就是<strong>认证性</strong>，即确保消息的发送者身份是真实的。</p><p>由于只有私钥持有者能够生成有效的签名，发送方无法否认自己曾经对消息进行过签名。这就是<strong>不可否认性</strong>。</p><h3 id="146-消息认证码认证-vs-数字签名认证"><a href="#1-4-6-消息认证码认证-vs-数字签名认证" class="headerlink" title="1.4.6 消息认证码认证 vs 数字签名认证"></a>1.4.6 消息认证码认证 vs 数字签名认证</h3><p>MAC（消息认证码）通过共享的密钥，认证消息确实来自通信对方，但是它一个非常大的缺点就是没有强身份认证，即不认证具体身份</p><ol><li>由于双方共享同一个密钥，MAC 只能证明消息来自拥有该密钥的一方，但如果多个实体共享同一个密钥，无法确定到底是哪一个实体发送的消息。也就是说，MAC 没有强身份认证功能，无法防止发送者后来否认自己发出的消息（不可否认性问题）。</li><li>同时由于没有身份认证，在密钥泄漏的情况下，也无法识别中间人攻击</li></ol><p>数字签名则提供了一种强身份认证的认证类型，确保消息来自某个具体的发送者， 同时可以防止否认</p><h1 id="2-http-通信使用明文可能会被窃听"><a href="#2-HTTP-通信使用明文可能会被窃听" class="headerlink" title="2. HTTP -通信使用明文可能会被窃听"></a>2. HTTP -通信使用明文可能会被窃听</h1><p>Alice 发出的邮件通过计算机网络传输给Bob, 邮件传输的过程中需要经过一系列中间设备。这些设备或节点被恶意控制或监控，那么邮件就有可能被窃听。<br>黑客或其他有恶意意图的人，可以在这些节点上安装窃听软件，或者通过物理方式接入网络来截获数据, 进而做篡改或者中间人攻击等</p><img src="/79674443/3.png" class><p>既然窃听是因为网络传输需要经过设备造成的，那么一种理想的解决办法就是，点对点通信。</p><p>如果Alice和Bob的计算机之间有一个完全物理隔离的、私有的连接（比如一根专线或者光纤），且中间没有任何其他设备介入，那么窃听的风险将会大幅减少。</p><p>这样的情况在一些高安全性、需要严格保密的环境中确实有可能实现，像是军事用途、金融系统内部的特殊通信等。但实现成本非常高。</p><p>且即便完全避免中间设备的参与没有经过加密处理的数据在传输过程中被截获（例如通过物理入侵或电磁信号泄漏），信息同样可能被窃听。</p><p>因此，关键的问题不仅在于是否经过中间设备，而是 <strong>通信的安全性依赖于数据加密技术的有效性</strong>。</p><p>而现代密码学并不依靠机密性，加解密算法都是完全公开的，信息的安全是建立在特定问题的计算复杂度之上。具体来说，就是算法根据输入端计算输出结果，这里耗费的算力资源很小；但根据输出端的结果反过来推算原本的输入，耗费的算力就极其庞大。</p><h2 id="21-对称加密-保证消息机密性"><a href="#2-1-对称加密-保证消息机密性" class="headerlink" title="2.1 对称加密-保证消息机密性"></a>2.1 对称加密-保证消息机密性</h2><p>由于在HTTP中一切信息都是明文传输，一旦发生窃听，第三个人立马就能读懂其中的含义。</p><p>那如果信息发送者Alice 将内容加密，Bob 收到信息解密后再阅读内容， 则第三方即使窃听到传输内容，也读不懂，是不是就可以保证传输内容不泄漏了？</p><p>是的，这是一个思路，这里可以使用高效的对称加密算法算法。</p><h2 id="22-非对称加密算法-安全传输密钥"><a href="#2-2-非对称加密算法-安全传输密钥" class="headerlink" title="2.2 非对称加密算法-安全传输密钥"></a>2.2 非对称加密算法-安全传输密钥</h2><p>在使用对称加密算法高效加密明文时保证机密性的思路中，存在一个问题， 这个密钥如何被Alice 和Bob 双方安全共享。</p><p>假设Alice 生成了密钥，Bob 也必须获取到才能进行解密，否则就和窃听者一样即使拿到邮件内容也无法得知其含义。</p><p>Bob 如何获取到密钥，无非就2种方式</p><ol><li>俩人见面，线下给密钥</li><li>网络传输密钥</li></ol><p>本文我们可以规定一切行为都发生在网络上， 那么通过网络传输密钥时依然是明文，也就是说窃听者可以通过和窃听邮件内容一样的方式获取到明文传递的密钥。</p><p>关于密钥被窃听有2种应对方式</p><ol><li>钻牛角尖思考，到底有什么方法可以让密钥安全传输呢 - 基本无解，有解的话直接传输内容本身就可以了</li><li>换个思路，即使密钥被窃听到也不影响内容加密传输是不是也可以 。 那这里就可以非对称加密算法</li></ol><p>非对称加密算法 有2种用法</p><ol><li>公钥加密，私钥解密 - 对应加密场景</li><li>私钥加密，公钥解密 -  对应数字签名场景</li></ol><p>在本小节中，先关注<strong>公钥加密、私钥解密</strong>这种场景，</p><p>如下图， 如果Alice 想给Bob 发送加密消息，需要Bob先将他的公钥通过网络明文传输给Alice,  这个过程公钥即使被窃听到也没关系</p><p>因为窃听者没有解密私钥，后面即使窃听到Alice 发给Bob 的加密信息，也无法解密用公钥加密后的内容。</p><img src="/79674443/4.png" class><h2 id="23-混合加密系统-既安全又高效"><a href="#2-3-混合加密系统-既安全又高效" class="headerlink" title="2.3 混合加密系统-既安全又高效"></a>2.3 混合加密系统-既安全又高效</h2><p>根据前面的内容可以看出</p><ol><li>对称加密算法可以使用分组方式，对大量明文进行高效加密，但是其密钥本身的安全传输是一个问题</li><li>非对称密钥 很好的解决了对称加密密钥被窃取的问题，但是它又不适合用户对大量明文进行加密</li></ol><p>可以考虑将二者的优点结合形成混合加密系统。</p><p><strong>混合加密系统</strong>通过利用非对称加密的强大安全性和对称加密的高效性，能够实现既安全又高效的数据加密。</p><p>其核心思想是分为2步</p><ol><li><strong>密钥交换</strong>：使用非对称加密（如RSA或ECC）来加密和交换对称加密密钥。由于非对称加密仅用于加密短小的对称密钥（如AES的256位密钥），计算开销较小，速度相对可接受。</li><li><p><strong>数据加密</strong>：一旦通过非对称加密安全地交换了对称密钥，实际的数据传输就使用高效的对称加密算法（如AES）。对称加密的加密速度非常快，能够处理大量的数据，适用于文件加密、实时视频流加密等场景。</p></li><li><p><strong>安全性和性能的平衡</strong>：这种方法兼具了非对称加密的安全性（用于密钥交换）和对称加密的效率（用于大数据加密），是现代安全通信的基础。HTTPS、SSH、PGP等安全协议都采用了这种混合加密模型。</p></li></ol><h2 id="24-消息认证码-既防篡改又能认证"><a href="#2-4-消息认证码-既防篡改又能认证" class="headerlink" title="2.4 消息认证码-既防篡改又能认证"></a>2.4 消息认证码-既防篡改又能认证</h2><p>防篡改和认证性质的实现见上文。</p><h2 id="25-数字签名-无法否认且能认证"><a href="#2-5-数字签名-无法否认且能认证" class="headerlink" title="2.5 数字签名-无法否认且能认证"></a>2.5 数字签名-无法否认且能认证</h2><p>如果Alice使用Bob 的公钥加密消息发送给Bob, 如何能确定这条消息一定是Alice发出的，因为窃听者同样可以拿到Bob 的公钥，然后以Alice 的口吻向Bob 发送消息。Bob 如何确定一条消息一定是Alice 发出的， 而不是窃听者冒充Alice 发出的。</p><p>这里可以使用非对称加密：私钥加密，公钥验证这个流程 ， 完成数字签名的功能，来保证消息一定是Alice 发出的， 且Alice 无法否认自己发出过这条消息。</p><p>关于私钥加密，公钥验证为什么就能保证消息就一定是私钥持有者发出的</p><p>当然，物理世界中私钥被窃取，在加密这样的网络世界是管不到的</p><h2 id="26-中间人攻击下公钥的认证问题"><a href="#2-6-中间人攻击下，公钥的认证问题" class="headerlink" title="2.6 中间人攻击下，公钥的认证问题"></a>2.6 中间人攻击下，公钥的认证问题</h2><p>由于非对称加密中公钥需要通过网络明文传输给Alice， 那么就是可以被窃听获取到的。</p><p>此时如果有一个主动攻击者Molly 自己也生成一个非对称加密密钥对， 他在窃取到Bob传递给Alice 后公钥后， 篡改成自己的公钥发送非Alice， 此时Alice  没有什么手段可以判断这个公钥到底是不是Bob, 他如果直接拿来加密内容，传输给Bob,  Molly 继续窃取这个内容，由于Alice实际用来加密的公钥匙Molly 的， 此时Molly 就可以用自己的私钥进行解密获取具体内容。</p><img src="/79674443/5.png" class><p><strong>中间人攻击的风险</strong>：</p><ul><li><strong>公钥篡改</strong>：如果 Alice 想与 Bob 通信，但攻击者（Mallory）冒充 Bob 拦截了 Alice 请求的公钥，并替换为自己的公钥。Alice 会误以为她在使用 Bob 的公钥加密信息，但实际上传输的对称密钥被 Mallory 用自己的私钥解密。</li><li><strong>认证性问题</strong>：Alice 需要确认她收到的公钥<strong>确实是 Bob 的</strong>，而不是来自攻击者。因此，<strong>公钥的认证</strong>是一个关键问题。</li></ul><p>基于以上解释，你应该可以理解， 公钥的“安全配送”并不是像对称加密密钥的安全配送那样，不被人窃取， 而是在明文传输的前提下，即使被窃取，收到公钥的人也要能识别出来，也就是说Alice 在收到公钥后，要能100%确定 这个公钥一定是Bob 的， 如果被中间人窃听篡改了，Alice 需要识别出来，不用这个公钥。</p><p>如果仍然考虑公钥的网络安全传输问题，将继续陷入“如果能安全传输密钥，那就肯定能安全传输明文”的死循环。</p><p>为了打破这个循环，引入<strong>第三方可信机构</strong>成为了解决方案的关键。具体来说，这一机构就是<strong>证书颁发机构（CA, Certificate Authority）</strong>，它的作用是通过公钥基础设施（PKI, Public Key Infrastructure）来验证和管理公钥，确保公钥的传输是安全的。</p><h3 id="261-ca-公钥的数字签名"><a href="#2-6-1-CA-公钥的数字签名" class="headerlink" title="2.6.1 CA-公钥的数字签名"></a>2.6.1 CA-公钥的数字签名</h3><p>数字证书认证机构(CA,Certificate Authority)。数字证书认证机构处于客户端与服务器双方都可信赖的第三方机构的立场上。</p><ul><li><strong>证书颁发机构（CA）如何工作</strong>：<ol><li><strong>身份验证</strong>：Bob 向 CA 提交身份信息和公钥，申请一个<strong>数字证书</strong>。CA 验证 Bob 的身份，确认公钥确实属于 Bob。这个身份验证可以是电话、邮箱等方式</li><li><strong>签发证书</strong>：CA使用自己的私钥 对 Bob 的身份和公钥进行数字签名，生成一个<strong>数字证书</strong>，并将该证书发给 Bob。证书中包含 Bob 的身份信息、他的公钥，以及 CA 的数字签名。</li><li><strong>公钥验证</strong>：Alice 在与 Bob 通信时，收到 Bob 提供的数字证书。她可以使用 CA 的公钥验证证书的签名，确保她获得的公钥<strong>没有被篡改</strong>，从而防止中间人攻击。即使攻击者在传输过程中试图篡改公钥，Alice 也能通过验证 CA 的签名识别出这种篡改。</li></ol></li></ul><h3 id="262-ca公钥的获取-操作系统和浏览器预装的根证书"><a href="#2-6-2-CA公钥的获取-操作系统和浏览器预装的根证书" class="headerlink" title="2.6.2 CA公钥的获取-操作系统和浏览器预装的根证书"></a>2.6.2 CA公钥的获取-操作系统和浏览器预装的根证书</h3><p>在<strong>证书颁发机构（CA）</strong> 的工作流程中，Alice 需要使用 CA 的<strong>公钥</strong>来验证 Bob 的数字证书是否有效，从而确保 Bob 的公钥未被篡改。那么Alice 如何获取 CA 的公钥呢？<br>实际上，Alice 不需要主动从网络上获取 CA 的公钥，因为这样会产生安全隐患。相反，CA 的公钥通常通过<strong>操作系统和浏览器预装的根证书</strong></p><p>现代操作系统和浏览器（如 Windows、macOS、Linux，Chrome、Firefox、Safari 等）通常都会预装一组<strong>可信任的根证书</strong>，这些根证书由全球广泛认可的证书颁发机构（CA）提供。每个根证书都包含 CA 的<strong>公钥</strong>，并被操作系统或浏览器标记为可信任的。</p><p><strong>根证书的作用：</strong></p><ul><li><strong>CA 的身份认证</strong>：根证书是 CA 的<strong>自签名证书</strong>，它包含 CA 的身份信息和公钥，以及 CA 自己用其私钥对证书签名的数字签名。因为这些证书是由操作系统或浏览器厂商直接植入的，Alice 可以信任这些根证书中的公钥。</li><li><strong>验证链证书的可信度</strong>：当 Alice 收到 Bob 的数字证书时，Bob 的证书通常是由中间 CA 签发的，而中间 CA 的证书会由上一级的 CA 签发，最终形成一个<strong>信任链</strong>。通过验证链中的证书，Alice 可以逐级追溯到操作系统或浏览器中内置的根证书，从而验证 Bob 的证书。</li></ul><p><strong>预装根证书的好处：</strong></p><ul><li><strong>安全性</strong>：根证书是直接通过操作系统和浏览器厂商提供的，因此这些公钥的获取过程是安全的，不需要通过网络传输，避免了中间人攻击的风险。</li><li><strong>自动验证</strong>：当 Alice 在浏览器中访问一个网站（如 Bob 的网站）时，浏览器会自动使用系统或浏览器中的根证书来验证该网站证书的可信度，无需 Alice 手动获取或验证 CA 的公钥。</li></ul><h1 id="3-密钥交换方法"><a href="#3-密钥交换方法" class="headerlink" title="3. 密钥交换方法"></a>3. 密钥交换方法</h1><p>通过CA 解决了公钥的认证问题，下面来总结一下，对称加密算法中密钥的安全传输问题。<br>密钥交换一般有以下4种方式</p><ol><li>公钥密码交换算法</li><li>Diffie-Hellman 密钥交换算法</li><li>使用密钥分配中心</li><li>事先共享密钥</li></ol><h2 id="31-公钥密码交换算法"><a href="#3-1-公钥密码交换算法" class="headerlink" title="3.1 公钥密码交换算法"></a>3.1 公钥密码交换算法</h2><p>即我们在前面介绍的混合加密系统中，在公钥认证问题解决的前提下， 通过非对称加密算法加密传输密钥</p><h2 id="32-diffie-hellman-密钥交换"><a href="#3-2-Diffie-Hellman-密钥交换" class="headerlink" title="3.2 Diffie-Hellman 密钥交换"></a>3.2 Diffie-Hellman 密钥交换</h2><p>Diffie-Hellman（DH）密钥交换协议是一种<strong>安全密钥交换</strong>的方法，它允许两个不相互信任的实体在不预先共享密钥的情况下，通过一个不安全的信道生成共享的加密密钥。该方法依赖于特定的数学问题（如大整数的离散对数问题），这些问题在现有计算能力下很难快速破解，因此确保了密钥交换的安全性。</p><ol><li><strong>公用参数选择</strong>：首先，通信双方A和B选择一个公共的素数<code>p</code>和一个基数<code>g</code>，这些值可以在公共信道中传输，无需保密。</li><li><strong>生成私钥</strong>：双方分别选择一个私有的随机数<code>a</code>（A的私钥）和<code>b</code>（B的私钥），这些值不会在通信中公开。</li><li><strong>计算共享值</strong>：A计算<code>A_value = g^a mod p</code>，B计算<code>B_value = g^b mod p</code>。然后A和B将各自的计算结果通过公共信道交换</li></ol><h2 id="33-事先共享密钥pre-shared-key-psk"><a href="#3-3-事先共享密钥（Pre-shared-Key-PSK）" class="headerlink" title="3.3  事先共享密钥（Pre-shared Key, PSK）"></a>3.3  事先共享密钥（Pre-shared Key, PSK）</h2><p>事先共享密钥（PSK）是一种传统的加密方法。在这种方式中，通信双方需要<strong>预先通过某种安全途径</strong>共享一个密钥。这个密钥可以通过线下物理方式进行传输，例如通过安全的信道、面对面的会晤、信件或电话。这种方式通常用于小范围或高度安全的环境中，例如在公司内部网络、军事通信或物联网设备之间。</p><ol><li><strong>密钥生成</strong>：首先，通信的双方需要决定一个共享的加密密钥。这通常是在一个安全的环境中产生的。</li><li><strong>线下共享</strong>：这个密钥不能通过不安全的渠道传输，因此通常通过物理方式或事先商定的安全信道传递。双方在建立通信前必须获取该密钥。</li><li><strong>使用密钥加密通信</strong>：一旦双方获得密钥，通信过程便使用该密钥进行加密和解密。通常是使用对称加密算法（如AES或DES），因为这些算法对加密和解密使用的是同一个密钥。</li><li><strong>更新或更换密钥</strong>：如果密钥有泄露的风险，双方需要通过安全的方式再次共享新的密钥。</li></ol><h2 id="34-使用密钥分配中心key-distribution-center-kdc"><a href="#3-4-使用密钥分配中心（Key-Distribution-Center-KDC）" class="headerlink" title="3.4  使用密钥分配中心（Key Distribution Center, KDC）"></a>3.4  使用密钥分配中心（Key Distribution Center, KDC）</h2><p>密钥分配中心（KDC）是一种集中化的密钥共享方式，适用于大规模网络环境，尤其是<strong>对称加密</strong>的环境中。KDC 是一个专用的服务器，负责管理和分发加密密钥。在这种架构中，参与通信的各方不需要直接相互共享密钥，而是通过一个可信的第三方KDC来管理密钥的分发和验证。这种方式可以有效减少直接共享密钥的复杂性和安全风险。</p><ol><li><strong>注册</strong>：首先，每个通信方需要在KDC注册，KDC为每个实体分配一个唯一的密钥（通常是与KDC共享的会话密钥）。</li><li><strong>请求通信密钥</strong>：当两个实体（比如A和B）想要通信时，A会向KDC请求与B通信所需的会话密钥。</li><li><strong>密钥分发</strong>：KDC生成一个新的会话密钥，并通过<strong>加密的方式分别传递给A和B</strong>。例如，KDC会用A的密钥加密会话密钥并发送给A，用B的密钥加密会话密钥并发送给B。</li><li><strong>安全通信</strong>：在获得会话密钥后，A和B可以使用该密钥进行加密通信。</li><li><strong>密钥刷新</strong>：KDC可以在需要时生成新的密钥，并通知通信双方。</li></ol><p>优点</p><ul><li><strong>安全集中管理</strong>：所有密钥的管理和分配由一个可信的中心控制，简化了密钥管理过程，减少了潜在的泄露风险。</li><li><strong>扩展性好</strong>：在大规模网络中，无需每对通信方直接共享密钥，可以由KDC动态生成和分发密钥。</li><li><strong>灵活性高</strong>：可以灵活地控制密钥的生效时间和使用权限，提高安全性。</li></ul><p>缺点</p><ul><li><strong>单点故障问题</strong>：KDC 作为系统中的核心，如果KDC出现故障，整个系统将无法正常工作，甚至可能导致所有通信被中断。</li><li><strong>需要高度信任的第三方</strong>：通信双方必须完全信任KDC，任何KDC的漏洞或恶意行为都会破坏系统的安全性。</li><li><strong>性能瓶颈</strong>：KDC 需要处理大量的密钥分发请求，可能会成为系统的性能瓶颈。</li></ul><h1 id="4-网络传输安全层-ssltls"><a href="#4-网络传输安全层-SSL-TLS" class="headerlink" title="4. 网络传输安全层 -SSL/TLS"></a>4. 网络传输安全层 -SSL/TLS</h1><p>由以上分步骤一一解决HTTP  明文传输中存在的问题可以看出，解决过程是复杂且繁琐的， 但是沿用网络分层的概念，在传输层和应用层之间抽象出一个安全层，可以隐藏这个复杂且繁琐的过程， 这个安全层就是我们熟悉的SSL/TLS。</p><p>SSL/TLS 是用于保护通信安全的协议，旨在提供<strong>机密性</strong>（通过加密）、<strong>完整性</strong>（防止数据篡改）、<strong>身份认证</strong>（确认通信双方的身份）和<strong>不可否认性</strong>（防止消息发送者否认发送过消息）。这些目标依赖于多种密码学工具的有机组合。</p><p>加密传输的HTTPs =HTTP + SSL/TLS</p><h2 id="41-ssltls-发展历史"><a href="#4-1-SSL-TLS-发展历史" class="headerlink" title="4.1 SSL/TLS 发展历史"></a>4.1 SSL/TLS 发展历史</h2><p>构建传输安全层这个想法，几乎可以说是和万维网的历史一样长，早在 1994 年，就已经有公司开始着手去实践了：</p><ol><li>1994 年，网景（Netscape）公司开发了 SSL 协议（Secure Sockets Layer）的 1.0 版，这是构建传输安全层的起源，但是 SSL 1.0 从未正式对外发布过。</li><li>1995 年，Netscape 把 SSL 升级到 2.0 版，正式对外发布，但是刚刚发布不久，就被发现有严重漏洞，所以并未大规模使用。</li><li>1996 年，修补好漏洞的 SSL 3.0 对外发布，这个版本得到了广泛的应用，很快成为 Web 网络安全层的事实标准。</li><li>1999 年，互联网标准化组织接替网景公司，将 SSL 改名为 TLS（Transport Layer Security），随即就形成了传输安全层的国际标准。第一个正式的版本是RFC 2246定义的 TLS 1.0，该版 TLS 的生命周期极长，直到 2020 年 3 月，主流浏览器（Chrome、Firefox、IE、Safari）才刚刚宣布同时停止 TLS 1.0/1.1 的支持。而讽刺的是，由于停止后许多政府网站被无法被浏览，此时又正值新冠病毒的爆发期，Firefox 紧急发布公告宣布撤回该改动，因此目前 TLS 1.0 的生命还在顽强延续。</li><li>2006 年，TLS 的第一个升级版 1.1 发布（RFC 4346），但它除了增加对 CBC 攻击的保护外，几乎没有任何改变，沦为了被遗忘的孩子，当时也很少有人会使用 TLS 1.1，甚至 TLS 1.1 根本都没有被提出过有啥已知的协议漏洞。</li><li>2008 年，TLS 1.1 发布 2 年之后，TLS 1.2 标准发布（RFC 5246），迄今超过 90% 的互联网 HTTPS 流量都是由 TLS 1.2 所支持的，现在我们仍在使用的浏览器几乎都完美支持了该协议。</li><li>2018 年，最新的 TLS 1.3（RFC 8446）发布，比起前面版本相对温和的升级，TLS 1.3 做出了一些激烈的改动，修改了从 1.0 起一直没有大变化的两轮四次（2-RTT）握手，首次连接仅需一轮（1-RTT）握手即可完成；在有连接复用支持的时候，甚至可以把 TLS 1.2 原本的 1-RTT 下降到 0-RTT，显著提升了访问速度。</li></ol><p>SL/TLS 工作在<strong>传输层</strong>和<strong>应用层</strong>之间的安全层。它能够为 HTTP（即 HTTPS）、SMTP、FTP 等应用层协议提供加密和身份验证功能。通过 SSL/TLS，应用层的通信变得安全透明，开发者无需在应用层实现复杂的安全机制，只需使用 SSL/TLS 来保护通信。</p><img src="/79674443/6.png" class><h2 id="42-ssltls-工作流程"><a href="#4-2-SSL-TLS-工作流程" class="headerlink" title="4.2 SSL/TLS 工作流程"></a>4.2 SSL/TLS 工作流程</h2><p><strong>SSL/TLS 协议</strong>通过将密码学工具箱中的六个关键工具（对称加密、非对称加密、消息认证码、数字签名、散列函数、密钥交换协议）有机结合，提供了高效的加密通信解决方案。这些工具的具体实现可以根据实际情况灵活替换，如选择不同的加密套件。SSL/TLS 保障了传输的机密性、完整性和身份认证，为上层应用层协议（如 HTTP、SMTP 等）提供了安全通信的基础。</p><p>现在广泛使用的是TLS 1.2，下面将以其为基础介绍一些袭击嗯</p><h2 id="43-tls协议分层结构"><a href="#4-3-TLS协议分层结构" class="headerlink" title="4.3 TLS协议分层结构"></a>4.3 TLS协议分层结构</h2><img src="/79674443/7.png" class><p>TLS 协议 由 TLS 记录协议和TLS 握手协议组成，可以将其理解为握手阶段和通信阶段。</p><p>TLS 握手协议中的握手协议负责双方的身份认证（即基于公钥的CA）、协商通信双方间的密码算法、密钥。</p><p>记录协议负责数据根据协商出密钥进行加密、数据认证</p><h2 id="44-握手协议"><a href="#4-4-握手协议" class="headerlink" title="4.4 握手协议"></a>4.4 握手协议</h2><img src="/79674443/8.png" class><p>根据《图解密码技术》一书提供的流程，将进行握手阶段的概括描述：</p><ol><li><strong>客户端问候（Client Hello）</strong>：<ul><li>客户端发送支持的 SSL/TLS 版本、加密套件列表（包括对称加密算法、散列算法、密钥交换方法等）和随机数 <code>ClientRandom</code>。</li></ul></li><li><strong>服务器问候（Server Hello）</strong>：<ul><li>服务器选择一个客户端支持的加密套件，并生成自己的随机数 <code>ServerRandom</code>，然后将这些信息返回客户端。</li><li>服务器发送数字证书（包含服务器的公钥），用于证明其身份。</li></ul></li><li><p><strong>客户端密钥交换</strong>：</p><ul><li>客户端生成一个<strong>预主密钥（Pre-Master Secret）</strong>，然后根据使用的密钥交换算法， 使用 <strong>RSA</strong> 时：客户端会用服务器的公钥加密预主密钥，并发送给服务器。</li></ul></li><li><p><strong>生成主密钥</strong>：</p><ul><li>客户端和服务器使用预主密钥，以及之前生成的 <code>ClientRandom</code> 和 <code>ServerRandom</code>，通过伪随机函数（PRF）生成<strong>主密钥（Master Secret）</strong>。</li></ul></li><li><strong>握手完成</strong>：<ul><li>客户端和服务器确认握手成功，握手阶段结束。此时，双方已经协商出了用于后续加密通信的对称密钥。</li></ul></li></ol><p><strong>握手阶段的作用</strong>：</p><ul><li><strong>身份认证</strong>：通过服务器的数字证书，客户端确认服务器的身份。如果需要双向认证，客户端也可能提供自己的证书。</li><li><strong>密钥协商</strong>：根据主密钥可以生成对称加密需要的密钥、消息认证码需要的密钥。</li></ul><h2 id="45-记录协议-通信阶段"><a href="#4-5-记录协议-通信阶段" class="headerlink" title="4.5 记录协议-通信阶段"></a>4.5 记录协议-通信阶段</h2><p>握手阶段完成后，SSL/TLS 进入<strong>通信阶段</strong>，双方开始通过协商好的对称密钥进行安全通信。此时，所有的消息都会使用对称密钥加密，并通过消息认证码（MAC）来保证数据的完整性和防篡改。</p><ol><li><strong>加密数据传输</strong>：<ul><li>客户端和服务器使用协商生成的<strong>对称密钥</strong>（例如 AES、ChaCha20）对传输的数据进行加密，确保通信内容的<strong>机密性</strong>。</li></ul></li><li><strong>消息完整性验证</strong>：<ul><li>每条加密的数据都会附带一个 <strong>MAC（消息认证码）</strong>，接收方使用相同的对称密钥计算 MAC 来验证数据的完整性，确保数据未被篡改。</li></ul></li><li><strong>数据传输和解密</strong>：<ul><li>双方在通信过程中反复使用对称加密进行数据的加密和解密操作。加密的数据经过传输后，接收方使用对称密钥解密消息并验证其完整性。</li></ul></li></ol><p><strong>SSL/TLS 并不会对每条发送的消息进行数字签名</strong>。数字签名仅在 <strong>握手阶段</strong> 用于身份认证和密钥协商，而 <strong>数据传输阶段</strong> 主要依赖 <strong>对称加密和 MAC</strong> 来确保数据的机密性和完整性。这样设计是为了在保证安全性的前提下，最大程度提升传输效率。</p><h2 id="46-tls-中的密钥交换"><a href="#4-6-TLS-中的密钥交换" class="headerlink" title="4.6 TLS 中的密钥交换"></a>4.6 TLS 中的密钥交换</h2><p>在HTTP 明文传输的问题 一节中，我的表达是使用非对称加密算法直接加密传输共享密钥，但其实在TLS的实际工作中并不直接传输密钥， 从对握手协议的描述中可以看出，</p><ol><li>在TLS1.2 中， 使用RSA加密传输的是预主密码。然后客户端和服务器基于这个共享的预主密钥，再结合双方各自生成的随机数，使用规定的算法生成主密码，最后基于主密码生成对称加密需要的密钥、消息认证码需要的密钥。</li><li>如果使用<strong>Diffie-Hellman 密钥交换算法</strong>, 则不需要使用非对称密钥加密传递信息，双方通过数学公式和公开值计算出相同的共享密钥，从而避免直接传输密钥相关信息并提供更强的安全性。</li><li>在TLS1.3中，相比 TLS 1.2，TLS 1.3 默认采用 <strong>ECDHE（椭圆曲线 Diffie-Hellman 临时密钥交换）</strong>，这一算法相比传统的 RSA 密钥交换或静态的 Diffie-Hellman 提供了更高的安全性和效率。ECDHE 通过使用临时密钥对，确保即使未来服务器的私钥被泄露，过去的通信内容仍然是安全的。前向安全性通过每次通信协商临时的 Diffie-Hellman 公私钥对来实现，即使私钥泄露，之前的通信记录也无法被解密。（这是前向安全性）</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文参考《图解密码技术》， 从HTTPs 为什么比HTTP 安全的角度梳理多个和密码相关的知识点， 希望对你有帮助。&lt;/p&gt;
&lt;p&gt;以下内容介绍，均基于Alice 向Bob 发送邮件为基础进行介绍&lt;br&gt;&lt;img src=&quot;/79674443/1.png&quot; class&gt;&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>不懂前端？用cursor 1小时也能写出一个可用的浏览器插件</title>
    <link href="http://example.com/62d611ce/"/>
    <id>http://example.com/62d611ce/</id>
    <published>2024-09-04T11:32:33.000Z</published>
    <updated>2024-09-05T11:35:35.882Z</updated>
    
    <content type="html"><![CDATA[<p>这2周，cursor 因为下面<a href="https://x.com/rickyrobinett/status/1825581674870055189">这条推特</a>,又爆火了一波</p><img src="/62d611ce/1.png" class><h1 id="cursor-是什么"><a href="#cursor-是什么" class="headerlink" title="cursor 是什么"></a>cursor 是什么</h1><p>根据<a href="https://www.cursor.com/">官网</a>的介绍， cursor  is  a  AI Code Editor。 它可以辅助你更好得进行代码开发，甚至根据自然语言完成开发。<br><img src="/62d611ce/2.png" class></p><h1 id="用cursor-实现一个浏览器插件"><a href="#用cursor-实现一个浏览器插件" class="headerlink" title="用cursor 实现一个浏览器插件"></a>用cursor 实现一个浏览器插件</h1><p>现在有cursor 2周免费体验时间，2周需要每月需要付费20美元。</p><p>作为一名后端工程师，我对前端的掌握程度就是能看懂一点点，但是几乎没有实际编写的能力。所以准备用cursor 完成一个  chrome 浏览器插件来体验AI 编程。</p><p>由于本人是一个网页目录的重度使用者，所以这次准备用它来实现了一个 网页目录生成器。</p><p>关于网页目录生成器，目前已经有很多成熟的插件可以使用。这次用cursor 来实现这个不算新的idea, 是因为暂时没有其他更好的idea,所以用这个来体验一下。</p><h2 id="用自然语言提出要求"><a href="#用自然语言提出要求" class="headerlink" title="用自然语言提出要求"></a>用自然语言提出要求</h2><p>如下图，我用自然语言描述了想要实现的插件功能</p><img src="/62d611ce/3.png" class><p>然后cursor 就给出一个插件项目完整的代码。</p><p>如果你完全不懂chrome 插件开发，一定会为这一步感到震惊。<br>如果你懂一点chrome 插件开发， 那更能意识到它对不懂chrome 开发的人节省了多少前置知识的准备时间。<br><img src="/62d611ce/4.png" class></p><h2 id="用报错信息与cursor-沟通"><a href="#用报错信息与cursor-沟通" class="headerlink" title="用报错信息与cursor 沟通"></a>用报错信息与cursor 沟通</h2><p>上面给出的代码实际往往不能一步到位，我在开发者模式下导入生成的代码。<br><img src="/62d611ce/5.png" class><br>随便找了一个网页生成目录，出现了3个报错信息，我依次将报错信息提供给cursor 修改代码</p><img src="/62d611ce/6.png" class><p>修改后代码已经完成了基本功能，生成了如下目录<br><img src="/62d611ce/7.png" class></p><h2 id="功能优化"><a href="#功能优化" class="headerlink" title="功能优化"></a>功能优化</h2><p>完成基本功能后，让cursor 以此为基础完成进一步功能，比如比如点击目录跳转到相应内容、网页滑动时对应目录高亮显示、显示内容的细节</p><h3 id="目录点击跳转"><a href="#目录点击跳转" class="headerlink" title="目录点击跳转"></a>目录点击跳转</h3><img src="/62d611ce/8.png" class><img src="/62d611ce/9.png" class><h3 id="标题高亮"><a href="#标题高亮" class="headerlink" title="标题高亮"></a>标题高亮</h3><img src="/62d611ce/10.png" class><img src="/62d611ce/11.png" class><h3 id="标题展示差异"><a href="#标题展示差异" class="headerlink" title="标题展示差异"></a>标题展示差异</h3><img src="/62d611ce/12.png" class><img src="/62d611ce/13.png" class><img src="/62d611ce/14.png" class><p>到这里，一个基本可用的网页目录生成器chrome 插件已经完成， 当然也可以提出更多的要求，比如自由拖动等。</p><h1 id="chatgpt-写代码-vs-cursor-写代码"><a href="#chatGPT-写代码-vs-cursor-写代码" class="headerlink" title="chatGPT 写代码 vs cursor 写代码"></a>chatGPT 写代码 vs cursor 写代码</h1><p>去年在chatGPT3.5 的帮助下，曾经开发过一个女书插件。</p><p>但是它不能根据我的描述生成完整的代码，为了调试，我依然需要去学习一些关于chrome 开发的知识，虽然chatGPT 当然可以帮助我提高学习这些知识的速度。</p><p>但是在错误调试的过程中比较痛苦， 在修改代码的过程中也需要不断的复制粘贴。</p><p>对比下来，用 cursor 写代码，一个几乎完全不懂编程的人也是可以实现一个功能的， cursor 确实强。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这2周，cursor 因为下面&lt;a href=&quot;https://x.com/rickyrobinett/status/1825581674870055189&quot;&gt;这条推特&lt;/a&gt;,又爆火了一波&lt;/p&gt;
&lt;img src=&quot;/62d611ce/1.png&quot; class&gt;
&lt;h1</summary>
      
    
    
    
    
    <category term="AI" scheme="http://example.com/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>在Spring事务管理下，使用Synchronized   为什么会出现并发问题</title>
    <link href="http://example.com/2a483461/"/>
    <id>http://example.com/2a483461/</id>
    <published>2024-07-23T09:58:56.000Z</published>
    <updated>2024-10-25T07:12:19.609Z</updated>
    
    <content type="html"><![CDATA[<p>理解了<a href="https://sunyan.xyz/1a0f7094/">Spring事务实现原理</a>， 现在来解决一个实际问题。</p><p>在实际业务开发中，我们经常会遇到在一个事务内执行多个业务操作保证原子性， 同时希望这段逻辑是并发安全的。</p><p>比如在商品售卖场景中，非常重要的一件事就是防止超卖，且要保证多个业务操作之间的原子性。<br>以下示例代码，明显会出现超卖问题（查询是否有库存时有库存并不代码真正扣减库存时还有库存，假设扣减库存时SQL 中没有乐观锁）<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 查看是商品否有库存</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> getProductCount();</span><br><span class="line">  <span class="keyword">if</span>(count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存为 0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 减库存</span></span><br><span class="line">  productRepository.reductCount();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成订单</span></span><br><span class="line">  createOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么修改该段代码的一个常见思路就是给<code>buy</code>加锁，确保<code>buy</code> 在任意时刻只会被一个线程操作，从而保证库存的正确扣减。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 查看是商品否有库存</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> getProductCount();</span><br><span class="line">  <span class="keyword">if</span>(count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存为 0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 减库存</span></span><br><span class="line">  productRepository.reductCount();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成订单</span></span><br><span class="line">  createOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们想要实现的逻辑是： 加锁-开始事务-执行方法-事务commit-释放锁</p><p>但是这段加锁后的代码，其实际执行效果是，开始事务-（加锁-执行方法-释放锁）- 事务commit。 依然有可能出现</p><p>也就是说在事务commit 之前，synchronized锁就已经释放，其他线程已经可以进入到该段逻辑，读到旧数据的快照库存，发现还有库存然后进行库存扣减。</p><p>如果此时库存为1 ，那么又会出现超卖现象。造成超卖的原因就是事务的开启和提交并不是在 Synchronized 锁定的范围内</p><p>下面就加锁后的代码，其实际执行效果为什么是，开始事务-（加锁-执行方法-释放锁）- 事务commit 进行解释。</p><h1 id="synchronized关键字"><a href="#Synchronized关键字" class="headerlink" title="Synchronized关键字"></a>Synchronized关键字</h1><p><code>Synchronized</code>是Java语言级别的关键字，用于实现线程同步，确保多个线程对共享资源的访问是有序的。它主要通过以下两种方式实现同步：</p><ol><li><strong>同步方法</strong>：在方法声明上使用<code>Synchronized</code>关键字，确保同一时间只有一个线程可以执行该方法。</li><li><strong>同步代码块</strong>：在方法内部使用<code>Synchronized</code>关键字对特定代码块进行同步，指定一个对象锁。</li></ol><p><code>Synchronized</code>仅仅是在JVM层面上对对象加锁，与数据库的锁机制无关。</p><h1 id="基于事务的动态代理对象"><a href="#基于事务的动态代理对象" class="headerlink" title="基于事务的动态代理对象"></a>基于事务的动态代理对象</h1><p>在<a href="https://sunyan.xyz/1a0f7094/">Spring事务实现原理</a>中已经详细介绍过基于事务的动态代理对象的生成和执行目标方法的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// 处理标准事务管理， 这是本次重点关心的</span></span><br><span class="line"><span class="type">PlatformTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> asPlatformTransactionManager(tm);</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"><span class="comment">// 如果事务属性为null或者事务管理器不支持回调</span></span><br><span class="line"><span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line"><span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line"><span class="comment">// 则执行标准的事务边界控制（即通过`getTransaction`和`commit/rollback`调用）。</span></span><br><span class="line"><span class="comment">//开始一个新的事务或者加入现有的事务。（如果有必要）</span></span><br><span class="line"><span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line">Object retVal;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 执行目标方法，这是一个环绕通知，通常会导致目标对象的方法被调用。</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// 如果方法抛出异常，调用`completeTransactionAfterThrowing`方法来处理事务回滚，并重新抛出异常。</span></span><br><span class="line">completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// - 在finally块中调用`cleanupTransactionInfo`来清理事务信息。</span></span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line"><span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line"><span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> txInfo.getTransactionStatus();</span><br><span class="line"><span class="keyword">if</span> (status != <span class="literal">null</span> &amp;&amp; txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果以上信息可以看出事务是在代理对象中开始和结束的， 但是锁是加在目标对象方法上的，也就是说只有在真正执行目标方法时才会加锁。</p><p>总结一句话， 就是事务的开启与提交并不是在 加锁范围内的，锁在事务的范围内就释放了，所以会出现加锁锁不住的问题。要解决就应该确保 事务的开启与提交在锁的范围内。</p><p>加ReentrantLock 锁也是同样的道理</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><h2 id="使用数据库乐观锁"><a href="#使用数据库乐观锁" class="headerlink" title="使用数据库乐观锁"></a>使用数据库乐观锁</h2><p>乐观锁通过版本号机制控制并发，在更新数据时检查版本号是否一致，防止并发更新导致的数据不一致问题。</p><h2 id="使用悲观锁"><a href="#使用悲观锁" class="headerlink" title="使用悲观锁"></a>使用悲观锁</h2><p>悲观锁在读取数据时加锁，确保在事务执行期间其他事务无法并发访问和修改被锁定的数据。通常通过数据库的 <code>SELECT FOR UPDATE</code> 语句实现。</p><h2 id="扩大加锁范围"><a href="#扩大加锁范围" class="headerlink" title="扩大加锁范围"></a>扩大加锁范围</h2><p>将加锁范围扩大到事务开启之前，确保在事务开始之前就获取到锁。<br>在进入事务管理逻辑之前就获得锁，从而避免并发问题。<br>具体做法 可以将<code>synchronized</code>关键字应用于一个外层方法，然后在该方法内调用实际的事务方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外层加锁方法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buySynchronized</span><span class="params">(String productName, <span class="type">int</span> quantity)</span> &#123; </span><br><span class="line"><span class="comment">// 调用实际事务方法 </span></span><br><span class="line">buy(productName, quantity); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buy</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 查看是商品否有库存</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> getProductCount();</span><br><span class="line">  <span class="keyword">if</span>(count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存为 0&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 减库存</span></span><br><span class="line">  productRepository.reductCount();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成订单</span></span><br><span class="line">  createOrder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意-self-invocation"><a href="#注意-self-invocation" class="headerlink" title="注意 self-invocation"></a>注意 self-invocation</h3><p><strong>Self-invocation</strong> 会导致 <code>@Transactional</code> 注解失效，因为事务是通过代理对象管理的，而在自调用中代理不会介入。所以注意要在A类的buySynchronized方法中调用B类中的事务方法。</p><h2 id="手动管理事务"><a href="#手动管理事务" class="headerlink" title="手动管理事务"></a>手动管理事务</h2><p><a href="https://learnku.com/articles/74980">在加锁的方法内手动管理事务， 确保事务结束后才释放锁</a><br>通过手动管理事务，可以精确控制事务的开始和结束时机，并在加锁之前开启事务，从而确保事务的一致性和线程安全性。</p><p>手动管理事务可以使用Spring的<code>PlatformTransactionManager</code>和<code>TransactionTemplate</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InventoryService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProductRepository productRepository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外层加锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">buySynchronized</span><span class="params">(String productName, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="comment">// 手动管理事务</span></span><br><span class="line">        <span class="type">TransactionTemplate</span> <span class="variable">transactionTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionTemplate</span>(transactionManager);</span><br><span class="line">        transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                performBuy(productName, quantity);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                status.setRollbackOnly();</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内层事务方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performBuy</span><span class="params">(String productName, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="comment">// 查看商品是否有库存</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">count</span> <span class="operator">=</span> getProductCount(productName);</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存为 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 减库存</span></span><br><span class="line">        productRepository.reduceCount(productName, quantity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成订单</span></span><br><span class="line">        createOrder(productName, quantity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer <span class="title function_">getProductCount</span><span class="params">(String productName)</span> &#123;</span><br><span class="line">        <span class="comment">// 查询库存逻辑</span></span><br><span class="line">        <span class="keyword">return</span> productRepository.findStockByProductName(productName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(String productName, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="comment">// 生成订单逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Order created for &quot;</span> + quantity + <span class="string">&quot; of &quot;</span> + productName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;理解了&lt;a href=&quot;https://sunyan.xyz/1a0f7094/&quot;&gt;Spring事务实现原理&lt;/a&gt;， 现在来解决一个实际问题。&lt;/p&gt;
&lt;p&gt;在实际业务开发中，我们经常会遇到在一个事务内执行多个业务操作保证原子性， 同时希望这段逻辑是并发安全的。&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务实现原理</title>
    <link href="http://example.com/1a0f7094/"/>
    <id>http://example.com/1a0f7094/</id>
    <published>2024-07-23T07:55:30.000Z</published>
    <updated>2024-07-25T02:37:02.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-数据库事务"><a href="#1-数据库事务" class="headerlink" title="1.  数据库事务"></a>1.  数据库事务</h1><h2 id="11-数据库事务实现原理"><a href="#1-1-数据库事务实现原理" class="headerlink" title="1.1  数据库事务实现原理"></a>1.1  数据库事务实现原理</h2><p>Spring提供了灵活方便的事务管理功能，但这些功能都是基于底层数据库本身的事务处理机制工作的。要想深入了解Spring的事务管理和配置，有必要先学习数据库事务的基础知识。有需要可以阅读以下文章<br><a href="https://sunyan.xyz/5b064db6/">Intro to 事务</a><br><a href="https://sunyan.xyz/9cd551f5/">Intro to InnoDB事务</a><br><a href="https://sunyan.xyz/b36b0ce9/">InnoDB事务-原子性的实现， undo log</a><br><a href="https://sunyan.xyz/9faedfe0/">InnoDB事务-隔离性的实现, MVCC &amp; 锁</a><br><a href="https://sunyan.xyz/6cb5dc64/">InnoDB事务-持久性的实现， binglog &amp; redo log&amp;undo log</a></p><h2 id="12-jdbc-事务"><a href="#1-2-JDBC-事务" class="headerlink" title="1.2 JDBC 事务"></a>1.2 JDBC 事务</h2><p>在介绍Spring 事务实现原理之前，先来看一下使用JDBC如何实现和数据库交互的事务功能。这可以帮助理解Spring事务的工作原理和优势。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="comment">// JDBC事务代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCTransactionExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/mydatabase&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;username&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;password&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1. 获取数据库连接</span></span><br><span class="line">            conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">            <span class="comment">// 2. 关闭自动提交模式</span></span><br><span class="line">            conn.setAutoCommit(<span class="literal">false</span>);  </span><br><span class="line">            <span class="comment">// 设置事务隔离级别</span></span><br><span class="line">                 conn.setTransactionIsolation(Connection.TRANSACTION_REPEATABLE_READ);</span><br><span class="line">            <span class="comment">// 3. 创建Statement对象</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            <span class="comment">// 4. 执行SQL操作</span></span><br><span class="line">            stmt.executeUpdate(<span class="string">&quot;INSERT INTO accounts (name, balance) VALUES (&#x27;Alice&#x27;, 1000)&quot;</span>);</span><br><span class="line">            stmt.executeUpdate(<span class="string">&quot;INSERT INTO accounts (name, balance) VALUES (&#x27;Bob&#x27;, 1000)&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5. 提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">            System.out.println(<span class="string">&quot;Transaction committed successfully.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// 6. 发生异常时回滚事务</span></span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                    System.out.println(<span class="string">&quot;Transaction rolled back.&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 7. 关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过了解JDBC事务处理的基本步骤，可以更好地理解Spring提供的事务管理功能如何简化和增强这些操作。</p><p>Spring事务管理通过编程式事务 和 声明式事务管理，极大地简化了事务管理的复杂性，并提供了更强大的功能，例如事务传播行为、隔离级别设置等。</p><h1 id="2-spring-事务抽象层"><a href="#2-Spring-事务抽象层" class="headerlink" title="2. Spring 事务抽象层"></a>2. Spring 事务抽象层</h1><img src="/1a0f7094/1.png" class><h2 id="21-transactiondefinition"><a href="#2-1-TransactionDefinition" class="headerlink" title="2.1 TransactionDefinition"></a>2.1 TransactionDefinition</h2><p><code>TransactionDefinition</code> 是一个接口，定义了事务的相关属性，如隔离级别、传播行为、超时时间和只读标志等。这些属性可以通过 XML 配置或注解进行声明配置。</p><ul><li><strong>隔离级别（Isolation Level）</strong>：定义事务在多个事务同时访问数据库时的隔离程度。</li><li><strong>传播行为（Propagation Behavior）</strong>：定义方法如何参与现有事务。</li><li><strong>超时时间（Timeout）</strong>：定义事务必须在多长时间内完成。</li><li><strong>只读（Read-Only）</strong>：标志事务是否只执行读操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionDefinition</span> &#123;  </span><br><span class="line">    <span class="comment">// 事务传播行为</span></span><br><span class="line"><span class="type">int</span> <span class="variable">PROPAGATION_REQUIRED</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">PROPAGATION_SUPPORTS</span> <span class="operator">=</span> <span class="number">1</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">PROPAGATION_MANDATORY</span> <span class="operator">=</span> <span class="number">2</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">PROPAGATION_REQUIRES_NEW</span> <span class="operator">=</span> <span class="number">3</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">PROPAGATION_NOT_SUPPORTED</span> <span class="operator">=</span> <span class="number">4</span>;     </span><br><span class="line"><span class="type">int</span> <span class="variable">PROPAGATION_NEVER</span> <span class="operator">=</span> <span class="number">5</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">PROPAGATION_NESTED</span> <span class="operator">=</span> <span class="number">6</span>;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 事务隔离级别</span></span><br><span class="line"><span class="type">int</span> <span class="variable">ISOLATION_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line"><span class="type">int</span> <span class="variable">ISOLATION_READ_UNCOMMITTED</span> <span class="operator">=</span> <span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> <span class="variable">ISOLATION_READ_COMMITTED</span> <span class="operator">=</span> <span class="number">2</span>; </span><br><span class="line"><span class="type">int</span> <span class="variable">ISOLATION_REPEATABLE_READ</span> <span class="operator">=</span> <span class="number">4</span>; </span><br><span class="line"><span class="type">int</span> <span class="variable">ISOLATION_SERIALIZABLE</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">TIMEOUT_DEFAULT</span> <span class="operator">=</span> -<span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getPropagationBehavior</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> PROPAGATION_REQUIRED;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getIsolationLevel</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> ISOLATION_DEFAULT;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">default</span> <span class="type">int</span> <span class="title function_">getTimeout</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> TIMEOUT_DEFAULT;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">isReadOnly</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">default</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">static</span> TransactionDefinition <span class="title function_">withDefaults</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> StaticTransactionDefinition.INSTANCE;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="22-transactionstatus"><a href="#2-2-TransactionStatus" class="headerlink" title="2.2 TransactionStatus"></a>2.2 TransactionStatus</h2><p><code>TransactionStatus</code> 是一个接口，表示事务的当前状态。它包含了事务的一些控制信息，如是否新建事务、是否只读、是否已完成等。</p><ul><li><strong>isNewTransaction()</strong>：检查是否是一个新的事务</li><li><strong>setRollbackOnly()</strong>：将当前事务标记为仅回滚</li><li><strong>isRollbackOnly()</strong>：检查当前事务是否被标记为仅回滚</li><li><strong>isCompleted()</strong>：检查事务是否已完成（提交或回滚）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionStatus</span> <span class="keyword">extends</span> <span class="title class_">TransactionExecution</span>, SavepointManager, Flushable &#123;</span><br><span class="line"><span class="type">boolean</span> <span class="title function_">hasSavepoint</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">flush</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/1a0f7094/2.png" class><h2 id="23-platformtransactionmanager"><a href="#2-3-PlatformTransactionManager" class="headerlink" title="2.3 PlatformTransactionManager"></a>2.3 PlatformTransactionManager</h2><p><code>PlatformTransactionManager</code> 定义了一组用于事务管理的标准方法，使得不同的事务管理器实现可以通过这个统一的接口进行交互。</p><p><code>PlatformTransactionManager</code> 定义了三种基本的事务操作：</p><ol><li><strong>getTransaction</strong>：获取一个事务</li><li><strong>commit</strong>：提交事务</li><li><strong>rollback</strong>：回滚事务</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;  </span><br><span class="line"> </span><br><span class="line">TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span>  </span><br><span class="line"><span class="keyword">throws</span> TransactionException;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">void</span> <span class="title function_">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionManager</span> &#123;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring 提供了多种 <code>PlatformTransactionManager</code> 的实现，适用于不同的持久化技术。无论使用的是哪种持久化技术，开发人员都可以通过统一的事务管理接口来处理事务。<br><img src="/1a0f7094/3.png" class></p><p>不同持久化技术对应的事务管理器实现类<br><img src="/1a0f7094/4.png" class></p><h3 id="231-datasourcetransactionmanager"><a href="#2-3-1-DataSourceTransactionManager" class="headerlink" title="2.3.1  DataSourceTransactionManager"></a>2.3.1  DataSourceTransactionManager</h3><p><code>DataSourceTransactionManager</code> 是针对 MyBatis 的事务管理器实现。它通过 <code>SqlSessionFactory</code> 与 MyBatis 会话交互，实现事务管理。<br><img src="/1a0f7094/5.png" class></p><img src="/1a0f7094/6.png" class><h2 id="24-spring-编程式事务-transactiontemplate"><a href="#2-4-Spring-编程式事务-TransactionTemplate" class="headerlink" title="2.4 Spring 编程式事务-TransactionTemplate"></a>2.4 Spring 编程式事务-TransactionTemplate</h2><p>Spring为编程式事务管理提供了模板类<code>org.springframework.transaction.support.TransactionTemplate</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTemplate</span> <span class="keyword">extends</span> <span class="title class_">DefaultTransactionDefinition</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">TransactionOperations</span>, InitializingBean &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> PlatformTransactionManager transactionManager;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TransactionTemplate</span><span class="params">(PlatformTransactionManager transactionManager)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.transactionManager = transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TransactionTemplate</span><span class="params">(PlatformTransactionManager transactionManager, TransactionDefinition transactionDefinition)</span> &#123;</span><br><span class="line"><span class="built_in">super</span>(transactionDefinition);</span><br><span class="line"><span class="built_in">this</span>.transactionManager = transactionManager;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTransactionManager</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager transactionManager)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.transactionManager = transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">getTransactionManager</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">execute</span><span class="params">(TransactionCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">      Assert.state(<span class="built_in">this</span>.transactionManager != <span class="literal">null</span>, <span class="string">&quot;No PlatformTransactionManager set&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.transactionManager <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((CallbackPreferringPlatformTransactionManager) <span class="built_in">this</span>.transactionManager).execute(<span class="built_in">this</span>, action);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="built_in">this</span>.transactionManager.getTransaction(<span class="built_in">this</span>);</span><br><span class="line">        T result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          result = action.doInTransaction(status);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">          <span class="comment">// Transactional code threw application exception -&gt; rollback</span></span><br><span class="line">          rollbackOnException(status, ex);</span><br><span class="line">          <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">          <span class="comment">// Transactional code threw unexpected exception -&gt; rollback</span></span><br><span class="line">          rollbackOnException(status, ex);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(ex, <span class="string">&quot;TransactionCallback threw undeclared checked exception&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.transactionManager.commit(status);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">rollbackOnException</span><span class="params">(TransactionStatus status, Throwable ex)</span> <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TransactionTemplate</code> 需要设置抽象层的<code>PlatformTransactionManager</code> <code>TransactionDefinition</code>。<br><code>execute</code> 是<code>TransactionTemplate</code>  中模版方法， 它是完成在事务中执行目标方法的核心逻辑</p><ol><li>开启事务</li><li>在事务中执行目标方法</li><li>根据目标方法执行结果处理事务commit or rollback</li></ol><p><code>execute</code> 方法接受一个 <code>TransactionCallback</code> 作为参数，并在事务上下文中执行该回调。</p><p><code>TransactionCallback</code>  是一个泛型函数式接口，用于定义在事务上下文中执行的目标方法。它有一个方法 <code>doInTransaction</code>，该方法包含具体的事务逻辑。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TransactionCallback</span>&lt;T&gt; &#123;  </span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line">T <span class="title function_">doInTransaction</span><span class="params">(TransactionStatus status)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>在实际使用时，可以使用匿名内部类或 Java 8 引入的 lambda 表达式进行传参。<br>示例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTemplateExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TransactionTemplate transactionTemplate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MessageService messageService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TransactionTemplateExample</span><span class="params">(TransactionTemplate transactionTemplate, MessageService messageService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.transactionTemplate = transactionTemplate;</span><br><span class="line">        <span class="built_in">this</span>.messageService = messageService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">        transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallback</span>&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Void <span class="title function_">doInTransaction</span><span class="params">(TransactionStatus status)</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">                    message.setMessage(<span class="string">&quot;test message&quot;</span>);</span><br><span class="line">                    messageService.insertMessage(message);</span><br><span class="line">                    messageService.insertMessage(message);</span><br><span class="line">                    <span class="comment">// 如果需要，可以在这里添加更多数据库操作</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    status.setRollbackOnly();</span><br><span class="line">                    <span class="keyword">throw</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用lambda 表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">transactionTemplate.execute(status -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        message.setMessage(<span class="string">&quot;test message&quot;</span>);</span><br><span class="line">        messageService.insertMessage(message);</span><br><span class="line">        messageService.insertMessage(message);</span><br><span class="line">        <span class="comment">// 如果需要，可以在这里添加更多数据库操作</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        status.setRollbackOnly();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h2 id="25-声明式事务"><a href="#2-5-声明式事务" class="headerlink" title="2.5 声明式事务"></a>2.5 声明式事务</h2><p>可以看到，编程式事务实现方式中，事务管理代码对业务代码有明显入侵，<br>Spring支持通过声明式事务，使业务代码和事务管理代码完全解耦。</p><p>Spring 的声明式事务管理通过 Spring AOP 实现，使得业务代码和事务管理代码完全解耦。通过使用 <code>@Transactional</code> 注解和 AOP 代理机制，Spring 在方法调用前后自动织入事务管理逻辑，包括获取线程绑定资源、开始事务、提交/回滚事务、进行异常转换和处理等工作。这种方式极大地简化了事务管理，使代码更简洁、易读和易维护。</p><p>关于Spring AOP 的实现原理，可以阅读以下内容了解<br><a href="https://sunyan.xyz/abd111cb/">Java 动态代理</a><br><a href="https://sunyan.xyz/62ebaa0e/">Spring AOP 实践</a><br><a href="https://sunyan.xyz/a10675df/">Spring AOP XML配置方式原理详解</a><br><a href="https://sunyan.xyz/4316da89/">Spring AOP 注解方式原理详解</a></p><p>声明式事务有3种</p><ol><li>TransactionProxyFactoryBean XML 配置</li><li>aop:config XML 配置</li><li>@Transactional 注解配置</li></ol><p>从循序渐进的学习角度来看，了解TransactionProxyFactoryBean有助于更直观地理解Spring声明式事务的内部工作原理。</p><p>总是来说，不论是哪种声明式 方式，都可以从以下3个角度考虑其实现原理</p><ol><li>事务Advisor 是如何生成的（Advisor 包含 pointcut 和 advice 2个概念）</li><li>基于事务的动态代理对象是如何生成的</li><li>基于事务的动态代理对象是如何执行目标方法的</li></ol><h1 id="3-声明式事务-transactionproxyfactorybean"><a href="#3-声明式事务-TransactionProxyFactoryBean" class="headerlink" title="3. 声明式事务-TransactionProxyFactoryBean"></a>3. 声明式事务-TransactionProxyFactoryBean</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title class_">AbstractSingletonProxyFactoryBean</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">  <span class="comment">// 事务拦截器，用于拦截方法调用</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TransactionInterceptor</span> <span class="variable">transactionInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionInterceptor</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pointcut 定义了一个切入点，它决定了哪些方法调用应该被拦截，并应用事务管理。</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> Pointcut pointcut;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置事务管理器, </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTransactionManager</span><span class="params">(PlatformTransactionManager transactionManager)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.transactionInterceptor.setTransactionManager(transactionManager);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置事务属性。事务属性通过方法名和事务配置（如传播行为、隔离级别等）进行映射。</span></span><br><span class="line">  <span class="comment">// 这个方法接受一个 Properties 对象，其中键是方法名，值是事务属性描述符。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTransactionAttributes</span><span class="params">(Properties transactionAttributes)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.transactionInterceptor.setTransactionAttributes(transactionAttributes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTransactionAttributeSource</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.transactionInterceptor.setTransactionAttributeSource(transactionAttributeSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPointcut</span><span class="params">(Pointcut pointcut)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.pointcut = pointcut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置 Bean 工厂。</span></span><br><span class="line">  <span class="comment">// 如果在运行时没有显式设置事务管理器，这个方法会从 Bean 工厂中获取一个类型为 PlatformTransactionManager 的 bean 作为默认的事务管理器。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBeanFactory</span><span class="params">(BeanFactory beanFactory)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.transactionInterceptor.setBeanFactory(beanFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建Advisor 将事务拦截器和切入点（如果有的话）组合起来。</span></span><br><span class="line">  <span class="comment">// DefaultPointcutAdvisor 是一个将切入点和拦截器组合在一起的 Advisor。如果没有设置切入点，使用 TransactionAttributeSourceAdvisor，它会自动应用事务属性源。</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createMainInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.transactionInterceptor.afterPropertiesSet();</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.pointcut != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(<span class="built_in">this</span>.pointcut, <span class="built_in">this</span>.transactionInterceptor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Rely on default pointcut.</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionAttributeSourceAdvisor</span>(<span class="built_in">this</span>.transactionInterceptor);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">postProcessProxyFactory</span><span class="params">(ProxyFactory proxyFactory)</span> &#123;</span><br><span class="line">proxyFactory.addInterface(TransactionalProxy.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/1a0f7094/7.png" class><p>下面将分析<code>TransactionProxyFactoryBean</code> 的继承实现图谱和重要变量</p><h2 id="31-实现factorybean-接口"><a href="#3-1-实现FactoryBean-接口" class="headerlink" title="3.1 实现FactoryBean 接口"></a>3.1 实现FactoryBean 接口</h2><p><code>TransactionProxyFactoryBean</code>是一个<code>FactoryBean</code> , 这意味着当调用它的<code>getObject</code> 方法时，可以获取到它创建的对象，在这里这个对象指的就是==基于事务的动态代理对象==</p><h2 id="32-实现initializingbean-接口"><a href="#3-2-实现InitializingBean-接口" class="headerlink" title="3.2 实现InitializingBean  接口"></a>3.2 实现InitializingBean  接口</h2><p><code>InitializingBean</code>是 Spring  启动过程中的一个拓展点，用于bean实例化 的init 阶段，使得bean可以在属性注入完成后但在使用之前执行一些自定义的初始化工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">InitializingBean</span> &#123;  </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于Spring bean init 阶段的拓展点，更多内容可以点击这里阅读：<a href="https://sunyan.xyz/678b23b2/#65-docreatebean-initializebean"> Spring bean 实例化过程-initializebean</a></p><p>看下<code>TransactionProxyFactoryBean</code> 重写的<code>InitializingBean.afterPropertiesSet</code>  方法，简化了代码，只保留重点部分，可以看到主要分成3个步骤</p><ol><li>准备代理工厂</li><li>创建Advisor</li><li>生成代理对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSingletonProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title class_">ProxyConfig</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Object&gt;, BeanClassLoaderAware, InitializingBean &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">proxyFactory.addAdvisor(<span class="built_in">this</span>.advisorAdapterRegistry.wrap(createMainInterceptor()));</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.proxy = proxyFactory.getProxy(<span class="built_in">this</span>.proxyClassLoader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>也就是说，<code>TransactionProxyFactoryBean</code>  在自身实例化的init 阶段就把需要的生成的代理对象对象先生成了。</li></ol><p>在  <a href="https://sunyan.xyz/a10675df/">Spring AOP XML配置方式原理详解</a> 一文中具体讲过<code>ProxyFactoryBean</code> 如何在重写的<code>FactoryBean.getObject</code>方法中生成代理对象。</p><p>所以<code>TransactionProxyFactoryBean</code> 和<code>ProxyFactoryBean</code> 这两个都是用于生成代理对象的<code>FactoryBean</code> ，实际生成代理对象的时机是不一样的。</p><p>观察下<code>ProxyFactoryBean</code>  的继承实现图谱，可以看到<code>ProxyFactoryBean</code> 并没有实现<code>InitializingBean</code> ， 所以无法像<code>TransactionProxyFactoryBean</code>  一样在自身实例化的init 阶段就把代理对象生产出来<br><img src="/1a0f7094/8.png" class></p><h3 id="321-createmaininterceptor-创建事务advisor"><a href="#3-2-1-createMainInterceptor-创建事务Advisor" class="headerlink" title="3.2.1 createMainInterceptor- 创建事务Advisor"></a>3.2.1 createMainInterceptor- 创建事务Advisor</h3><p><code>createMainInterceptor</code>  用于创建事务管理中的环绕增强 <code>TransactionInterceptor</code>， 关于<code>TransactionInterceptor</code>见下面3.2 TransactionInterceptor - 环绕增强 部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSingletonProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title class_">ProxyConfig</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Object&gt;, BeanClassLoaderAware, InitializingBean &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title function_">createMainInterceptor</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title class_">AbstractSingletonProxyFactoryBean</span></span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Object <span class="title function_">createMainInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.transactionInterceptor.afterPropertiesSet();</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.pointcut != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultPointcutAdvisor</span>(<span class="built_in">this</span>.pointcut, <span class="built_in">this</span>.transactionInterceptor);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Rely on default pointcut.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransactionAttributeSourceAdvisor</span>(<span class="built_in">this</span>.transactionInterceptor);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createMainInterceptor</code>是 <code>AbstractSingletonProxyFactoryBean</code>中的一个抽象方法，<code>TransactionProxyFactoryBean</code> 实现了它。</p><p>在不指定切点表达式 pointcut 的时候， 会使用<code>TransactionAttributeSourceAdvisor</code>。</p><h4 id="transactionattributesourceadvisor"><a href="#TransactionAttributeSourceAdvisor" class="headerlink" title="TransactionAttributeSourceAdvisor"></a>TransactionAttributeSourceAdvisor</h4><p><code>TransactionAttributeSourceAdvisor</code> 管理<code>TransactionInterceptor</code>这个环绕增强。通过它可以获取到 pointcut 和Advice<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title class_">AbstractPointcutAdvisor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> TransactionInterceptor transactionInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TransactionAttributeSourcePointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionAttributeSourcePointcut</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> TransactionAttributeSource <span class="title function_">getTransactionAttributeSource</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (transactionInterceptor != <span class="literal">null</span> ? transactionInterceptor.getTransactionAttributeSource() : <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TransactionAttributeSourceAdvisor</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TransactionAttributeSourceAdvisor</span><span class="params">(TransactionInterceptor interceptor)</span> &#123;</span><br><span class="line">setTransactionInterceptor(interceptor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTransactionInterceptor</span><span class="params">(TransactionInterceptor interceptor)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.transactionInterceptor = interceptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassFilter</span><span class="params">(ClassFilter classFilter)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.pointcut.setClassFilter(classFilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Advice <span class="title function_">getAdvice</span><span class="params">()</span> &#123;</span><br><span class="line">Assert.state(<span class="built_in">this</span>.transactionInterceptor != <span class="literal">null</span>, <span class="string">&quot;No TransactionInterceptor set&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.transactionInterceptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Pointcut <span class="title function_">getPointcut</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.pointcut;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="322-proxyfactorygetproxy-创建动态代理对象"><a href="#3-2-2-proxyFactory-getProxy-创建动态代理对象" class="headerlink" title="3.2.2 proxyFactory.getProxy -创建动态代理对象"></a>3.2.2 proxyFactory.getProxy -创建动态代理对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxy(classLoader);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>又来到熟悉的动态代理创建的流程</p><ol><li>判断代理类型</li><li>根据代理类型创建代理对象<br>具体创建流程可以参考文章 <a href="https://sunyan.xyz/a10675df/">Spring AOP XML配置方式原理详解</a></li></ol><p>下面来介绍一下<code>TransactionProxyFactoryBean</code>中的变量</p><h2 id="33-transactioninterceptor-环绕增强"><a href="#3-3-TransactionInterceptor-环绕增强" class="headerlink" title="3.3  TransactionInterceptor - 环绕增强"></a>3.3  TransactionInterceptor - 环绕增强</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TransactionInterceptor</span><span class="params">()</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TransactionInterceptor</span><span class="params">(TransactionManager ptm, TransactionAttributeSource tas)</span> &#123;</span><br><span class="line">setTransactionManager(ptm);</span><br><span class="line">setTransactionAttributeSource(tas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line"> </span><br><span class="line">Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);  </span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/1a0f7094/9.png" class><p><code>TransactionInterceptor</code>  继承了<code>org.aopalliance.intercept.MethodInterceptor</code>。</p><p><code>org.aopalliance.intercept.MethodInterceptor</code>是一个环绕增强，表示在目标方法执行前后实施增强。符合事务要在方法执行前开启 和执行后的关闭或者异常处理的使用场景。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.aopalliance.intercept</span><br><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MethodInterceptor</span> <span class="keyword">extends</span> <span class="title class_">Interceptor</span> &#123;  </span><br><span class="line">Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>TransactionInterceptor</code> 重写的<code>invoke</code>  方法中， 通过调用父类<code>TransactionAspectSupport</code>中方法<code>invokeWithinTransaction</code> 完成在事务中执行目标方法这一功能。</p><p><code>invokeWithinTransaction</code> 方法，用于在事务范围内调用目标方法，它处理了事务的开始、提交和回滚，并确保目标方法在事务上下文中执行。</p><h2 id="34-transactionaspectsupport"><a href="#3-4-TransactionAspectSupport" class="headerlink" title="3.4 TransactionAspectSupport"></a>3.4 TransactionAspectSupport</h2><p><code>TransactionAspectSupport</code>是 Spring事务管理的基类，包含了事务管理汇总大多数真正的逻辑，具体的事务管理类，<code>TransactionInterceptor</code>继承它并实现具体的事务管理逻辑。<br><img src="/1a0f7094/10.png" class></p><h3 id="341-invokewithintransaction"><a href="#3-4-1-invokeWithinTransaction" class="headerlink" title="3.4.1 invokeWithinTransaction"></a>3.4.1 invokeWithinTransaction</h3><p><code>invokeWithinTransaction</code> 方法是 <code>TransactionAspectSupport</code> 类的一个关键方法， 用于在事务范围内调用目标方法，并处理事务的开始、提交和回滚，确保目标方法在适当的事务上下文中执行。也是<code>TransactionInterceptor</code>  重写invoke 实现环绕增强时的重点逻辑。</p><p><strong>参数说明</strong>：</p><ul><li><code>method</code>：要调用的方法。</li><li><code>targetClass</code>：目标类，可以为空。</li><li><code>invocation</code>：一个回调接口，用于实际执行目标方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// 通过事务属性源获取当前方法的事务属性。</span></span><br><span class="line"><span class="comment">// 如果没有事务属性，则方法是非事务性的。</span></span><br><span class="line"><span class="type">TransactionAttributeSource</span> <span class="variable">tas</span> <span class="operator">=</span> getTransactionAttributeSource();</span><br><span class="line"><span class="keyword">final</span> <span class="type">TransactionAttribute</span> <span class="variable">txAttr</span> <span class="operator">=</span> (tas != <span class="literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="literal">null</span>);</span><br><span class="line"><span class="keyword">final</span> <span class="type">TransactionManager</span> <span class="variable">tm</span> <span class="operator">=</span> determineTransactionManager(txAttr);</span><br><span class="line"><span class="comment">// 处理响应式事务管理, 先不管</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.reactiveAdapterRegistry != <span class="literal">null</span> &amp;&amp; tm <span class="keyword">instanceof</span> ReactiveTransactionManager) &#123;</span><br><span class="line"><span class="keyword">return</span> txSupport.invokeWithinTransaction(</span><br><span class="line">method, targetClass, invocation, txAttr, (ReactiveTransactionManager) tm);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理标准事务管理， 这是本次重点关心的</span></span><br><span class="line"><span class="type">PlatformTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> asPlatformTransactionManager(tm);</span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">joinpointIdentification</span> <span class="operator">=</span> methodIdentification(method, targetClass, txAttr);</span><br><span class="line"><span class="comment">// 如果事务属性为null或者事务管理器不支持回调</span></span><br><span class="line"><span class="keyword">if</span> (txAttr == <span class="literal">null</span> || !(ptm <span class="keyword">instanceof</span> CallbackPreferringPlatformTransactionManager)) &#123;</span><br><span class="line"><span class="comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span></span><br><span class="line"><span class="comment">// 则执行标准的事务边界控制（即通过`getTransaction`和`commit/rollback`调用）。</span></span><br><span class="line"><span class="comment">//开始一个新的事务或者加入现有的事务。（如果有必要）</span></span><br><span class="line"><span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);</span><br><span class="line"></span><br><span class="line">Object retVal;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 执行目标方法，这是一个环绕通知，通常会导致目标对象的方法被调用。</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// 如果方法抛出异常，调用`completeTransactionAfterThrowing`方法来处理事务回滚，并重新抛出异常。</span></span><br><span class="line">completeTransactionAfterThrowing(txInfo, ex);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// - 在finally块中调用`cleanupTransactionInfo`来清理事务信息。</span></span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line"><span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line"><span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> txInfo.getTransactionStatus();</span><br><span class="line"><span class="keyword">if</span> (status != <span class="literal">null</span> &amp;&amp; txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line">retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">commitTransactionAfterReturning(txInfo);</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">Object result;</span><br><span class="line"><span class="keyword">final</span> <span class="type">ThrowableHolder</span> <span class="variable">throwableHolder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThrowableHolder</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// It&#x27;s a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">result = ((CallbackPreferringPlatformTransactionManager) ptm).execute(txAttr, status -&gt; &#123;</span><br><span class="line"><span class="type">TransactionInfo</span> <span class="variable">txInfo</span> <span class="operator">=</span> prepareTransactionInfo(ptm, txAttr, joinpointIdentification, status);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">retVal</span> <span class="operator">=</span> invocation.proceedWithInvocation();</span><br><span class="line"><span class="keyword">if</span> (retVal != <span class="literal">null</span> &amp;&amp; vavrPresent &amp;&amp; VavrDelegate.isVavrTry(retVal)) &#123;</span><br><span class="line"><span class="comment">// Set rollback-only in case of Vavr failure matching our rollback rules...</span></span><br><span class="line">retVal = VavrDelegate.evaluateTryFailure(retVal, txAttr, status);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (txAttr.rollbackOn(ex)) &#123;</span><br><span class="line"><span class="comment">// A RuntimeException: will lead to a rollback.</span></span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line"><span class="keyword">throw</span> (RuntimeException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ThrowableHolderException</span>(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// A normal return value: will lead to a commit.</span></span><br><span class="line">throwableHolder.throwable = ex;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">cleanupTransactionInfo(txInfo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (ThrowableHolderException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> ex.getCause();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (TransactionSystemException ex2) &#123;</span><br><span class="line"><span class="keyword">if</span> (throwableHolder.throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);</span><br><span class="line">ex2.initApplicationException(throwableHolder.throwable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex2) &#123;</span><br><span class="line"><span class="keyword">if</span> (throwableHolder.throwable != <span class="literal">null</span>) &#123;</span><br><span class="line">logger.error(<span class="string">&quot;Application exception overridden by commit exception&quot;</span>, throwableHolder.throwable);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> ex2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check result state: It might indicate a Throwable to rethrow.</span></span><br><span class="line"><span class="keyword">if</span> (throwableHolder.throwable != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> throwableHolder.throwable;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是要在事务中执行方法的环绕增强，那么其逻辑显然易见包含3步</p><ol><li>开启事务</li><li>在事务中执行目标方法</li><li>根据目标方法执行结果处理事务commit or rollback</li></ol><p>该方法把事务的处理分成了3类</p><ol><li>响应式事务</li><li>标准事务</li><li>回掉首选事务 CallbackPreferringPlatformTransactionManager</li></ol><p>这里只分析标准事务的处理过程</p><h3 id="342-invokewithintransaction-开启事务"><a href="#3-4-2-invokeWithinTransaction-开启事务" class="headerlink" title="3.4.2 invokeWithinTransaction-开启事务"></a>3.4.2 invokeWithinTransaction-开启事务</h3><h4 id="3421-createtransactionifnecessary"><a href="#3-4-2-1-createTransactionIfNecessary" class="headerlink" title="3.4.2.1 createTransactionIfNecessary"></a>3.4.2.1 createTransactionIfNecessary</h4><p><code>createTransactionIfNecessary</code> 负责在需要时创建一个新的事务或加入现有事务，并返回相应的事务状态（<code>TransactionStatus</code>）</p><ul><li><code>tm</code>：事务管理器 (<code>PlatformTransactionManager</code>)，用于实际管理事务。</li><li><code>txAttr</code>：事务属性 (<code>TransactionAttribute</code>)，定义事务的传播行为、隔离级别、超时时间等。</li><li><code>joinpointIdentification</code>：连接点标识，用于标识当前方法调用。 在<a href="https://sunyan.xyz/62ebaa0e/">Spring AOP 实践</a> 讲解过连接点 <code>joinpoint</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事务管理器 (`PlatformTransactionManager`)，用于实际管理事务。</span></span><br><span class="line"><span class="keyword">protected</span> TransactionInfo <span class="title function_">createTransactionIfNecessary</span><span class="params">(<span class="meta">@Nullable</span> PlatformTransactionManager tm,</span></span><br><span class="line"><span class="params"><span class="meta">@Nullable</span> TransactionAttribute txAttr, <span class="keyword">final</span> String joinpointIdentification)</span> &#123;</span><br><span class="line"><span class="comment">// 如果事务属性存在但没有指定名称，则创建一个新的 `DelegatingTransactionAttribute`，并覆盖其 `getName` 方法，使其返回 `joinpointIdentification` 作为事务名称。这确保了每个事务都有一个唯一的标识符，便于调试和日志记录。</span></span><br><span class="line"><span class="keyword">if</span> (txAttr != <span class="literal">null</span> &amp;&amp; txAttr.getName() == <span class="literal">null</span>) &#123;</span><br><span class="line">txAttr = <span class="keyword">new</span> <span class="title class_">DelegatingTransactionAttribute</span>(txAttr) &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> joinpointIdentification;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">TransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (txAttr != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (tm != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//创建一个新事务or加入到现有事务中，取决于事务属性的配置</span></span><br><span class="line">status = tm.getTransaction(txAttr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Skipping transactional joinpoint [&quot;</span> + joinpointIdentification +</span><br><span class="line"><span class="string">&quot;] because no transaction manager has been configured&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 保存与当前事务相关的所有信息,并返回 `TransactionInfo` 对象。</span></span><br><span class="line"><span class="keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);</span><br><span class="line">&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><ol><li>设置事务名称<ul><li>检查事务属性 <code>txAttr</code> 是否为空，并且事务属性中是否指定了事务名称。</li><li>如果事务属性存在但没有指定名称，则创建一个新的 <code>DelegatingTransactionAttribute</code>，并覆盖其 <code>getName</code> 方法，使其返回 <code>joinpointIdentification</code> 作为事务名称。这确保了每个事务都有一个唯一的标识符，便于调试和日志记录。</li></ul></li><li>获取事务状态TransactionStatus<br>如果事务属性 <code>txAttr</code> 不为空：<ul><li>检查是否提供了事务管理器 <code>tm</code>。</li><li>如果事务管理器存在，调用 <code>tm.getTransaction(txAttr)</code> 来获取事务状态（<code>TransactionStatus</code>）。这一步可能会创建一个新事务，或者加入到现有事务中，具体取决于事务属性的配置。</li><li>如果没有配置事务管理器，并且日志级别为调试，则记录一条调试信息，表示跳过事务处理。</li></ul></li><li>准备事务信息 TransactionInfo<ul><li>调用 <code>prepareTransactionInfo</code> 方法来准备并返回 <code>TransactionInfo</code> 对象。</li><li><code>TransactionInfo</code> 是一个内部类，用于保存与当前事务相关的所有信息，包括<code>tm</code>-事务管理器、<code>txAttr</code>-事务属性、<code>joinpointIdentification</code>-连接点标识、<code>status</code>-事务状态</li></ul></li></ol><h5 id="gettransaction-获取当前事务"><a href="#getTransaction-获取当前事务" class="headerlink" title="getTransaction-获取当前事务"></a>getTransaction-获取当前事务</h5><p><code>getTransaction(TransactionAttribute txAttr)</code> 方法是由<code>PlatformTransactionManager</code>接口定义的一个关键方法，用于根据定义好的事务传播行为来判断获取或创建一个事务。</p><p><code>AbstractPlatformTransactionManager</code> 实现了<code>PlatformTransactionManager</code> 并重写了<code>getTransaction</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">TransactionManager</span> &#123;</span><br><span class="line">TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span>  </span><br><span class="line"><span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title class_">PlatformTransactionManager</span>, Serializable &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span><br><span class="line"><span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use defaults if no transaction definition given.</span></span><br><span class="line"><span class="comment">// 如果传入的事务定义为 `null`，则使用默认的事务定义</span></span><br><span class="line"><span class="type">TransactionDefinition</span> <span class="variable">def</span> <span class="operator">=</span> (definition != <span class="literal">null</span> ? definition : TransactionDefinition.withDefaults());</span><br><span class="line"><span class="comment">// 获取当前事务对象。</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">debugEnabled</span> <span class="operator">=</span> logger.isDebugEnabled();</span><br><span class="line"><span class="comment">// 检查给定的事务对象是否表示一个已经存在的事务</span></span><br><span class="line"><span class="comment">// 在事务管理中，确定是否存在现有事务对于决定如何处理新事务至关重要。例如，根据传播行为，新事务可能需要挂起现有事务或者参与现有事务。</span></span><br><span class="line"><span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line"><span class="comment">// Existing transaction found -&gt; check propagation behavior to find out how to behave.</span></span><br><span class="line"><span class="comment">// 如果存在当前事务，则根据传播行为处理现有事务，调用 `handleExistingTransaction(def, transaction, debugEnabled)` 方法，并返回相应的事务状态。</span></span><br><span class="line"><span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check definition settings for new transaction.</span></span><br><span class="line"><span class="comment">// 检查事务定义中的超时时间</span></span><br><span class="line"><span class="keyword">if</span> (def.getTimeout() &lt; TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidTimeoutException</span>(<span class="string">&quot;Invalid transaction timeout&quot;</span>, def.getTimeout());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No existing transaction found -&gt; check propagation behavior to find out how to proceed.</span></span><br><span class="line"><span class="comment">// 根据事务定义中的传播行为（`PropagationBehavior`）决定如何处理新事务。</span></span><br><span class="line"><span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line"><span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line"><span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + def.getName() + <span class="string">&quot;]: &quot;</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">resume(<span class="literal">null</span>, suspendedResources);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line"><span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line"><span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(def, <span class="literal">null</span>, <span class="literal">true</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法的主要功能是根据事务定义（<code>TransactionDefinition</code>）来获取或创建一个事务，并返回相应的事务状态（<code>TransactionStatus</code>）</p><ul><li><code>definition</code>：事务定义（<code>TransactionDefinition</code>），描述事务的传播行为、隔离级别、超时时间等属性。可以为空，如果为空则使用默认的事务定义。</li><li>返回一个 <code>TransactionStatus</code> 对象，表示当前事务的状态。</li></ul><p><code>doGetTransaction</code> 方法在 Spring 事务管理中用于获取当前的事务对象。<br>它返回一个包含当前事务状态信息的对象，后续方法（如 <code>getTransaction</code>）会根据这个对象决定是否需要创建新的事务或加入现有事务。通过这种设计，Spring 提供了灵活且可扩展的事务管理机制，确保事务的正确性和一致性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title class_">PlatformTransactionManager</span>, Serializable &#123;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title function_">doGetTransaction</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/1a0f7094/11.png" class><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlatformTransactionManager</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">ResourceTransactionManager</span>, InitializingBean &#123;</span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doGetTransaction</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionObject</span>();  </span><br><span class="line">txObject.setSavepointAllowed(isNestedTransactionAllowed());  </span><br><span class="line"><span class="type">ConnectionHolder</span> <span class="variable">conHolder</span> <span class="operator">=</span>  </span><br><span class="line">(ConnectionHolder) TransactionSynchronizationManager.getResource(obtainDataSource());  </span><br><span class="line">txObject.setConnectionHolder(conHolder, <span class="literal">false</span>);  </span><br><span class="line"><span class="keyword">return</span> txObject;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>TransactionSynchronizationManager</code> 是一个用来管理与当前线程关联的资源（如连接、事务状态等）的工具类。它使用线程局部变量（ThreadLocal）来存储这些资源，从而确保每个线程都有自己的独立资源副本。</p><h5 id="事务传播行为处理"><a href="#事务传播行为处理" class="headerlink" title="事务传播行为处理"></a>事务传播行为处理</h5><p>Spring 的事务传播行为定义在 <code>TransactionDefinition.Propagation</code> 枚举中，包括以下几种常见的类型：</p><ul><li><strong>REQUIRED</strong>：如果当前没有事务，被嵌套调用的方法会创建一个新的事务；如果已经存在一个事务，嵌套调用的方法将加入到现有事务中执行。</li><li><strong>REQUIRES_NEW</strong>：被嵌套调用的方法每次都创建一个新的事务；如果当前已经存在一个事务，则暂停当前事务，待新事务完成后再恢复。</li><li><strong>NESTED</strong>：如果当前没有事务，则被嵌套调用的方法创建一个新的事务；如果已经存在一个事务，则在现有事务中创建一个嵌套事务。</li><li><strong>MANDATORY</strong>：被嵌套调用的方法必须在现有事务中运行，如果当前没有事务，则抛出异常。</li><li><strong>SUPPORTS</strong>：如果当前有事务，被嵌套调用的方法则在当前事务中运行；如果当前没有事务，被嵌套调用的方法则以非事务方式运行。</li><li><strong>NOT_SUPPORTED</strong>：被嵌套调用的方法以非事务方式运行，如果当前有事务，则暂停当前事务。</li><li><strong>NEVER</strong>：被嵌套调用的方法 以非事务方式运行，如果当前有事务，则抛出异常。</li></ul><p>在<code>getTransaction</code> 中，事务传播行为 要分成2种情况处理</p><ol><li>没有当前事务，根据事物传播行为如何处理当前方法的调用</li><li>存在当前事务，根据事物传播行为如何处理当前方法的调用, handleExistingTransaction<h6 id="没有当前事务"><a href="#没有当前事务" class="headerlink" title="没有当前事务"></a>没有当前事务</h6>省略<code>getTransaction</code>中其他逻辑，只看和事务传播行为相关的代码。<br>在没有当前事务时， 当前方法的调用按照以下逻辑处理<br><strong>MANDATORY</strong>：被嵌套调用的方法必须在现有事务中运行，当前没有事务，则抛出异常。<br><strong>REQUIRED</strong>、<strong>REQUIRES_NEW</strong>、<strong>NESTED</strong>：当前没有事务，创建一个新事务<br><strong>SUPPORTS</strong>、<strong>NOT_SUPPORTED</strong>、<strong>NEVER</strong>：当前没有事务，以非事务方式运行当前方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title class_">PlatformTransactionManager</span>, Serializable &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title function_">getTransaction</span><span class="params">(<span class="meta">@Nullable</span> TransactionDefinition definition)</span></span><br><span class="line"><span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">transaction</span> <span class="operator">=</span> doGetTransaction();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查给定的事务对象是否表示一个已经存在的事务</span></span><br><span class="line"><span class="comment">// 在事务管理中，确定是否存在现有事务对于决定如何处理新事务至关重要。例如，根据传播行为，新事务可能需要挂起现有事务或者参与现有事务。</span></span><br><span class="line"><span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line"><span class="comment">//存在当前事务，则根据传播行为处理现有事务，调用 `handleExistingTransaction(def, transaction, debugEnabled)` 方法，并返回相应的事务状态。</span></span><br><span class="line"><span class="keyword">return</span> handleExistingTransaction(def, transaction, debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不存在当前事务，根据事务定义中的传播行为（`PropagationBehavior`）决定如何处理新事务。</span></span><br><span class="line"><span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line"><span class="string">&quot;No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line"><span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(<span class="literal">null</span>);</span><br><span class="line"><span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Creating new transaction with name [&quot;</span> + def.getName() + <span class="string">&quot;]: &quot;</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">return</span> startTransaction(def, transaction, debugEnabled, suspendedResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">resume(<span class="literal">null</span>, suspendedResources);</span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Create &quot;empty&quot; transaction: no actual transaction, but potentially synchronization.</span></span><br><span class="line"><span class="keyword">if</span> (def.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT &amp;&amp; logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">&quot;Custom isolation level specified but no actual transaction initiated; &quot;</span> +</span><br><span class="line"><span class="string">&quot;isolation level will effectively be ignored: &quot;</span> + def);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line"><span class="keyword">return</span> prepareTransactionStatus(def, <span class="literal">null</span>, <span class="literal">true</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="存在当前事务"><a href="#存在当前事务" class="headerlink" title="存在当前事务"></a>存在当前事务</h6>handleExistingTransaction整体逻辑比较容易理解，也是按照各种传播行为定义进行相应处理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title class_">PlatformTransactionManager</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TransactionStatus <span class="title function_">handleExistingTransaction</span><span class="params">(</span></span><br><span class="line"><span class="params">        TransactionDefinition definition, Object transaction, <span class="type">boolean</span> debugEnabled)</span></span><br><span class="line">        <span class="keyword">throws</span> TransactionException &#123;</span><br><span class="line"><span class="comment">// 该方法要以非事务方式运行，如果当前有事务，则抛出异常。</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(</span><br><span class="line">            <span class="string">&quot;Existing transaction found for transaction marked with propagation &#x27;never&#x27;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 该方法要以非事务方式运行，如果当前有事务，则暂停当前事务。</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Suspending current transaction&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(transaction);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">        <span class="keyword">return</span> prepareTransactionStatus(</span><br><span class="line">            definition, <span class="literal">null</span>, <span class="literal">false</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 该方法调用需要创建一个新的事务；如果当前已经存在一个事务，则暂停当前事务，待新事务完成后再恢复。</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123;</span><br><span class="line">        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Suspending current transaction, creating new transaction with name [&quot;</span> +</span><br><span class="line">              definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">SuspendedResourcesHolder</span> <span class="variable">suspendedResources</span> <span class="operator">=</span> suspend(transaction);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, suspendedResources);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (RuntimeException | Error beginEx) &#123;</span><br><span class="line">          resumeAfterBeginException(transaction, suspendedResources, beginEx);</span><br><span class="line">          <span class="keyword">throw</span> beginEx;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果当前没有事务，则该方法创建一个新的事务；</span></span><br><span class="line"><span class="comment">// 如果已经存在一个事务，则在现有事务中创建一个嵌套事务。</span></span><br><span class="line">    <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNestedTransactionAllowed()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NestedTransactionNotSupportedException</span>(</span><br><span class="line">              <span class="string">&quot;Transaction manager does not allow nested transactions by default - &quot;</span> +</span><br><span class="line">              <span class="string">&quot;specify &#x27;nestedTransactionAllowed&#x27; property with value &#x27;true&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">          logger.debug(<span class="string">&quot;Creating nested transaction with name [&quot;</span> + definition.getName() + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (useSavepointForNestedTransaction()) &#123;</span><br><span class="line">          <span class="comment">// Create savepoint within existing Spring-managed transaction,</span></span><br><span class="line">          <span class="comment">// through the SavepointManager API implemented by TransactionStatus.</span></span><br><span class="line">          <span class="comment">// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.</span></span><br><span class="line">          <span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span></span><br><span class="line">              prepareTransactionStatus(definition, transaction, <span class="literal">false</span>, <span class="literal">false</span>, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">          status.createAndHoldSavepoint();</span><br><span class="line">          <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// Nested transaction through nested begin and commit/rollback calls.</span></span><br><span class="line">          <span class="comment">// Usually only for JTA: Spring synchronization might get activated here</span></span><br><span class="line">          <span class="comment">// in case of a pre-existing JTA transaction.</span></span><br><span class="line">          <span class="keyword">return</span> startTransaction(definition, transaction, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.</span></span><br><span class="line">      <span class="comment">// 在已经有事务的前提下PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED 都需要新建一个事务， </span></span><br><span class="line">    <span class="keyword">if</span> (debugEnabled) &#123;</span><br><span class="line">        logger.debug(<span class="string">&quot;Participating in existing transaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isValidateExistingTransaction()) &#123;</span><br><span class="line">      <span class="comment">// 判断将要新建的事务和已存在的事务其隔离等级是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">          <span class="type">Integer</span> <span class="variable">currentIsolationLevel</span> <span class="operator">=</span> TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">          <span class="comment">//如果当前事务的隔离级别为 `null` 或者与新的事务定义中的隔离级别不一致，则抛出 `IllegalTransactionStateException` 异常。这表示新的事务定义中的隔离级别与现有事务不兼容。</span></span><br><span class="line">          <span class="keyword">if</span> (currentIsolationLevel == <span class="literal">null</span> || currentIsolationLevel != definition.getIsolationLevel()) &#123;</span><br><span class="line">            <span class="type">Constants</span> <span class="variable">isoConstants</span> <span class="operator">=</span> DefaultTransactionDefinition.constants;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(<span class="string">&quot;Participating transaction with definition [&quot;</span> +</span><br><span class="line">                definition + <span class="string">&quot;] specifies isolation level which is incompatible with existing transaction: &quot;</span> +</span><br><span class="line">                (currentIsolationLevel != <span class="literal">null</span> ?</span><br><span class="line">                    isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :</span><br><span class="line">                    <span class="string">&quot;(unknown)&quot;</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前事务是只读的，而新的事务定义不是只读的，则2个事务不兼容，需要抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!definition.isReadOnly()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalTransactionStateException</span>(<span class="string">&quot;Participating transaction with definition [&quot;</span> +</span><br><span class="line">                definition + <span class="string">&quot;] is not marked as read-only but existing transaction is&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">      <span class="keyword">return</span> prepareTransactionStatus(definition, transaction, <span class="literal">false</span>, newSynchronization, debugEnabled, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这段代码的主要作用是验证参与的事务定义（<code>TransactionDefinition</code>）是否与现有事务的属性兼容。它具体执行以下验证：</p><ol><li><strong>隔离级别验证</strong>：确保新的事务定义中的隔离级别与现有事务的隔离级别一致。如果不一致，则抛出异常。</li><li><strong>只读属性验证</strong>：确保新的事务定义中的只读属性与现有事务的只读属性一致。如果不一致，则抛出异常。</li></ol><p>通过这种验证机制，Spring 能够确保在事务传播过程中，新的事务定义不会破坏现有事务的设置，从而保证事务管理的正确性和一致性。</p><h4 id="3421-开始事务-starttransaction-gtdobegin"><a href="#3-4-2-1-开始事务-startTransaction-gt-doBegin" class="headerlink" title="3.4.2.1 开始事务: startTransaction-&gt;doBegin"></a>3.4.2.1 开始事务: startTransaction-&gt;doBegin</h4><p>不论是否存在当前事务， 都要有一个事务启动的步骤<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPlatformTransactionManager</span> <span class="keyword">implements</span> <span class="title class_">PlatformTransactionManager</span>, Serializable &#123;</span><br><span class="line"><span class="keyword">private</span> TransactionStatus <span class="title function_">startTransaction</span><span class="params">(TransactionDefinition definition, Object transaction,  </span></span><br><span class="line"><span class="params"><span class="type">boolean</span> debugEnabled, <span class="meta">@Nullable</span> SuspendedResourcesHolder suspendedResources)</span> &#123;  </span><br><span class="line"><span class="type">boolean</span> <span class="variable">newSynchronization</span> <span class="operator">=</span> (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);  </span><br><span class="line"><span class="type">DefaultTransactionStatus</span> <span class="variable">status</span> <span class="operator">=</span> newTransactionStatus(  </span><br><span class="line">definition, transaction, <span class="literal">true</span>, newSynchronization, debugEnabled, suspendedResources);  </span><br><span class="line">doBegin(transaction, definition);  </span><br><span class="line">prepareSynchronization(status, definition);  </span><br><span class="line"><span class="keyword">return</span> status;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/1a0f7094/12.png" class><p>重点逻辑在doBegin 中，还是看我们更常用到的<code>DataSourceTransactionManager</code> 如何实现的该方法，可以看到其整体流程和JDBC 事务中的流程保持一致,只是<code>DataSourceTransactionManager</code> 中多了更多的包装层。</p><ol><li>获取数据库连接</li><li>设置自动提交、隔离级别、只读属性</li><li>执行目标方法</li><li>结束事务：commit or rollback</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceTransactionManager</span> <span class="keyword">extends</span> <span class="title class_">AbstractPlatformTransactionManager</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">ResourceTransactionManager</span>, InitializingBean &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> &#123;</span><br><span class="line"><span class="type">DataSourceTransactionObject</span> <span class="variable">txObject</span> <span class="operator">=</span> (DataSourceTransactionObject) transaction;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</span><br><span class="line">txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line"><span class="type">Connection</span> <span class="variable">newCon</span> <span class="operator">=</span> obtainDataSource().getConnection();</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Acquired Connection [&quot;</span> + newCon + <span class="string">&quot;] for JDBC transaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">txObject.setConnectionHolder(<span class="keyword">new</span> <span class="title class_">ConnectionHolder</span>(newCon), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 1. 获取数据库连接</span></span><br><span class="line">con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">previousIsolationLevel</span> <span class="operator">=</span> DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line"><span class="comment">// 设置事务隔离级别</span></span><br><span class="line">txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line"><span class="comment">// 设置只读属性</span></span><br><span class="line">txObject.setReadOnly(definition.isReadOnly());</span><br><span class="line"><span class="comment">// 设置自动提交属性</span></span><br><span class="line"><span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">txObject.setMustRestoreAutoCommit(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Switching JDBC Connection [&quot;</span> + con + <span class="string">&quot;] to manual commit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">con.setAutoCommit(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prepareTransactionalConnection(con, definition);</span><br><span class="line">txObject.getConnectionHolder().setTransactionActive(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">timeout</span> <span class="operator">=</span> determineTimeout(definition);</span><br><span class="line"><span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bind the connection holder to the thread.</span></span><br><span class="line"><span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line"><span class="comment">// 将与当前线程的事务相关信息保存到TransactionSynchronizationManager工具类中，方便后续使用</span></span><br><span class="line">TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">DataSourceUtils.releaseConnection(con, obtainDataSource());</span><br><span class="line">txObject.setConnectionHolder(<span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">CannotCreateTransactionException</span>(<span class="string">&quot;Could not open JDBC Connection for transaction&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="342-invokewithintransaction-执行目标方法-invocationcallback"><a href="#3-4-2-invokeWithinTransaction-执行目标方法-InvocationCallback" class="headerlink" title="3.4.2 invokeWithinTransaction 执行目标方法-InvocationCallback"></a>3.4.2 invokeWithinTransaction 执行目标方法-InvocationCallback</h3><p><code>invokeWithinTransaction</code>在对当前的方法有了合适的事务后，就可以通过<code>InvocationCallback.proceedWithInvocation</code>执行对目标方法的调用了。</p><p><code>InvocationCallback</code> 是<code>invokeWithinTransaction</code>的第三个参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> InvocationCallback invocation)</span> </span><br></pre></td></tr></table></figure><p><code>InvocationCallback</code> 是一个位于<code>TransactionAspectSupport</code>内部的函数式接口，可以通过匿名内部类或者lambda表达式实现该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line"><span class="meta">@FunctionalInterface</span>  </span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">interface</span> <span class="title class_">InvocationCallback</span> &#123;  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line">Object <span class="title function_">proceedWithInvocation</span><span class="params">()</span> <span class="keyword">throws</span> Throwable;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用<code>TransactionInterceptor.invoke</code>方法中调用<code>invokeWithinTransaction</code> 时,<code>InvocationCallback</code> 传入了一个lambda 表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionInterceptor</span> <span class="keyword">extends</span> <span class="title class_">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span>, Serializable &#123;</span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;  </span><br><span class="line">Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="literal">null</span>);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TransactionAspectSupport</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span>, InitializingBean &#123;</span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">invokeWithinTransaction</span><span class="params">(Method method, <span class="meta">@Nullable</span> Class&lt;?&gt; targetClass,</span></span><br><span class="line"><span class="params"><span class="keyword">final</span> InvocationCallback invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// 执行目标方法</span></span><br><span class="line">retVal = invocation.proceedWithInvocation();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>说明在<code>invokeWithinTransaction</code>中执行目标方式时， 实际上调用的是<code>MethodInvocation.proceed</code>方法。</p><p><code>ReflectiveMethodInvocation</code>  实现了<code>MethodInvocation</code>， 所以这里在调用<code>ReflectiveMethodInvocation.proceed</code></p><p><code>ReflectiveMethodInvocation.proceed</code> 及其子类<code>CglibMethodInvocation.proceed</code> 可以通过递归调用完成Advice 增强逻辑的执行和目标方法的执行。</p><img src="/1a0f7094/13.png" class><h3 id="343-invokewithintransaction-事务结束处理"><a href="#3-4-3-invokeWithinTransaction-事务结束处理" class="headerlink" title="3.4.3  invokeWithinTransaction-事务结束处理"></a>3.4.3  invokeWithinTransaction-事务结束处理</h3><ol><li>如果目标方法正常完成执行，那就要执行commit 操作， commitTransactionAfterReturning</li><li>如果目标方法执行出现异常，那就要执行回滚操作</li></ol><h2 id="35-再看事务传播行为"><a href="#3-5-再看事务传播行为" class="headerlink" title="3.5 再看事务传播行为"></a>3.5 再看事务传播行为</h2><p>在方法嵌套调用的情况下，Spring 的事务传播行为（Transaction Propagation Behaviors）决定了嵌套方法是新建事务、加入现有事务、开始非事务执行，还是创建嵌套事务。在方法正常执行结束时，不同传播行为的区别不大，但在业务操作失败/部分失败并需要回滚时，这些传播行为的差异变得至关重要。</p><ol><li><strong>PROPAGATION_REQUIRED</strong></li></ol><ul><li><strong>描述</strong>：如果当前没有事务，则创建一个新事务；如果已经存在一个事务，则加入该事务。</li><li><strong>正常执行</strong>：方法正常执行结束，事务提交。</li><li><strong>失败回滚</strong>：无论是外层方法还是内层方法抛出异常，整个事务都会回滚，因为它们属于同一个事务边界。</li></ul><ol><li><strong>PROPAGATION_REQUIRES_NEW</strong></li></ol><ul><li><strong>描述</strong>：每次都创建一个新的事务。如果已经存在一个事务，则暂停当前事务，创建一个新事务。</li><li><strong>正常执行</strong>：每个方法都有自己独立的事务，方法执行结束，各自的事务提交。</li><li><strong>失败回滚</strong>：如果内层方法抛出异常，只有内层方法的事务回滚，外层事务不会受到影响。如果外层方法抛出异常，外层事务回滚，内层事务不受影响（已提交）。</li></ul><ol><li><strong>PROPAGATION_NESTED</strong></li></ol><ul><li><strong>描述</strong>：如果当前没有事务，则创建一个新的事务；如果已经存在一个事务，则在当前事务中创建一个嵌套事务。</li><li><strong>正常执行</strong>：嵌套方法成功执行，其嵌套事务提交，主事务继续。</li><li><strong>失败回滚</strong>：如果内层方法抛出异常，内层事务回滚到保存点，外层事务可以决定是否继续执行或回滚到整个事务。如果外层方法抛出异常，整个事务（包括嵌套事务）都会回滚。</li></ul><ol><li><strong>PROPAGATION_SUPPORTS</strong></li></ol><ul><li><strong>描述</strong>：如果当前有事务，则在事务中运行；如果当前没有事务，则以非事务方式运行。</li><li><strong>正常执行</strong>：在事务中执行则提交事务；非事务执行则正常完成。</li><li><strong>失败回滚</strong>：在事务中执行时，如果抛出异常，事务回滚；非事务执行时，抛出异常不会回滚。</li></ul><ol><li><strong>PROPAGATION_NOT_SUPPORTED</strong></li></ol><ul><li><strong>描述</strong>：总是以非事务方式执行，如果当前有事务，则暂停当前事务。</li><li><strong>正常执行</strong>：方法总是非事务方式执行，正常完成。</li><li><strong>失败回滚</strong>：由于没有事务，即使抛出异常，也不会触发回滚。</li></ul><ol><li><strong>PROPAGATION_NEVER</strong></li></ol><ul><li><strong>描述</strong>：以非事务方式执行，如果当前有事务，则抛出异常。</li><li><strong>正常执行</strong>：在没有事务的情况下正常执行。</li><li><strong>失败回滚</strong>：如果在事务中调用，则直接抛出异常，操作不会执行。</li></ul><ol><li><strong>PROPAGATION_MANDATORY</strong></li></ol><ul><li><strong>描述</strong>：必须在事务中执行，如果当前没有事务，则抛出异常。</li><li><strong>正常执行</strong>：必须在事务中执行，正常完成。</li><li><strong>失败回滚</strong>：如果在非事务情况下调用，则抛出异常，操作不会执行；在事务中调用时，抛出异常回滚事务。</li></ul><h2 id="36-示例代码"><a href="#3-6-示例代码" class="headerlink" title="3.6 示例代码"></a>3.6 示例代码</h2><p>有了以上内容了解，下面我们将基于以下代码，并跟随debug 信息，来具体看下基于事务的动态代理对象的生成和目标方法执行过程<br>applicationContext.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义业务类的 Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.codingInAction.service.MessageService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/trust_message&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;XXXXXX&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageServiceProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;target&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;messageService&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionAttributes&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;insertMessage&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;findByMessageKey&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertMessage</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">      <span class="comment">// 模拟数据库操作</span></span><br><span class="line">        System.out.println(<span class="string">&quot;insertMessage 执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">findByMessageKey</span><span class="params">(Map&lt;String, Object&gt; params)</span>&#123;</span><br><span class="line">      <span class="comment">// 模拟数据库操作 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;findByMessageKey 执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodingInActionApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">MessageService</span> <span class="variable">messageService</span> <span class="operator">=</span> (MessageService) context.getBean(<span class="string">&quot;messageServiceProxy&quot;</span>);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        message.setMessage(<span class="string">&quot;test message&quot;</span>);</span><br><span class="line">        messageService.insertMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-基于事务的动态代理对象"><a href="#3-7-基于事务的动态代理对象" class="headerlink" title="3.7 基于事务的动态代理对象"></a>3.7 基于事务的动态代理对象</h2><p>和  <a href="https://sunyan.xyz/a10675df/">Spring AOP XML配置方式原理详解</a> 一文讲解过使用<code>ProxyFactoryBean</code> 配置代理对象的过程框架基本一致, 以下会省略大部分内容，只重点强调不一致的细节</p><p>getBean(“&amp;messageServiceProxy”)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></p><p>getBean(“&amp;messageServiceProxy”) 意味着是在以上代码的Spring 容器启动过程中实例化了messageServiceProxy 这个<code>TransactionProxyFactoryBean</code>本身。</p><h3 id="371-transactionproxyfactorybean-init-阶段-initializingbean"><a href="#3-7-1-TransactionProxyFactoryBean-init-阶段-InitializingBean" class="headerlink" title="3.7.1  TransactionProxyFactoryBean init 阶段 -InitializingBean"></a>3.7.1  TransactionProxyFactoryBean init 阶段 -InitializingBean</h3><p>在<code>messageServiceProxy</code>本身实例化的过程中，会在init 阶段就生成代理对象</p><img src="/1a0f7094/14.png" class><h3 id="372-获取代理对象-getbeanmessageserviceproxy"><a href="#3-7-2-获取代理对象-getBean-“messageServiceProxy”" class="headerlink" title="3.7.2  获取代理对象-getBean(“messageServiceProxy”)"></a>3.7.2  获取代理对象-getBean(“messageServiceProxy”)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">MessageService</span> <span class="variable">messageService</span> <span class="operator">=</span> (MessageService) context.getBean(<span class="string">&quot;messageServiceProxy&quot;</span>);</span><br></pre></td></tr></table></figure><p>直接跳过各种细节来到<code>FactoryBean.getObject</code>,可以看到由于在<code>afterPropertiesSet</code>中已经生成了代理对象，所以在<code>getObject</code>逻辑中是直接返回已经生成的代理对象的， 不像ProxyFactoryBean 是在<code>getObject</code>逻辑中才生成代理对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractSingletonProxyFactoryBean</span> <span class="keyword">extends</span> <span class="title class_">ProxyConfig</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Object&gt;, BeanClassLoaderAware, InitializingBean &#123;</span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getObject</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.proxy == <span class="literal">null</span>) &#123;  </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FactoryBeanNotInitializedException</span>();  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.proxy;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/1a0f7094/15.png" class><h2 id="38-createmaininterceptor-事务advisor"><a href="#3-8-createMainInterceptor-事务Advisor" class="headerlink" title="3.8 createMainInterceptor -事务Advisor"></a>3.8 createMainInterceptor -事务Advisor</h2><img src="/1a0f7094/16.png" class><img src="/1a0f7094/17.png" class><p>还是在<code>afterPropertiesSet</code> 方法中，会创建事务Advisor。在不指定切点表达式 pointcut 的时候， 会使用<code>TransactionAttributeSourceAdvisor</code></p><p><code>TransactionInterceptor</code> 本身也是在Spring 容器启动过程中，并且按照XML 文件中的信息进行实例化，相当于把编程式事务实现中通过代码设置的属性，全部在XML 文件中通过配置实现了。<br><img src="/1a0f7094/18.png" class><br><img src="/1a0f7094/19.png" class></p><p>从以上代码可以看出， 从<code>TransactionAttributeSourceAdvisor</code>可以获取到需要的切点 Pointcut （这里pointcut 就是前面填充的TransactionAttributeSource 属性）和Advice 增强 , 切点可以过滤出需要执行增强的类及方法， 筛选出目标方法后应用增强完成事务自动管理的功能。<br><img src="/1a0f7094/20.png" class></p><p>以上步骤执行完毕后，可以看下实例化完成的<code>TransactionProxyFactoryBean</code> 包含的内容</p><ol><li>proxy: 在init 阶段提前生成好的动态代理对象， 这是一个CGLIB  动态对象</li><li>transactionInterceptor, 包含了在XML文件中指定的transactionManager、transactionAttributes信息</li></ol><h2 id="39-基于事务的动态代理对象执行目标方法"><a href="#3-9-基于事务的动态代理对象执行目标方法" class="headerlink" title="3.9 基于事务的动态代理对象执行目标方法"></a>3.9 基于事务的动态代理对象执行目标方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">messageService.insertMessage(message)</span><br></pre></td></tr></table></figure><p>最终获取到的是一个CGLIB 动态代理对象， 执行方法时， 直接来到<code>DynamicAdvisedInterceptor.intercept</code>方法</p><h3 id="391-dynamicadvisedinterceptorintercept"><a href="#3-9-1-DynamicAdvisedInterceptor-intercept" class="headerlink" title="3.9.1 DynamicAdvisedInterceptor.intercept"></a>3.9.1 DynamicAdvisedInterceptor.intercept</h3><img src="/1a0f7094/21.png" class><h3 id="392-getinterceptorsanddynamicinterceptionadvice"><a href="#3-9-2-getInterceptorsAndDynamicInterceptionAdvice" class="headerlink" title="3.9.2 getInterceptorsAndDynamicInterceptionAdvice"></a>3.9.2 getInterceptorsAndDynamicInterceptionAdvice</h3><p>获取档案方法可用的interceptor.</p><p>advisor 就是前面创建的<code>TransactionAttributeSourceAdvisor</code>实例， 经过<code>ClassFilter.matches</code> 和<code>MethodMatcher.matches</code>处理后后， 最终返回了可以用在当前bean 上interceptor<br><img src="/1a0f7094/22.png" class></p><h3 id="393-reflectivemethodinvocationproceed"><a href="#3-9-3-ReflectiveMethodInvocation-proceed" class="headerlink" title="3.9.3 ReflectiveMethodInvocation.proceed"></a>3.9.3 <code>ReflectiveMethodInvocation.proceed</code></h3><p><code>ReflectiveMethodInvocation.proceed</code> 是CGLIB 动态代理处理目标方法调用 核心逻辑,它根据<code>currentInterceptorIndex</code>来判断运行以下逻辑</p><ol><li>执行目标方法</li><li>执行目标方法上的interceptor<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectiveMethodInvocation</span> <span class="keyword">implements</span> <span class="title class_">ProxyMethodInvocation</span>, Cloneable &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">currentInterceptorIndex</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="comment">// We start with an index of -1 and increment early.</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.currentInterceptorIndex == <span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.size() - <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> invokeJoinpoint();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">interceptorOrInterceptionAdvice</span> <span class="operator">=</span></span><br><span class="line"><span class="built_in">this</span>.interceptorsAndDynamicMethodMatchers.get(++<span class="built_in">this</span>.currentInterceptorIndex);</span><br><span class="line"><span class="keyword">if</span> (interceptorOrInterceptionAdvice <span class="keyword">instanceof</span> InterceptorAndDynamicMethodMatcher) &#123;</span><br><span class="line"><span class="type">InterceptorAndDynamicMethodMatcher</span> <span class="variable">dm</span> <span class="operator">=</span></span><br><span class="line">(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;</span><br><span class="line">Class&lt;?&gt; targetClass = (<span class="built_in">this</span>.targetClass != <span class="literal">null</span> ? <span class="built_in">this</span>.targetClass : <span class="built_in">this</span>.method.getDeclaringClass());</span><br><span class="line"><span class="keyword">if</span> (dm.methodMatcher.matches(<span class="built_in">this</span>.method, targetClass, <span class="built_in">this</span>.arguments)) &#123;</span><br><span class="line"><span class="keyword">return</span> dm.interceptor.invoke(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>CglibAopProxy</code>中有一个内部类<code>CglibMethodInvocation</code>继承了<code>`ReflectiveMethodInvocation</code> 并重写了<code>proceed</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CglibAopProxy</span> <span class="keyword">implements</span> <span class="title class_">AopProxy</span>, Serializable &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">CglibMethodInvocation</span> <span class="keyword">extends</span> <span class="title class_">ReflectiveMethodInvocation</span> &#123;</span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">proceed</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.proceed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以当<code>DynamicAdvisedInterceptor.intercept</code>中执行到<code>new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed()</code>，会首先来到父类 <code>ReflectiveMethodInvocation.proceed</code>来到递归处理Advisor 和目标方法的核心逻辑<br><img src="/1a0f7094/23.png" class></p><p>前面已经说了，<code>TransactionInterceptor</code>  继承了<code>org.aopalliance.intercept.MethodInterceptor</code>， 所以逻辑会走到这里调用invoke 方法。</p><img src="/1a0f7094/24.png" class><p>来到<code>TransactionInterceptor</code>  重写的invoke 方法， 进入前面重点讲过的<code>invokeWithTransaction</code></p><img src="/1a0f7094/25.png" class><p>这里<code>invokeWithTransaction</code> 的第4个参数是InvocationCallback， 这里传入了 传入了一个labada 表达式， 说明在调用<code>InvocationCallback.proceedWithInvocation</code> 的实现逻辑是调用<code>MethodInvocation.proceed</code> 方法</p><p>所以在<code>invokeWithTransaction</code> 方法中获取到事务信息后，执行<code>InvocationCallback.proceedWithInvocation</code> 实际还是在继续执行<code>ReflectiveMethodInvocation.proceed</code><br><img src="/1a0f7094/26.png" class><br>再次进入<code>ReflectiveMethodInvocation.proceed</code>在此代码示例中， Advisor 只有一个，且已经访问过，所以这里开始执行目标方法的调用<br><img src="/1a0f7094/27.png" class><br>执行完目标方法后，一层层出栈，又回到<code>invokeWithTransaction</code>方法，此时开始执行事务结束的逻辑， 此次调用方法正常执行完毕，所以这里走正常commit 关闭逻辑即可。<br><img src="/1a0f7094/28.png" class></p><h1 id="4-声明式事务-aopconfig"><a href="#4-声明式事务-aop-config" class="headerlink" title="4. 声明式事务 aop:config"></a>4. 声明式事务 aop:config</h1><p><code>TransactionProxyFactoryBean</code> 需要手动配置和获取代理对象，尤其是在需要为多个 bean 配置事务时，每个 bean 都需要手动配置，这在实际应用中会变得繁琐且易出错。</p><p>而 <code>aop:config</code> 和 <code>@Transactional</code> 注解通过 <code>AbstractAutoProxyCreator</code>这个<code>BeanPostProcessor</code> 可以在实例化的init 阶段自动生成代理对象。</p><h2 id="41-示例代码"><a href="#4-1-示例代码" class="headerlink" title="4.1 示例代码"></a>4.1 示例代码</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">&lt;!-- 定义业务类的 Bean --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.codingInAction.service.MessageService&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 配置数据源 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/trust_message&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;24048@Ms&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置事务拦截器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionInterceptor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.transaction.interceptor.TransactionInterceptor&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionAttributes&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;insertMessage&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;findByMessageKey&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 配置事务增强 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;serviceMethods&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.example.codingInAction.service.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;transactionInterceptor&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;serviceMethods&quot;</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodingInActionApplication</span> &#123;   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);  </span><br><span class="line"><span class="type">MessageService</span> <span class="variable">messageService</span> <span class="operator">=</span> (MessageService) context.getBean(<span class="string">&quot;messageService&quot;</span>);  </span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();  </span><br><span class="line">message.setMessage(<span class="string">&quot;test message&quot;</span>);  </span><br><span class="line">messageService.insertMessage(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="42-生成基于事务的动态代理对象aspectjawareadvisorautoproxycreator"><a href="#4-2-生成基于事务的动态代理对象AspectJAwareAdvisorAutoProxyCreator" class="headerlink" title="4.2  生成基于事务的动态代理对象AspectJAwareAdvisorAutoProxyCreator"></a>4.2  生成基于事务的动态代理对象AspectJAwareAdvisorAutoProxyCreator</h2><p>在<a href="https://sunyan.xyz/4316da89/#12-abstractautoproxycreator">Spring AOP 注解方式原理详解-## AbstractAutoProxyCreator</a> 中讲过，<code>AbstractAutoProxyCreator</code> 是一个抽象类，它有多个具体实现。<br><img src="/1a0f7094/29.png" class></p><p>在使用aop:config 方式，实现事务功能时，使用的是<code>AspectJAwareAdvisorAutoProxyCreator</code></p><p><code>AspectJAwareAdvisorAutoProxyCreator</code>和 <code>AnnotationAwareAspectJAutoProxyCreator</code> 类似，但主要用于处理通过 XML 配置文件或其他非注解方式配置的 AspectJ 切面。</p><p>来看Spring 容器启动过程， 当进行业务bean 的初始化之前，已经有一些bean 提前初始化完成存放在singletonObjects 这个一级缓存中了<br><img src="/1a0f7094/30.png" class><br><img src="/1a0f7094/31.png" class></p><p>从beanName 可以看出，messageService、dataSource、transactionManager、transactionInterceptor、serviceMethods 均是在XML 出现的bean 定义。</p><img src="/1a0f7094/32.png" class><p><code>org.springframework.aop.support.DefaultBeanFactoryPointcutAdvisor</code> 和 <code>org.springframework.aop.config.internalAutoProxyCreator</code> 比较特殊</p><h3 id="421-internalautoproxycreator"><a href="#4-2-1-internalAutoProxyCreator" class="headerlink" title="4.2.1 internalAutoProxyCreator"></a>4.2.1 internalAutoProxyCreator</h3><p><code>org.springframework.aop.config.internalAutoProxyCreator</code> 不是一个实际的类，而是一个特殊的 bean 名称。Spring 使用这个名称在内部标识和注册用于自动代理创建的组件。</p><p>这个 bean 名称指向的是一个具体的 <code>AbstractAutoProxyCreator</code>实现类，在使用aop:config 配置基于事务的代理对象时，指的是<code>AspectJAwareAdvisorAutoProxyCreator</code>， 通过上面的debug 信息也可以确认这一点。</p><h3 id="422-beanpostprocessorpostprocessafterinitialization"><a href="#4-2-2-BeanPostProcessor-postProcessAfterInitialization" class="headerlink" title="4.2.2 BeanPostProcessor.postProcessAfterInitialization"></a>4.2.2 BeanPostProcessor.postProcessAfterInitialization</h3><p><code>AspectJAwareAdvisorAutoProxyCreator</code>直接在Spring 容器启动过程中，通过<code>BeanPostProcessor.postProcessAfterInitialization</code>在init阶段介入为MessageService 生成基于事务的动态代理对象</p><img src="/1a0f7094/33.png" class><h2 id="43-事务advisor-defaultbeanfactorypointcutadvisor"><a href="#4-3-事务Advisor-DefaultBeanFactoryPointcutAdvisor" class="headerlink" title="4.3 事务Advisor-DefaultBeanFactoryPointcutAdvisor"></a>4.3 事务Advisor-DefaultBeanFactoryPointcutAdvisor</h2><p>从Spring 启动完成后的singletonObjects 中可以看出aop:config  这个标签配置对应<code>DefaultBeanFactoryPointcutAdvisor</code> 。<br><img src="/1a0f7094/32.png" class></p><p><code>DefaultBeanFactoryPointcutAdvisor</code> 的主要作用是将一个切点（Pointcut）和一个切面（Advice）结合起来，形成一个完整的 AOP 配置。根据Spring 容器启动完成的数据看<code>DefaultBeanFactoryPointcutAdvisor</code> 就对应aop:config 配置，里面包含了定义的pointcut 和Advice.</p><p>Advisor 实例化完成后，在生成代理对象的<code>wrapIfNecessary</code>中就可以获取到能应用到当前类的Advisor 了。</p><p>通过<code>getAdvicesAndAdvisorsForBean</code> 获取在当前类上可以的Advisor , 从debug 信息上可以看到specificInterceptors</p><img src="/1a0f7094/34.png" class><h2 id="44-基于事务的动态代理对象执行目标方法"><a href="#4-4-基于事务的动态代理对象执行目标方法" class="headerlink" title="4.4  基于事务的动态代理对象执行目标方法"></a>4.4  基于事务的动态代理对象执行目标方法</h2><p>前面生成的代理对象是CGLIB 动态代理对象， 执行目标方法时，直接来到<code>DynamicAdvisedInterceptor.intercept</code>方法 。通过ReflectiveMethodInvocation.proceed 方法进入递归执行Advisor和目标方法 的逻辑。<br>和3.9.3 中内容完成一致，此处略过</p><h1 id="5-声明式事务-transactional注解"><a href="#5-声明式事务-Transactional注解" class="headerlink" title="5. 声明式事务-@Transactional注解"></a>5. 声明式事务-@Transactional注解</h1><p>@Transactional 注解</p><ul><li><strong>类级别和方法级别</strong>：可以在类上或方法上使用 <code>@Transactional</code> 注解。如果在类上标注，则该类的所有方法都将受事务管理。</li><li><strong>事务传播行为</strong>：通过 <code>propagation</code> 属性定义事务的传播行为，如 <code>REQUIRED</code>、<code>REQUIRES_NEW</code>、<code>MANDATORY</code> 等。</li><li><strong>隔离级别</strong>：通过 <code>isolation</code> 属性定义事务的隔离级别，如 <code>READ_COMMITTED</code>、<code>REPEATABLE_READ</code>、<code>SERIALIZABLE</code> 等。</li><li><strong>超时和只读属性</strong>：可以通过 <code>timeout</code> 和 <code>readOnly</code> 属性设置事务的超时时间和只读特性。</li><li><strong>回滚规则</strong>：通过 <code>rollbackFor</code> 和 <code>noRollbackFor</code> 属性指定哪些异常会导致事务回滚。</li></ul><h2 id="51-示例代码"><a href="#5-1-示例代码" class="headerlink" title="5.1 示例代码"></a>5.1 示例代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertMessage</span><span class="params">(Message message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;insertMessage 执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">findByMessageKey</span><span class="params">(Map&lt;String, Object&gt; params)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;findByMessageKey 执行&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodingInActionApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(CodingInActionApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="52-生成基于事务的动态代理对象annotationawareaspectjautoproxycreator"><a href="#5-2-生成基于事务的动态代理对象AnnotationAwareAspectJAutoProxyCreator" class="headerlink" title="5.2  生成基于事务的动态代理对象AnnotationAwareAspectJAutoProxyCreator"></a>5.2  生成基于事务的动态代理对象AnnotationAwareAspectJAutoProxyCreator</h2><img src="/1a0f7094/29.png" class><p>使用<code>@Transactional</code>注解时，基于事务的代理对象时通过<code>AnnotationAwareAspectJAutoProxyCreator</code>这个<code>BeanPostProcessor</code>在init 阶段生成的<br><img src="/1a0f7094/35.png" class></p><img src="/1a0f7094/36.png" class><h2 id="53-beanfactorytransactionattributesourceadvisor"><a href="#5-3-BeanFactoryTransactionAttributeSourceAdvisor" class="headerlink" title="5.3 BeanFactoryTransactionAttributeSourceAdvisor`"></a>5.3 BeanFactoryTransactionAttributeSourceAdvisor`</h2><h3 id="531-internaltransactionadvisor"><a href="#5-3-1-internalTransactionAdvisor" class="headerlink" title="5.3.1 internalTransactionAdvisor"></a>5.3.1 internalTransactionAdvisor</h3><p><code>org.springframework.transaction.config.internalTransactionAdvisor</code> 并不是一个实际存在的类，而是一个特殊的 bean 名称。</p><p>在Spring 项目中， 当使用 <code>@EnableTransactionManagement</code> 或 <code>&lt;tx:annotation-driven&gt;</code> 配置时，Spring 会自动注册并配置internalTransactionAdvisor 这个特殊Bean, 其对应的实例是<code>BeanFactoryTransactionAttributeSourceAdvisor</code>。</p><p>在 Spring Boot 项目中，即使不显式使用 <code>@EnableAutoConfiguration</code>，Spring Boot 仍会自动注册和配置许多默认的组件和功能，包括事务管理。这是因为 Spring Boot 的自动配置机制默认包含在 <code>@SpringBootApplication</code> 注解中。</p><p><code>@SpringBootApplication</code> 是一个组合注解，它包含了多个注解，其中一个关键注解就是 <code>@EnableAutoConfiguration</code>。因此，使用 <code>@SpringBootApplication</code> 时，Spring Boot 的自动配置机制会被自动启用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactoryPointcutAdvisor</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> TransactionAttributeSource transactionAttributeSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">TransactionAttributeSourcePointcut</span> <span class="variable">pointcut</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransactionAttributeSourcePointcut</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="keyword">protected</span> TransactionAttributeSource <span class="title function_">getTransactionAttributeSource</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> transactionAttributeSource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTransactionAttributeSource</span><span class="params">(TransactionAttributeSource transactionAttributeSource)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.transactionAttributeSource = transactionAttributeSource;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setClassFilter</span><span class="params">(ClassFilter classFilter)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.pointcut.setClassFilter(classFilter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Pointcut <span class="title function_">getPointcut</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.pointcut;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBeanFactoryPointcutAdvisor</span> <span class="keyword">extends</span> <span class="title class_">AbstractPointcutAdvisor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryAware</span> &#123;  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">private</span> String adviceBeanName;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Nullable</span>  </span><br><span class="line"><span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BeanFactoryTransactionAttributeSourceAdvisor</code>和前面讲过的<code>TransactionProxyFactoryBean</code>有相似之处，</p><ul><li><code>TransactionAttributeSourceAdvisor</code> 和 <code>BeanFactoryTransactionAttributeSourceAdvisor</code> 都是用于应用事务管理的 AOP  Advisor，但在实现细节和使用场景上有所不同。</li><li><code>TransactionAttributeSourceAdvisor</code> 适用于XML 配置配置和使用场景，而 <code>BeanFactoryTransactionAttributeSourceAdvisor</code> 增加了BeanFactory 属性， 适合用于Spring 容器启动过程中使用</li><li>两者都通过定义切点和应用事务增强，实现了 Spring 事务管理的核心功能。</li></ul><img src="/1a0f7094/37.png" class><img src="/1a0f7094/38.png" class><p>通过<code>getAdvicesAndAdvisorsForBean</code>,可以看到在获取应用到当前类的Advisor 时， 通过<code>getBean</code>方法从Spring 容器获取Advisor 实例时， beanName使用的是<code>org.springframework.transaction.config.internalTransactionAdvisor</code> , 最终返回的实例是 <code>BeanFactoryTransactionAttributeSourceAdvisor</code></p><h2 id="54-基于事务的动态代理对象如何执行方法"><a href="#5-4-基于事务的动态代理对象如何执行方法" class="headerlink" title="5.4 基于事务的动态代理对象如何执行方法"></a>5.4 基于事务的动态代理对象如何执行方法</h2><p>和3.9.3 中内容完成一致，此处略过</p><h1 id="6在spring中实现跨资源事务"><a href="#6-在Spring中实现跨资源事务" class="headerlink" title="6.在Spring中实现跨资源事务"></a>6.在Spring中实现跨资源事务</h1><p>前面已经说过，Spring 的事务机制只保证数据库操作的原子性，所以当需要数据库操作和其他中间件操作如kafka操作具有原子性的时候，就要用其他的方案来保证。<br>关于这种情况，可以点击阅读<a href="https://sunyan.xyz/99d433fa/">TrustMessage-基于2PC+MySQL+泛化调用实现的可靠消息中心</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-数据库事务&quot;&gt;&lt;a href=&quot;#1-数据库事务&quot; class=&quot;headerlink&quot; title=&quot;1.  数据库事务&quot;&gt;&lt;/a&gt;1.  数据库事务&lt;/h1&gt;&lt;h2 id=&quot;11-数据库事务实现原理&quot;&gt;&lt;a href=&quot;#1-1-数据库事务实现原理&quot; cl</summary>
      
    
    
    
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring中三级缓存无法解决的循环依赖</title>
    <link href="http://example.com/bccbdfb8/"/>
    <id>http://example.com/bccbdfb8/</id>
    <published>2024-07-16T13:57:56.000Z</published>
    <updated>2024-07-16T14:34:43.100Z</updated>
    
    <content type="html"><![CDATA[<p>建议了解以下内容后再阅读本文</p><p><a href="https://sunyan.xyz/50be4554/">Spring IOC容器 和 Spring bean</a><br><a href="https://sunyan.xyz/114991e5/">Spring IOC 容器启动过程拓展点</a><br><a href="https://sunyan.xyz/678b23b2/">Spring bean 实例化</a><br><a href="https://sunyan.xyz/abd111cb/">Java 动态代理</a><br><a href="https://sunyan.xyz/62ebaa0e/">Spring AOP 实践</a><br><a href="https://sunyan.xyz/a10675df/">Spring AOP XML配置方式原理详解</a><br><a href="https://sunyan.xyz/4316da89/">Spring AOP 注解方式原理详解</a></p><p>关于Spring 循环依赖， 在  <a href="https://sunyan.xyz/678b23b2/">Spring bean 实例化</a>一文中讲解了使用三级缓存+暴露早期引用机制 解决循环依赖问题，但其实不是所有的循环依赖都可以被解决，即使三级缓存+暴露早期引用机制，在Spring  启动过程中依然有可能遇到一下循环依赖错误, 该报错信息位于doCreateBean方法中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">&#x27;springTransactionService&#x27;</span>: Bean with name <span class="string">&#x27;springTransactionService&#x27;</span> has been injected into other beans [userService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans <span class="keyword">do</span> not use the <span class="keyword">final</span> version of the bean. This is often the result of over-eager type matching - consider using <span class="string">&#x27;getBeanNamesForType&#x27;</span> with the <span class="string">&#x27;allowEagerInit&#x27;</span> flag turned off, <span class="keyword">for</span> example.</span><br></pre></td></tr></table></figure></p><p>在单例bean（单例bean 才能使用缓存）且不使用构造器注入（构造器注入无法使用早期引用）的前提下</p><ol><li>普通不需要代理的bean 之间 循环依赖一定可以解决</li><li>需要代理的bean 之间产生循环依赖不一定能解决。</li></ol><h1 id="1-再看docreatebean"><a href="#1-再看doCreateBean" class="headerlink" title="1. 再看doCreateBean"></a>1. 再看doCreateBean</h1><p><code>doCreateBean</code> 方法中包含了bean 实例化的全过程，在  <a href="https://sunyan.xyz/678b23b2/">Spring bean 实例化</a> 一文中，已经说明了实例化的整个流程，并对三层缓存的内容和缓存添加时机都进行了详细介绍，本文将在这些内容之外介绍更多细节，来更好理解循环依赖的过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">AbstractAutowireCapableBeanFactory.java </span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span>&#123;</span><br><span class="line">  <span class="type">Object</span> <span class="variable">beanInstance</span> <span class="operator">=</span> doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">doCreateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span><br><span class="line"><span class="keyword">throws</span> BeanCreationException &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate the bean.</span></span><br><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">instanceWrapper = <span class="built_in">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (instanceWrapper == <span class="literal">null</span>) &#123;</span><br><span class="line">instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line">Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"><span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">mbd.resolvedTargetType = beanType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line"><span class="comment">//检查是否已经对 Bean 定义进行了后处理，如果没有，则调用 applyMergedBeanDefinitionPostProcessors 方法应用后处理器。</span></span><br><span class="line"><span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line"><span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">&quot;Post-processing of merged bean definition failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">mbd.postProcessed = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line"><span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">earlySingletonExposure</span> <span class="operator">=</span> (mbd.isSingleton() &amp;&amp; <span class="built_in">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">isSingletonCurrentlyInCreation(beanName));</span><br><span class="line"><span class="comment">//如果允许循环引用，并且当前 Bean 是单例，则调用 addSingletonFactory 方法，提供一个回调以获取早期 Bean 引用。</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">&quot;Eagerly caching bean &#x27;&quot;</span> + beanName +</span><br><span class="line"><span class="string">&quot;&#x27; to allow for resolving potential circular references&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">      <span class="comment">// 添加第3级缓存， 此处第二个参数又是一个ObjectFactory的匿名类实现</span></span><br><span class="line">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize the bean instance.</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line"><span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCreationException</span>(</span><br><span class="line">mbd.getResourceDescription(), beanName, <span class="string">&quot;Initialization of bean failed&quot;</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 验证循环引用的处理过程是否正确</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 尝试获取早期引用，那么这个早期引用肯定是因为循环依赖，其他bean在getSingleton(beanName, true)生产出来的</span></span><br><span class="line"><span class="comment">// 因为该bean 自己的生产过程中，只会主动添加一级、三级缓存</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 表示init后，Bean实例未被代理,在未代理的情况下，exposedObject 和 bean 是相同的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line"><span class="comment">// 如果存在早期暴露的单例引用，并且exposedObject未被代理，将exposedObject替换为早期暴露的单例引用。</span></span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125; <span class="comment">// 如果在暴露早期引用的情况下，init阶段还存在代理操作时，要确保依赖当前bean 的其他bean 引用到了正确的版本</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line"><span class="comment">// 获取所有依赖当前Bean的Bean名称。</span></span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="comment">// 尝试移除只为类型检查而创建的单例Bean。如果成功移除，表示这个Bean只是为类型检查而创建的，不是实际使用的Bean。</span></span><br><span class="line"><span class="comment">// 通过这个循环，Spring会过滤掉那些只为类型检查而创建的Bean，保留那些实际依赖当前Bean的Bean。</span></span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 这段逻辑确保在处理循环依赖时，确保依赖的Bean使用的是最终版本的Bean，而不是中间状态的原始Bean。</span></span><br><span class="line"><span class="comment">// 如果存在实际依赖当前Bean的Bean。抛出BeanCurrentlyInCreationException异常</span></span><br><span class="line"><span class="comment">// 因为这意味着有Bean在循环依赖的过程中使用了当前Bean的原始版本，但最终当前Bean被包装（如被AOP代理）。</span></span><br><span class="line"><span class="comment">// 这意味着被依赖的Bean使用的不是最终版本的Bean，这可能导致一些问题。</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-ifearlysingletonexposure"><a href="#1-1-if-earlySingletonExposure" class="headerlink" title="1.1 if(earlySingletonExposure)"></a>1.1 if(earlySingletonExposure)</h2><p>关于更多的细节，重点来看init 阶段完成后的以下代码<br>这段逻辑中抛出的异常即是指循环依赖处理失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证循环引用的处理过程是否正确</span></span><br><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line"><span class="comment">// 尝试获取早期引用，那么这个早期引用肯定是因为循环依赖，其他bean在getSingleton(beanName, true)生产出来的</span></span><br><span class="line"><span class="comment">// 因为该bean 自己的生产过程中，只会主动添加一级、三级缓存</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">if</span> (earlySingletonReference != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">// 表示init后，Bean实例未被代理,在未代理的情况下，exposedObject 和 bean 是相同的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line"><span class="comment">// 如果存在早期暴露的单例引用，并且exposedObject未被代理，将exposedObject替换为早期暴露的单例引用。</span></span><br><span class="line">exposedObject = earlySingletonReference;</span><br><span class="line">&#125; <span class="comment">// 如果在暴露早期引用的情况下，init阶段还存在代理操作时，要确保依赖当前bean 的其他bean 引用到了正确的版本</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line"><span class="comment">// 获取所有依赖当前Bean的Bean名称。</span></span><br><span class="line">String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(dependentBeans.length);</span><br><span class="line"><span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line"><span class="comment">// 尝试移除只为类型检查而创建的单例Bean。如果成功移除，表示这个Bean只是为类型检查而创建的，不是实际使用的Bean。</span></span><br><span class="line"><span class="comment">// 通过这个循环，Spring会过滤掉那些只为类型检查而创建的Bean，保留那些实际依赖当前Bean的Bean。</span></span><br><span class="line"><span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">actualDependentBeans.add(dependentBean);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 这段逻辑确保在处理循环依赖时，确保依赖的Bean使用的是最终版本的Bean，而不是中间状态的原始Bean。</span></span><br><span class="line"><span class="comment">// 如果存在实际依赖当前Bean的Bean。抛出BeanCurrentlyInCreationException异常</span></span><br><span class="line"><span class="comment">// 因为这意味着有Bean在循环依赖的过程中使用了当前Bean的原始版本，但最终当前Bean被包装（如被AOP代理）。</span></span><br><span class="line"><span class="comment">// 这意味着被依赖的Bean使用的不是最终版本的Bean，这可能导致一些问题。</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BeanCurrentlyInCreationException</span>(beanName,</span><br><span class="line"><span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line"><span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line"><span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line"><span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line"><span class="string">&quot;&#x27;getBeanNamesForType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-bean-exposedobject-earlysingletonreference"><a href="#1-2-bean、exposedObject、earlySingletonReference" class="headerlink" title="1.2 bean、exposedObject、earlySingletonReference"></a>1.2 bean、exposedObject、earlySingletonReference</h2><p>先来对这3个指向bean 实例的变量进行解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BeanWrapper</span> <span class="variable">instanceWrapper</span> <span class="operator">=</span> createBeanInstance(beanName, mbd, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bean 指create阶段后获取的引用， 这个引用非常原始，肯定不会是代理对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">bean</span> <span class="operator">=</span> instanceWrapper.getWrappedInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">// exposedObject 是doCreateBean方法最终会返回的数据</span></span><br><span class="line"><span class="comment">// 经过init阶段后，如果执行了代理逻辑，则会产生一个新的代理对象赋值给 exposedObject，这时exposedObject和bean就不相等了</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// bean的早期引用， 即三级缓存中第二级缓存</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">earlySingletonReference</span> <span class="operator">=</span> getSingleton(beanName, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="13-同一个bean实例-的同一个apc不会重复执行"><a href="#1-3-同一个bean实例-的同一个APC不会重复执行" class="headerlink" title="1.3 同一个bean实例 的同一个APC不会重复执行"></a>1.3 同一个bean实例 的同一个APC不会重复执行</h2><p>针对<code>AbstractAutoProxyCreator</code> 而言，对一个bean产生对象的有两个时机</p><ol><li>因为循环依赖被其他bean 依赖时，通过<code>AbstractAutoProxyCreator.getEarlyBeanReference</code>获取其早期引用，即代理对象引用</li><li>bean 正常实例化流程中, 在init 阶段通过<code>BeanPostProcessor.postProcessAfterInitialization</code> 方法，触发<code>AbstractAutoProxyCreator.postProcessAfterInitialization</code>  方法执行，该方法中包含生成代理对象的逻辑</li></ol><p>具体代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line">  <span class="comment">// 生成了早期引用的bean缓存，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; earlyProxyReferences = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;  </span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);  </span><br><span class="line"><span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);  </span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123; </span><br><span class="line"><span class="comment">// 如果 `bean` 为 `null`，则直接返回 `null`。</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;  </span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);  </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;  </span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> bean;  </span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> Object <span class="title function_">getCacheKey</span><span class="params">(Class&lt;?&gt; beanClass, <span class="meta">@Nullable</span> String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (StringUtils.hasLength(beanName)) &#123;</span><br><span class="line"><span class="keyword">return</span> (FactoryBean.class.isAssignableFrom(beanClass) ?</span><br><span class="line">BeanFactory.FACTORY_BEAN_PREFIX + beanName : beanName);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> beanClass;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="131-earlyproxyreferences"><a href="#1-3-1-earlyProxyReferences" class="headerlink" title="1.3.1 earlyProxyReferences"></a>1.3.1 <code>earlyProxyReferences</code></h3><p>之所以说对一个bean 来讲，同一个<code>AbstractAutoProxyCreator</code>实例的代理逻辑不会重复执行，是因为<code>earlyProxyReferences</code> 这个缓存的存在。</p><p><code>earlyProxyReferences</code>  是一个ConcurrentHashMap， key 是beanName(先忽略对FactoryBean的处理，即使加了&amp; 前缀，也是一个字符串，继续理解成beanName就可以了)， value是bean 实例对象。</p><p>根据<code>getEarlyBeanReference</code>和<code>postProcessAfterInitialization</code>的逻辑可以看出，如果一个bean 提前获取了早期引用，则会在<code>earlyProxyReferences</code>  中将其记录下来。</p><p>⚠️：注意记录的不是早期引用（早期引用可以是原始bean ,也可能是代理对象引用），早期引用是存储在三级缓存中的第二级缓存中的。</p><p>那么在bean 实例化init 阶段， 进入<code>AbstractAutoProxyCreator.postProcessAfterInitialization</code> 方法时，通过cacheKey读取value , 判断<code>earlyProxyReferences</code> 中记录的bean和当前入参bean是否一致， 如果一致，就不用重复执行<code>wrapIfNecessary</code>逻辑了。</p><h3 id="132-earlyproxyreferencesremove"><a href="#1-3-2-earlyProxyReferences-remove" class="headerlink" title="1.3.2 earlyProxyReferences.remove"></a>1.3.2 earlyProxyReferences.remove</h3><p>判断<code>earlyProxyReferences</code> 中记录的bean和当前入参bean是否一致， 是通过以下代码逻辑完成的，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean)</span><br></pre></td></tr></table></figure><p><code>earlyProxyReferences.remove(cacheKey)</code> 的结果有3种情况 null,   与入参bean 相等的值，与入参bean 不相等的值，</p><ol><li><strong>返回 <code>null</code>：</strong><ul><li><strong>解释：</strong> 这表明入参bean 没有在其他 bean 的依赖注入过程中提前暴露引用。</li><li><strong>处理：</strong> 需要对入参bean 进行代理创建，调用 <code>wrapIfNecessary</code> 方法。</li></ul></li><li><strong>返回与 入参bean 相等的值：</strong><ul><li><strong>解释：</strong> 这表明该入参bean 已经因为其他 bean 的依赖注入提前执行<code>wrapIfNecessary</code>，所以这里不需要重复执行了</li><li><strong>处理：</strong> 不需要对该 bean 进行代理创建，因此不调用 <code>wrapIfNecessary</code> 方法。</li></ul></li><li><strong>返回与入参bean 不相等的值：</strong><ul><li><strong>解释：</strong> cacheKey 对应的bean 确实已经提前暴露了引用，但是具有相同cacheKey 的 入参bean不是当初来获取早期引用的那个bean, 所以仍然要对这个入参bean 执行<code>wrapIfNecessary</code> 逻辑</li><li><strong>处理：</strong> 需要对该 bean 进行代理创建，调用 <code>wrapIfNecessary</code> 方法</li></ul></li></ol><p>前两种情况都比较好理解， 第3种情况需要多加解释，而且第三种也是无法解决的循环依赖。</p><p>出现的原因可以分为2种</p><ol><li>能生成代理对象的不只AbstractAutoProxyCreator， 还有AbstractAdvisingBeanPostProcessor</li><li>存在多个AbstractAutoProxyCreator</li></ol><p>⚠️：这个缓存的使用逻辑， 和实际开发中我们要删除缓存时思路一致， 要先判断要删除的线程是不是和当前添加缓存的线程一致，一致的话才能删除缓存，否则会造成数据不一致。</p><h1 id="2-有动态代理的循环引用实例"><a href="#2-有动态代理的循环引用实例" class="headerlink" title="2.  有动态代理的循环引用实例"></a>2.  有动态代理的循环引用实例</h1><h2 id="21-有动态代理的循环引用示例代码"><a href="#2-1-有动态代理的循环引用示例代码" class="headerlink" title="2.1 有动态代理的循环引用示例代码"></a>2.1 有动态代理的循环引用示例代码</h2><p>该示例代码是Springboot 项目，构造一个依赖循环的例子</p><p>在如下代码中，userService和springTransactionService通过属性注入互相依赖， 且定义了一个Aspect , 这个Aspect 会为userService和springTransactionService 都生成代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTransactionService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;performTransaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> <span class="keyword">implements</span> <span class="title class_">UserI</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    SpringTransactionService springTransactionService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟业务处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Creating user: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟业务处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Deleting user: &quot;</span> + username);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个匹配userService中所有方法的切点表达式</span></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.example.codingInAction.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userServiceAllMethod</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在方法执行之前执行的通知</span></span><br><span class="line">    <span class="meta">@Before(&quot;userServiceAllMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Before method: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在方法执行之后执行的通知</span></span><br><span class="line">    <span class="meta">@After(&quot;userServiceAllMethod()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfter</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;After method: &quot;</span> + joinPoint.getSignature().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个只匹配 UserService.createUser 方法的切点表达式</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.codingInAction.service.UserService.createUser(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot; 方法开始执行&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();  <span class="comment">// 执行目标方法</span></span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(joinPoint.getSignature().getName() + <span class="string">&quot; 方法执行时间: &quot;</span> + (endTime - startTime) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例代码启动入口</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CodingInActionApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(CodingInActionApplication.class, args);</span><br></pre></td></tr></table></figure><h2 id="22-springtransactionservice-实例化"><a href="#2-2-springTransactionService-实例化" class="headerlink" title="2.2 springTransactionService 实例化"></a>2.2 springTransactionService 实例化</h2><h3 id="221-三级缓存"><a href="#2-2-1-三级缓存" class="headerlink" title="2.2.1 三级缓存"></a>2.2.1 三级缓存</h3><img src="/bccbdfb8/1.png" class><p>springTransactionService 经过createBeanInstance阶段后，放入第三级缓存，以便在需要之时提前暴露引用</p><img src="/bccbdfb8/2.png" class><h3 id="222-populate-with-userservice"><a href="#2-2-2-populate-with-userService" class="headerlink" title="2.2.2 populate with  userService"></a>2.2.2 populate with  userService</h3><p>springTransactionService 在populate阶段发现需要userService, 通过getBean 获取userService 实例。</p><h4 id="2221-getbeanuserservice"><a href="#2-2-2-1-getBean-userService" class="headerlink" title="2.2.2.1 getBean(userService)"></a>2.2.2.1 getBean(userService)</h4><p>此时userService 还没有进行实例化，所以在三级缓存中不存在，要走create 流程进行实例化</p><img src="/bccbdfb8/3.png" class><h4 id="2222-userservice-放入第三级缓存"><a href="#2-2-2-2-userService-放入第三级缓存" class="headerlink" title="2.2.2.2 userService 放入第三级缓存"></a>2.2.2.2 userService 放入第三级缓存</h4><p>userService 经过createBeanInstance阶段后，放入第三级缓存，以便在需要之时提前暴露引用<br><img src="/bccbdfb8/4.png" class></p><h4 id="2223-userservice-populate-with-springtransactionservice"><a href="#2-2-2-3-userService-populate-with-springTransactionService" class="headerlink" title="2.2.2.3 userService populate with springTransactionService"></a>2.2.2.3 userService populate with springTransactionService</h4><p>userService在populate 阶段发现需要springTransactionService ， 再次通过getBean 流程获取springTransactionService， 此时springTransactionService的三级缓存已经存在，可以获取早期引用。</p><h4 id="2224-获取springtransactionservice早期引用"><a href="#2-2-2-4-获取springTransactionService早期引用" class="headerlink" title="2.2.2.4 获取springTransactionService早期引用"></a>2.2.2.4 获取springTransactionService早期引用</h4><p>获取springTransactionService  时，依然是getBean作为入口<br><img src="/bccbdfb8/5.png" class><br>由于springTransactionService  已经完成createInstance 放入了第三级缓存，此时getSingleton(beanName )方法是可以获取到早期引用的， 获取早期引用的逻辑如下<br><img src="/bccbdfb8/6.png" class><br>以singletonFactory.getObject 为入口，进入三级缓存获取早期引用的逻辑<code>AbstractAutoProxyCreator.getEarlyBeanReference</code></p><img src="/bccbdfb8/7.png" class><img src="/bccbdfb8/8.png" class><img src="/bccbdfb8/9.png" class><p>经过<code>AbstractAutoProxyCreator</code> 这个<code>BeanPostProcessor</code> 处理，其earlyProxyReferences 记录了springTransactionService曾来获取过早期引用， 并最终返回了一个CGLIB 动态代理对象</p><p>⚠️ wrapIfNecessary  只对需要产生代理的对象生成代理对象，不需要产生代理的对象会直接返回原对象.在这个例子中是springTransactionService 代理对象的引用</p><p>getEarlyBeanReference 返回的数据，即singletonFactory.getObject 获取到数据会放到第二级缓存中，同时删除第三级缓存。</p><img src="/bccbdfb8/9.png" class><img src="/bccbdfb8/6.png" class><h4 id="2225-userservice-init"><a href="#2-2-2-5-userService-init" class="headerlink" title="2.2.2.5 userService init"></a>2.2.2.5 userService init</h4><p>现在 userService populate 阶段结束，开始init 阶段，省略其他部分，只看AutoProxyCreator这个BeanPostProcessor.</p><p>由于userService 之前没有获取过早期引用， 所以<code>earlyProxyReferences</code> 并不存在userService,<code>this.earlyProxyReferences.remove(cacheKey)</code> 返回null, 需要进入<code>wrapIfNecessary</code> 逻辑，由于userService 符合LoggingAspect 切点表达式，经过<code>wrapIfNecessary</code> 后， 会生成userService的动态代理对象</p><img src="/bccbdfb8/10.png" class><img src="/bccbdfb8/11.png" class><h4 id="2226-earlysingletonexposure"><a href="#2-2-2-6-earlySingletonExposure" class="headerlink" title="2.2.2.6 earlySingletonExposure"></a>2.2.2.6 earlySingletonExposure</h4><p>由于目前为止，userService 并没有触发早期引用的暴露逻辑，即从三级缓存中获取早期引用放到二级缓存中的逻辑，所以一级缓存，二级缓存中均不存在userService, 所以<code>getSingleton(beanName, false)</code>会返回null， 因此userService不需要进行早期引用暴露的特殊处理，直接返回实例化完成的bean 即可（有可能是原始bean, 也有可能是代理对象，在这个例子中是代理对象）<br><img src="/bccbdfb8/12.png" class></p><h4 id="2227-一级缓存"><a href="#2-2-2-7-一级缓存" class="headerlink" title="2.2.2.7 一级缓存"></a>2.2.2.7 一级缓存</h4><p>实例化完成的userService 会放入一级缓存中，同时删除二、三级缓存，确保一个bean 在同一时刻只会存在于某一级缓存中</p><img src="/bccbdfb8/13.png" class><h3 id="223-springtransactionservice-init"><a href="#2-2-3-springTransactionService-init" class="headerlink" title="2.2.3 springTransactionService  init"></a>2.2.3 springTransactionService  init</h3><p>springTransactionService populate 阶段完成，现在来到init阶段，只看我们关心的 <code>AbstractAutoProxyCreator.postProcessAfterInitialization</code><br><img src="/bccbdfb8/14.png" class><br>由于前面在userService 的实例化过程中，我们已经通过<code>getEarlyBeanReference</code><br>获取过springTransactionService的早期引用(且是经过springTransactionService包装过的代理对象引用)</p><p>所以<code>earlyProxyReferences</code>中已经记录了springTransactionService相关数据，且和传进来bean数据一致，所以这里的逻辑会直接返回，而不是再走一遍<code>wrapIfNecessary</code>逻辑。<br><img src="/bccbdfb8/8.png" class></p><img src="/bccbdfb8/15.png" class><h3 id="224-earlysingletonexposure"><a href="#2-2-4-earlySingletonExposure" class="headerlink" title="2.2.4 earlySingletonExposure"></a>2.2.4 earlySingletonExposure</h3><p>现在springTransactionService 已经完成了实例化的3个阶段，逻辑来到<code>doCreateBean</code>中最后关于循环依赖和早期引用的处理逻辑<br><img src="/bccbdfb8/16.png" class></p><p>由于在userService 的实例化过程中，springTransactionService已经提前暴露了引用，且是代理对象的引用， 所以<code>getSingleton(beanName, false)</code>会获取到其早期引用。</p><p>此时bean 与 exposedObject相等，说明在init阶段没有执行代理逻辑，doCreateBean 最终会返回提前暴露的引用earlySingletonReference</p><p>至此springTransactionService   经过和userService 的循环依赖处理，已经成功初始化。userService 也成功初始化，后续在对userService 执行getBean 操作都会直接从一级缓存中获取。</p><p>下面来看三级缓存无法解决的循环依赖</p><h1 id="3-abstractadvisingbeanpostprocessor-引发的异常"><a href="#3-AbstractAdvisingBeanPostProcessor-引发的异常" class="headerlink" title="3. AbstractAdvisingBeanPostProcessor 引发的异常"></a>3. AbstractAdvisingBeanPostProcessor 引发的异常</h1><p>在Spring 启动过程中，能为bean 生成代理对象的不止<code>AbstractAutoProxyCreator</code> 一个， <code>AbstractAdvisingBeanPostProcessor</code>也可以为bean 生成一个代理对象<br><img src="/bccbdfb8/17.png" class></p><p><code>AbstractAdvisingBeanPostProcessor</code> 也是一个<code>BeanPostProcessor</code> ， 因此也可以在<code>init</code> 阶段通过<code>postProcessAfterInitialization</code>方法介入bean 的生命周期。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAdvisingBeanPostProcessor</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.advisor == <span class="literal">null</span> || bean <span class="keyword">instanceof</span> AopInfrastructureBean) &#123;</span><br><span class="line"><span class="comment">// Ignore AOP infrastructure such as scoped proxies.</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Advised) &#123;</span><br><span class="line"><span class="type">Advised</span> <span class="variable">advised</span> <span class="operator">=</span> (Advised) bean;</span><br><span class="line"><span class="keyword">if</span> (!advised.isFrozen() &amp;&amp; isEligible(AopUtils.getTargetClass(bean))) &#123;</span><br><span class="line"><span class="comment">// Add our local Advisor to the existing proxy&#x27;s Advisor chain...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.beforeExistingAdvisors) &#123;</span><br><span class="line">advised.addAdvisor(<span class="number">0</span>, <span class="built_in">this</span>.advisor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">advised.addAdvisor(<span class="built_in">this</span>.advisor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEligible(bean, beanName)) &#123;</span><br><span class="line"><span class="type">ProxyFactory</span> <span class="variable">proxyFactory</span> <span class="operator">=</span> prepareProxyFactory(bean, beanName);</span><br><span class="line"><span class="keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;</span><br><span class="line">evaluateProxyInterfaces(bean.getClass(), proxyFactory);</span><br><span class="line">&#125;</span><br><span class="line">proxyFactory.addAdvisor(<span class="built_in">this</span>.advisor);</span><br><span class="line">customizeProxyFactory(proxyFactory);</span><br><span class="line"><span class="keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// No proxy needed.</span></span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看<code>AbstractAdvisingBeanPostProcessor.postProcessAfterInitialization</code>代码，可以看到也是生成代理对象的diamanté，其逻辑进入getProxy就和之前 讲过<a href="obsidian://open?vault=Documents&amp;file=second-brain%2F1-tech%2FSpring%20%E5%AE%B6%E6%97%8F%2Fnew%2F7%20-%20Spring%20AOP%20%20%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3">代理创建流程</a> 完全一致，就不进入细节去分析了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">extends</span> <span class="title class_">ProxyCreatorSupport</span> &#123; </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getProxy</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123; </span><br><span class="line"><span class="keyword">return</span> createAopProxy().getProxy(classLoader);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那实际生产开发中，有两个注解会用到<code>AbstractAdvisingBeanPostProcessor</code>  ， 如果使用不当，就会引发无法解决的循环依赖，从而导致Spring 容器启动失败</p><h2 id="31-repository注解-persistenceexceptiontranslationpostprocessor"><a href="#3-1-Repository注解-PersistenceExceptionTranslationPostProcessor" class="headerlink" title="3.1 @Repository注解-PersistenceExceptionTranslationPostProcessor"></a>3.1 @Repository注解-PersistenceExceptionTranslationPostProcessor</h2><p>在Spring中，<code>@Repository</code> 注解主要用于标记数据访问层（DAO）。相比 <code>@Component</code>（通用Bean 注解）、<code>@Service</code>（用于对Service实现类进行标注） 和 <code>@Controller</code>（用于对Controller实现类进行标注），<code>@Repository</code> 注解的一个显著区别在于它的异常处理机制。</p><p>Spring为<code>@Repository</code>  提供了一个特殊的处理机制，自动将数据访问异常转换为 Spring 的统一数据访问异常层次结构（如 <code>DataAccessException</code>）。<code>@Service</code> 和 <code>@Controller</code> 没有这种特定的异常处理机制。它们的异常处理通常依赖于全局异常处理器（如 <code>@ControllerAdvice</code>）或手动捕获和处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repository &#123;</span><br><span class="line">    <span class="meta">@AliasFor(annotation = Component.class)</span></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 <code>@Repository</code> 注解时，Spring 会在后台自动注册一个 <code>PersistenceExceptionTranslationPostProcessor</code>。</p><p><code>PersistenceExceptionTranslationPostProcessor</code> 继承了<code>AbstractAdvisingBeanPostProcessor</code> , 因此使用了<code>@Repository</code>注解的bean 在实例化完成后，最终生成的是其代理对象。<br><img src="/bccbdfb8/18.png" class></p><h3 id="311-有动态代理的循环引用示例代码"><a href="#3-1-1-有动态代理的循环引用示例代码" class="headerlink" title="3.1.1  有动态代理的循环引用示例代码"></a>3.1.1  有动态代理的循环引用示例代码</h3><p>改造下SpringTransactionService , 将@Service 替换成<code>@Repository</code>， 其他代码保持不变。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTransactionService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTransaction</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟业务逻辑</span></span><br><span class="line">        System.out.println(<span class="string">&quot;performTransaction&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>启动该SpringBoot 项目，将报如下错误<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name <span class="string">&#x27;springTransactionService&#x27;</span>: Bean with name <span class="string">&#x27;springTransactionService&#x27;</span> has been injected into other beans [userService] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans <span class="keyword">do</span> not use the <span class="keyword">final</span> version of the bean. This is often the result of over-eager type matching - consider using <span class="string">&#x27;getBeanNamesForType&#x27;</span> with the <span class="string">&#x27;allowEagerInit&#x27;</span> flag turned off, <span class="keyword">for</span> example.</span><br></pre></td></tr></table></figure></p><p>直接跟随debug 信息来到springTransactionService 实例化过程 阶段</p><h4 id="getearlybeanreference"><a href="#getEarlyBeanReference" class="headerlink" title="getEarlyBeanReference"></a>getEarlyBeanReference</h4><p>在springTransactionService  -&gt;userService -&gt; springTransactionService  循环依赖获取springTransactionService 的早期引用时，</p><p>在<code>getEarlyBeanReference</code>中，只有 <code>AbstractAutoProxyCreator</code> 这类<code>BeanPostProcessor</code> 才会执行。 <code>AbstractAdvisingBeanPostProcessor</code>不是 <code>AbstractAutoProxyCreator</code>  ，所示<code>PersistenceExceptionTranslationPostProcessor</code>在 <code>getEarlyBeanReference</code>阶段是不会发挥作用的</p><img src="/bccbdfb8/19.png" class><img src="/bccbdfb8/20.png" class><h4 id="postprocessafterinitialization"><a href="#postProcessAfterInitialization" class="headerlink" title="postProcessAfterInitialization"></a>postProcessAfterInitialization</h4><p>在springTransactionService 的init 阶段， 不会过滤 只有<code>AbstractAutoProxyCreator</code> 的子类执行，而是对所有的<code>BeanPostProcessor</code> 都执行其<code>postProcessAfterInitialization</code> 方法。<br><code>AnnotationAwareAspectJAutoProxyCreator</code> 里根据<code>if (this.earlyProxyReferences.remove(cacheKey) != bean)</code>判断，不会重复执行<code>wrapIfNecessary</code>, 直接返回入参bean</p><img src="/bccbdfb8/25.png" class><p>接着开始执行<code>PersistenceExceptionTranslationPostProcessor</code></p><img src="/bccbdfb8/21.png" class><img src="/bccbdfb8/22.png" class><p>从图中可以看出，此时入参bean 依然是原始bean, 经过@Repository注解-PersistenceExceptionTranslationPostProcessor 处理后，原始入参bean又生成了一个的代理对象返回。<br><img src="/bccbdfb8/23.png" class></p><h4 id="earlysingletonexposure"><a href="#earlySingletonExposure" class="headerlink" title="earlySingletonExposure"></a>earlySingletonExposure</h4><img src="/bccbdfb8/24.png" class><p>从图中可以看出， 最终返回的exposedObject 和提前暴露的earlySingletonReference 已经不是同一个实例了，earlySingletonReference 是经过<code>AnnotationAwareAspectJAutoProxyCreator</code> 生成的代对象， exposedObject 是<code>PersistenceExceptionTranslationPostProcessor</code>生成的地理对象，提前暴露的引用和最终生成的引用不一致，且该bean的早期引用已经被userService 依赖了，最终会走到报错逻辑</p><p>==所以在实际生产开发中，关于注解的最佳实践一定是按照层级划分使用对应的注解==</p><h2 id="32-async-asyncannotationbeanpostprocessor"><a href="#3-2-Async-AsyncAnnotationBeanPostProcessor" class="headerlink" title="3.2 @Async-AsyncAnnotationBeanPostProcessor"></a>3.2 @Async-AsyncAnnotationBeanPostProcessor</h2><p>@Async 是用于标识异步执行的注解，使用不当的话，会由于同样的原因造成无法解决的循环依赖。<br>AsyncAnnotationBeanPostProcessor 同样继承了AbstractAdvisingBeanPostProcessor，因此会在init 阶段 为添加了@Async 注解的bean 生成代理对象<br><img src="/bccbdfb8/26.png" class></p><h3 id="321-有动态代理的循环引用示例代码"><a href="#3-2-1-有动态代理的循环引用示例代码" class="headerlink" title="3.2.1 有动态代理的循环引用示例代码"></a>3.2.1 有动态代理的循环引用示例代码</h3><p>改造下SpringTransactionService , 将@Service 替换成<code>@Repository</code>， 其他代码保持不变。启动该SpringBoot 项目，会报同样的错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span>  </span><br><span class="line"><span class="meta">@Service</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTransactionService</span> &#123;  </span><br><span class="line">   </span><br><span class="line"><span class="meta">@Autowired</span>  </span><br><span class="line">UserService userService;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">@Async</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTransaction</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="comment">// 模拟业务逻辑  </span></span><br><span class="line">System.out.println(<span class="string">&quot;performTransaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/bccbdfb8/27.png" class><img src="/bccbdfb8/28.png" class><img src="/bccbdfb8/29.png" class><p>经过<code>AsyncAnnotationBeanPostProcessor.post</code>处理后，会为原始bean 生成一个代理对象，与暴露的早期引用不一致，最终会报错</p><h2 id="33-beanpostprocessor的不同过滤条件"><a href="#3-3-BeanPostProcessor的不同过滤条件" class="headerlink" title="3.3 ## BeanPostProcessor的不同过滤条件"></a>3.3 ## BeanPostProcessor的不同过滤条件</h2><p>在AbstractAdvisingBeanPostProcessor 引发异常的这2个例子中，能够看出，有机会对bean 生成代理的2处逻辑，对要执行的BeanPostProcessor有不同的过滤条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactory</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">AutowireCapableBeanFactory</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;  </span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;  </span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;  </span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;  </span><br><span class="line"><span class="keyword">if</span> (bp <span class="keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;  </span><br><span class="line"><span class="type">SmartInstantiationAwareBeanPostProcessor</span> <span class="variable">ibp</span> <span class="operator">=</span> (SmartInstantiationAwareBeanPostProcessor) bp;  </span><br><span class="line">exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> exposedObject;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span><br><span class="line"><span class="keyword">throws</span> BeansException &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> existingBean;</span><br><span class="line"><span class="keyword">for</span> (BeanPostProcessor processor : getBeanPostProcessors()) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">current</span> <span class="operator">=</span> processor.postProcessAfterInitialization(result, beanName);</span><br><span class="line"><span class="keyword">if</span> (current == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = current;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>getEarlyBeanReference</code> 中只执行 <code>AbstractAutoProxyCreator</code>的子类，在Springboot 启动的项目中，就是<code>AnnotationAwareAspectJAutoProxyCreator</code></li><li>在init 阶段的<code>applyBeanPostProcessorsAfterInitialization</code> 中，会执行所有<code>BeanPostProcessor</code></li></ol><p>所以在有动态代理的循环依赖+暴露引用的时候，如果其中包含了除<code>AbstractAutoProxyCreator</code>子类外可生成代理的<code>BeanPostProcessor</code>， 就会产生一个类的2个实例，违反单例模式报错。</p><p>分析到这，可以看出，一个bean 只要暴露了早期引用，那么在init 阶段就绝不能再执行任何生成代理的操作了，因为一旦有代理操作就会再生成一个新的引用，就会有问题。</p><p>如果没有暴露早期引用，init 阶段随便几个代理操作都行。</p><p>比如把SpringTransactionService 中的userService 去掉， 把前面提到的各种可以生成代理的操作全部叠加，启动都是没有问题的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableAsync</span>  </span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringTransactionService</span> &#123;  </span><br><span class="line"><span class="meta">@Async</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">performTransaction</span><span class="params">()</span> &#123;  </span><br><span class="line"><span class="comment">// 模拟业务逻辑  </span></span><br><span class="line">System.out.println(<span class="string">&quot;performTransaction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-存在多个-abstractautoproxycreator"><a href="#4-存在多个-AbstractAutoProxyCreator" class="headerlink" title="4. 存在多个 AbstractAutoProxyCreator"></a>4. 存在多个 <code>AbstractAutoProxyCreator</code></h1><p>再来分析另外一种 有多个<code>AbstractAutoProxyCreator</code></p><p>spring默认保证一个容器中只能有一个AbstractAutoProxyCreator 子类存在 ，如过手动添加或者自定义会出现多个APC情况。</p><p>这里直接分析源码，假设有2个AbstractAutoProxyCreator 子类存在。</p><h2 id="41-getearlybeanreference"><a href="#4-1-getEarlyBeanReference" class="headerlink" title="4.1 getEarlyBeanReference"></a>4.1 getEarlyBeanReference</h2><p>来看下早期引用的获取逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutowireCapableBeanFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractBeanFactory</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">AutowireCapableBeanFactory</span> &#123;</span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(String beanName, RootBeanDefinition mbd, Object bean)</span> &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">exposedObject</span> <span class="operator">=</span> bean;</span><br><span class="line"><span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line"><span class="keyword">for</span> (SmartInstantiationAwareBeanPostProcessor bp : getBeanPostProcessorCache().smartInstantiationAware) &#123;</span><br><span class="line">exposedObject = bp.getEarlyBeanReference(exposedObject, beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getEarlyBeanReference</span><span class="params">(Object bean, String beanName)</span> &#123;  </span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);  </span><br><span class="line"><span class="built_in">this</span>.earlyProxyReferences.put(cacheKey, bean);  </span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由于在调用<code>AbstractAutoProxyCreator.getEarlyBeanReference</code>时， 每次入参bean 其实都是上一个<code>AbstractAutoProxyCreator</code>处理结果。</p><p>对于第一层代理来说<code>earlySingletonReferences</code>这个map 中的value 是原始bean<br>对于第二层代理来说<code>earlySingletonReferences</code>这个map 中的value 是第一层代理生成的代理对象。</p><p>⚠️ 每个<code>AbstractAutoProxyCreator</code>实例都有自己的<code>earlySingletonReferences</code></p><p>所以那么第2层代理实际是对第一层代理生成的代理对象又代理了一层，最终生成的早期引用，即放入第二级缓存的数据也是第二层代理对象</p><h2 id="42-postprocessafterinitialization"><a href="#4-2-postProcessAfterInitialization" class="headerlink" title="4.2 postProcessAfterInitialization"></a>4.2 postProcessAfterInitialization</h2><p>那么当来到init阶段的bean后处理逻辑<br>当执行第一层代理的postProcessAfterInitialization时，入参bean 时原始bean, 第一层代理<code>earlySingletonReferences</code> 中能找到对应的值，不会重复执行<code>wrapIfNecessary</code>逻辑，直接返回入参原始bean。</p><p>继续执行for循环，来到第二层代理，第二层代理earlySingletonReference 存储的是bean 第一层代理的引用， 这里入参bean 还是原始bean， <code>this.earlyProxyReferences.remove(cacheKey) != bean</code>条件成立，会执行<code>wrapIfNecessary</code>逻辑次 会创建一个新的代理对象，经过第二层代理处理后，init 阶段返回的exposedObject已经和提前暴露的早期引用不一致了，会报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line">  <span class="comment">// 生成了早期引用的bean缓存，</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; earlyProxyReferences = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="number">16</span>);</span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123; </span><br><span class="line"><span class="comment">// 如果 `bean` 为 `null`，则直接返回 `null`。</span></span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;  </span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);  </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;  </span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> bean;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAutoProxyCreator</span> <span class="keyword">extends</span> <span class="title class_">ProxyProcessorSupport</span>  </span><br><span class="line"><span class="keyword">implements</span> <span class="title class_">SmartInstantiationAwareBeanPostProcessor</span>, BeanFactoryAware &#123;</span><br><span class="line"><span class="meta">@Override</span>  </span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(<span class="meta">@Nullable</span> Object bean, String beanName)</span> &#123;  </span><br><span class="line"><span class="keyword">if</span> (bean != <span class="literal">null</span>) &#123;  </span><br><span class="line"><span class="type">Object</span> <span class="variable">cacheKey</span> <span class="operator">=</span> getCacheKey(bean.getClass(), beanName);  </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.earlyProxyReferences.remove(cacheKey) != bean) &#123;  </span><br><span class="line"><span class="keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> bean;  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="5-解决方案"><a href="#5-解决方案" class="headerlink" title="5. 解决方案"></a>5. 解决方案</h1><ol><li>使用合理的Bean注解</li><li>使用@Lazy 注解</li><li>重构你的代码</li></ol><h1 id="6参考文章"><a href="#6-参考文章" class="headerlink" title="6.参考文章"></a>6.参考文章</h1><p><a href="https://mp.weixin.qq.com/s/cqkZEvmmh7jnNt2K5r_lXg">Spring循环依赖那些事儿（含Spring详细流程图）</a></p><p><a href="https://mp.weixin.qq.com/s/DDgYHPChoo63-kL06PACog">一文详解 Spring Bean 循环依赖</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;建议了解以下内容后再阅读本文&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sunyan.xyz/50be4554/&quot;&gt;Spring IOC容器 和 Spring bean&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://sunyan.xyz/114991e5/&quot;&gt;Spr</summary>
      
    
    
    
    
    <category term="java" scheme="http://example.com/tags/java/"/>
    
    <category term="Spring" scheme="http://example.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Understanding LSTM Networks</title>
    <link href="http://example.com/4579c6a3/"/>
    <id>http://example.com/4579c6a3/</id>
    <published>2024-07-16T10:07:01.000Z</published>
    <updated>2024-09-05T11:49:33.684Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/">Understanding LSTM Networks</a></p><h1 id="recurrent-neural-networks"><a href="#Recurrent-Neural-Networks" class="headerlink" title="Recurrent Neural Networks"></a>Recurrent Neural Networks</h1><p>递归神经网络<br>Humans don’t start their thinking from scratch every second. As you read this essay, you understand each word based on your understanding of previous words. You don’t throw everything away and start thinking from scratch again. Your thoughts have persistence.<br>人类不会每秒都从头开始思考。当你阅读这篇文章时，你会基于对之前词语的理解来理解每个词。你不会把所有东西都丢掉然后重新开始思考。你的思维是有连续性的。</p><p>Traditional neural networks can’t do this, and it seems like a major shortcoming. For example, imagine you want to classify what kind of event is happening at every point in a movie. It’s unclear how a traditional neural network could use its reasoning about previous events in the film to inform later ones.<br>传统的神经网络做不到这一点，这似乎是一个主要的缺陷。比如，想象一下你想对电影中每个时刻发生的事件类型进行分类。目前尚不清楚传统的神经网络如何利用其对电影中先前事件的推理来为后来的事件提供信息。</p><p>Recurrent neural networks address this issue. They are networks with loops in them, allowing information to persist.<br>循环神经网络解决了这个问题。它们是内部带有循环的网络，允许信息持续存在。</p><img src="/4579c6a3/1.png" class><p><strong>Recurrent Neural Networks have loops.  递归神经网络有循环。</strong></p><p>In the above diagram, a chunk of neural network, 𝐴, looks at some input $𝑥_𝑡$ and outputs a value $ℎ_𝑡$. A loop allows information to be passed from one step of the network to the next.<br>在上图中，神经网络的一部分 $A$ ,查看一些输入$x_t​$ 并输出一个值 $h_t$。一个循环允许信息从网络的一个步骤传递到下一个步骤。</p><p>These loops make recurrent neural networks seem kind of mysterious. However, if you think a bit more, it turns out that they aren’t all that different than a normal neural network. A recurrent neural network can be thought of as multiple copies of the same network, each passing a message to a successor. Consider what happens if we unroll the loop:<br>这些循环使循环神经网络看起来有点神秘。然而，如果你多想一点，就会发现它们与普通的神经网络并没有太大的不同。递归神经网络可以被认为是同一网络的多个副本，每个副本将消息传递给继任者。考虑一下如果我们展开循环会发生什么：<br><img src="/4579c6a3/2.png" class><br><strong>An unrolled recurrent neural network.  展开的循环神经网络。</strong></p><p>This chain-like nature reveals that recurrent neural networks are intimately related to sequences and lists. They’re the natural architecture of neural network to use for such data.<br>这种链式结构表明，递归神经网络与序列和列表密切相关。它们是处理此类数据的自然神经网络架构。</p><p>And they certainly are used! In the last few years, there have been incredible success applying RNNs to a variety of problems: speech recognition, language modeling, translation, image captioning… The list goes on. I’ll leave discussion of the amazing feats one can achieve with RNNs to Andrej Karpathy’s excellent blog post, <a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/">The Unreasonable Effectiveness of Recurrent Neural Networks</a>. But they really are pretty amazing.<br>他们当然被使用了！在过去的几年里，将RNN应用于各种问题取得了令人难以置信的成功：语音识别、语言建模、翻译、图像字幕……这样的例子不胜枚举。我将把关于RNN可以实现的惊人壮举的讨论留给Andrej Karpathy的优秀博客文章，递归神经网络的不合理有效性。但他们真的非常了不起。</p><p>Essential to these successes is the use of “LSTMs,” a very special kind of recurrent neural network which works, for many tasks, much much better than the standard version. Almost all exciting results based on recurrent neural networks are achieved with them. It’s these LSTMs that this essay will explore.<br>这些成功的关键是“LSTM”的使用，这是一种非常特殊的递归神经网络，对于许多任务，它比标准版本要好得多。几乎所有基于递归神经网络的令人兴奋的结果都是通过它们实现的。本文将探讨的正是这些 LSTM。</p><h1 id="the-problem-of-long-term-dependencies"><a href="#The-Problem-of-Long-Term-Dependencies" class="headerlink" title="The Problem of Long-Term Dependencies"></a>The Problem of Long-Term Dependencies</h1><p>长期依赖性问题</p><p>One of the appeals of RNNs is the idea that they might be able to connect previous information to the present task, such as using previous video frames might inform the understanding of the present frame. If RNNs could do this, they’d be extremely useful. But can they? It depends.<br>RNN的吸引力之一是，它们可能能够将先前的信息与当前任务联系起来，例如使用以前的视频帧可能会为理解当前帧提供信息。如果RNN可以做到这一点，它们将非常有用。但是他们能做到吗？这要视情况而定。</p><p>Sometimes, we only need to look at recent information to perform the present task. For example, consider a language model trying to predict the next word based on the previous ones. If we are trying to predict the last word in “the clouds are in the _sky_,” we don’t need any further context – it’s pretty obvious the next word is going to be sky. In such cases, where the gap between the relevant information and the place that it’s needed is small, RNNs can learn to use the past information.<br>有时候，我们只需要查看最近的信息就可以完成当前的任务。例如，考虑一个语言模型,它尝试基于前面的单词来预测下一个单词。如果我们试图预测“the clouds are in the sky”中的最后一个单词，我们不需要任何进一步的上下文——很明显下一个单词将是sky。在这种情况下，相关信息和所需位置之间的间隔较小，RNNs可以学习使用过去的信息。<br><img src="/4579c6a3/3.png" class></p><p>But there are also cases where we need more context. Consider trying to predict the last word in the text “I grew up in France… I speak fluent _French_.” Recent information suggests that the next word is probably the name of a language, but if we want to narrow down which language, we need the context of France, from further back. It’s entirely possible for the gap between the relevant information and the point where it is needed to become very large.<br>但在某些情况下，我们需要更多的背景信息。考虑试图预测文本“I grew up in France… I speak fluent French.”中的最后一个单词。最近的信息表明下一个单词可能是某种语言的名称，但如果我们想缩小语言范围，我们需要更早的法国这一背景信息。相关信息和需要使用该信息的点之间的间隔完全有可能变得非常大。</p><p>Unfortunately, as that gap grows, RNNs become unable to learn to connect the information.<br>不幸的是，随着这种间隔的扩大，RNN变得无法学习去连接信息。</p><img src="/4579c6a3/4.png" class><p>In theory, RNNs are absolutely capable of handling such “long-term dependencies.” A human could carefully pick parameters for them to solve toy problems of this form. Sadly, in practice, RNNs don’t seem to be able to learn them. The problem was explored in depth by <a href="http://people.idsia.ch/~juergen/SeppHochreiter1991ThesisAdvisorSchmidhuber.pdf">Hochreiter (1991) [German]</a> and <a href="http://www-dsi.ing.unifi.it/~paolo/ps/tnn-94-gradient.pdf">Bengio, et al. (1994)</a>, who found some pretty fundamental reasons why it might be difficult.<br>理论上，RNNs完全有能力处理这种“长期依赖”。人类可以仔细挑选参数，使它们解决这种形式的玩具问题。遗憾的是，在实际应用中，RNNs似乎无法学会它们。这个问题在Hochreiter（1991）和Bengio等人（1994）的研究中得到了深入探讨，他们发现了一些可能导致这一困难的基本原因。</p><p>Thankfully, LSTMs don’t have this problem!<br>值得庆幸的是，LSTM 没有这个问题！</p><h1 id="lstm-networks"><a href="#LSTM-Networks" class="headerlink" title="LSTM Networks"></a>LSTM Networks</h1><p>Long Short Term Memory networks – usually just called “LSTMs” – are a special kind of RNN, capable of learning long-term dependencies. They were introduced by <a href="http://www.bioinf.jku.at/publications/older/2604.pdf">Hochreiter &amp; Schmidhuber (1997)</a>, and were refined and popularized by many people in following work.<a href="https://colah.github.io/posts/2015-08-Understanding-LSTMs/#fn1">1</a> They work tremendously well on a large variety of problems, and are now widely used.<br>长短期记忆网络——通常简称为“LSTMs”——是一种特殊的RNN，能够学习长期依赖。它们由Hochreiter和Schmidhuber（1997）引入，并在随后的工作中被许多人改进和推广。LSTMs在大量不同的问题上表现出色，现在被广泛使用。</p><p>LSTMs are explicitly designed to avoid the long-term dependency problem. Remembering information for long periods of time is practically their default behavior, not something they struggle to learn!<br>LSTMs被明确设计用于避免长期依赖问题。记住长时间的信息几乎是它们的默认行为，而不是它们需要努力学习的东西！</p><p>All recurrent neural networks have the form of a chain of repeating modules of neural network. In standard RNNs, this repeating module will have a very simple structure, such as a single tanh layer.<br>所有递归神经网络都具有神经网络重复模块链的形式。在标准 RNN 中，该重复模块将具有非常简单的结构，例如单个 tanh 层。</p><img src="/4579c6a3/5.png" class><p><strong>The repeating module in a standard RNN contains a single layer.<br>标准 RNN 中的重复模块包含单层。</strong></p><p>LSTMs also have this chain like structure, but the repeating module has a different structure. Instead of having a single neural network layer, there are four, interacting in a very special way.<br>LSTM 也具有这种链状结构，但重复模块具有不同的结构。不是只有一个神经网络层，而是有四个，以一种非常特殊的方式进行交互。</p><img src="/4579c6a3/6.png" class><p><strong>The repeating module in an LSTM contains four interacting layers.<br>LSTM 中的重复模块包含四个交互层。</strong></p><p>Don’t worry about the details of what’s going on. We’ll walk through the LSTM diagram step by step later. For now, let’s just try to get comfortable with the notation we’ll be using.<br>不用担心具体的细节。我们稍后会一步步讲解LSTM的图表。现在，让我们先熟悉一下我们将要使用的符号。<br><img src="/4579c6a3/7.png" class><br>In the above diagram, each line carries an entire vector, from the output of one node to the inputs of others. The pink circles represent pointwise operations, like vector addition, while the yellow boxes are learned neural network layers. Lines merging denote concatenation, while a line forking denote its content being copied and the copies going to different locations.<br>在上图中，每条线都带有一个完整的向量，从一个节点的输出到其他节点的输入。粉红色的圆圈代表逐点运算，如向量加法，而黄色框是学习的神经网络层。合并的行表示串联，而分叉的行表示正在复制其内容并将副本发送到不同的位置。</p><h1 id="the-core-idea-behind-lstms"><a href="#The-Core-Idea-Behind-LSTMs" class="headerlink" title="The Core Idea Behind LSTMs"></a>The Core Idea Behind LSTMs</h1><p>LSTM 背后的核心思想</p><p>The key to LSTMs is the cell state, the horizontal line running through the top of the diagram.<br>LSTMs的关键是单元状态，这条横线贯穿了图表的顶部。</p><p>The cell state is kind of like a conveyor belt. It runs straight down the entire chain, with only some minor linear interactions. It’s very easy for information to just flow along it unchanged.<br>单元状态有点像传送带。它直接沿着整个链条运行，只有一些小的线性交互。信息可以非常容易地沿着它不变地流动。</p><img src="/4579c6a3/8.png" class><p>The LSTM does have the ability to remove or add information to the cell state, carefully regulated by structures called gates.<br>LSTM确实具有从单元状态中移除或添加信息的能力，这些操作由称为门控的结构严格调控。</p><p>Gates are a way to optionally let information through. They are composed out of a sigmoid neural net layer and a pointwise multiplication operation.<br>门控是一种选择性地让信息通过的方式。它们由一个sigmoid神经网络层和一个逐点乘法操作组成。<br><img src="/4579c6a3/9.png" class><br>The sigmoid layer outputs numbers between zero and one, describing how much of each component should be let through. A value of zero means “let nothing through,” while a value of one means “let everything through!”<br>sigmoid 层输出介于 0 和 1 之间的数字，描述每个组件应通过多少。值为零表示“什么都不让通过”，而值为 1 表示“让所有东西都通过！”</p><p>An LSTM has three of these gates, to protect and control the cell state.<br>LSTM 有三个这样的门，用于保护和控制单元状态。</p><h1 id="step-by-step-lstm-walk-through"><a href="#Step-by-Step-LSTM-Walk-Through" class="headerlink" title="Step-by-Step LSTM Walk Through"></a>Step-by-Step LSTM Walk Through</h1><p>循序渐进的 LSTM 演练</p><h2 id="forget-gate-layer"><a href="#forget-gate-layer" class="headerlink" title="forget gate layer"></a>forget gate layer</h2><p>The first step in our LSTM is to decide what information we’re going to throw away from the cell state. This decision is made by a sigmoid layer called the “forget gate layer.” It looks at $h_{t−1}$ and $x_t$, and outputs a number between 00 and 11 for each number in the cell state $C_{t−1}$. A 1 represents “completely keep this” while a 0 represents “completely get rid of this.”<br>LSTM的第一步是决定要从单元状态中丢弃哪些信息。这个决策是由一个名为“遗忘门层”的sigmoid层做出的。它查看 $h_{t-1}​$ 和 $x_t$，并为单元状态 $C_{t-1}$ 中的每个数字输出一个介于0和1之间的数值。1表示“完全保留这个”，而0表示“完全丢弃这个”。</p><p>Let’s go back to our example of a language model trying to predict the next word based on all the previous ones. In such a problem, the cell state might include the gender of the present subject, so that the correct pronouns can be used. When we see a new subject, we want to forget the gender of the old subject.<br>让我们回到我们的例子，一个语言模型试图基于所有前面的单词来预测下一个单词。在这样的问题中，单元状态可能包含当前主语的性别，以便使用正确的代词。当我们看到一个新的主语时，我们想忘记旧主语的性别。<br><img src="/4579c6a3/10.png" class></p><h2 id="input-gate-layer"><a href="#input-gate-layer" class="headerlink" title="input gate layer"></a>input gate layer</h2><p>The next step is to decide what new information we’re going to store in the cell state. This has two parts. First, a sigmoid layer called the “input gate layer” decides which values we’ll update. Next, a tanh layer creates a vector of new candidate values, $\tilde{C}_t$, that could be added to the state. In the next step, we’ll combine these two to create an update to the state.<br>下一步是决定要在单元状态中存储哪些新信息。这包括两个部分。首先，一个名为“输入门层”的sigmoid层决定我们将更新哪些值。接下来，一个tanh层创建一个新的候选值向量$\tilde{C}_t$，这些候选值可以被添加到状态中。在下一步中，我们将结合这两部分来更新状态。</p><p>In the example of our language model, we’d want to add the gender of the new subject to the cell state, to replace the old one we’re forgetting.<br>在我们的语言模型示例中，我们希望将新主语的性别添加到单元格状态中，以替换我们忘记的旧主语。</p><img src="/4579c6a3/11.png" class><p>It’s now time to update the old cell state$C_{t-1}$, into the new cell state $C_t$​. The previous steps already decided what to do, we just need to actually do it.<br>现在是时候将旧的单元格状态$C_{t-1}$更新为新的单元格状态 $C_t$​了。前面的步骤已经决定了要做什么，我们只需要实际去执行它。</p><p>We multiply the old state by $𝑓_𝑡$, forgetting the things we decided to forget earlier. Then we add $i_t \ast \tilde{C}_t$. This is the new candidate values, scaled by how much we decided to update each state value.<br>我们将旧状态乘以 $f_t$，忘记我们之前决定忘记的内容。然后我们加上 $i_t \ast \tilde{C}_t$。这些是新的候选值，按我们决定更新每个状态值的程度进行缩放。</p><p>In the case of the language model, this is where we’d actually drop the information about the old subject’s gender and add the new information, as we decided in the previous steps.<br>在语言模型的情况下，正如我们在前面的步骤中决定的那样，我们实际上会删除有关旧主题性别的信息并添加新信息。</p><img src="/4579c6a3/12.png" class><h2 id="output-layer"><a href="#output-layer" class="headerlink" title="output  layer"></a>output  layer</h2><p>Finally, we need to decide what we’re going to output. This output will be based on our cell state, but will be a filtered version. First, we run a sigmoid layer which decides what parts of the cell state we’re going to output. Then, we put the cell state through tanh (to push the values to be between −1 and 1) and multiply it by the output of the sigmoid gate, so that we only output the parts we decided to.<br>最后，我们需要决定输出什么。这个输出将基于我们的单元状态，但会是一个过滤后的版本。首先，我们运行一个sigmoid层来决定要输出单元状态的哪些部分。然后，我们将单元状态通过tanh（将值压缩到-1到1之间），并将其与sigmoid门的输出相乘，这样我们只输出我们决定输出的部分。</p><p>For the language model example, since it just saw a subject, it might want to output information relevant to a verb, in case that’s what is coming next. For example, it might output whether the subject is singular or plural, so that we know what form a verb should be conjugated into if that’s what follows next.<br>对于语言模型的例子，由于它刚刚看到一个主语，它可能想输出与动词相关的信息，以防接下来需要动词。例如，它可能会输出主语是单数还是复数，这样我们就知道如果接下来是动词，该动词应该变成什么形式。</p><img src="/4579c6a3/13.png" class><h1 id="variants-on-long-short-term-memory"><a href="#Variants-on-Long-Short-Term-Memory" class="headerlink" title="Variants on Long Short Term Memory"></a>Variants on Long Short Term Memory</h1><p>长短期记忆的变体</p><p>What I’ve described so far is a pretty normal LSTM. But not all LSTMs are the same as the above. In fact, it seems like almost every paper involving LSTMs uses a slightly different version. The differences are minor, but it’s worth mentioning some of them.<br>我到目前为止描述的是一个相当普通的LSTM。但并不是所有的LSTM都与上述相同。实际上，几乎每篇涉及LSTM的论文都使用了稍微不同的版本。这些差异很小，但值得一提。</p><p>One popular LSTM variant, introduced by <a href="ftp://ftp.idsia.ch/pub/juergen/TimeCount-IJCNN2000.pdf">Gers &amp; Schmidhuber (2000)</a>, is adding “peephole connections.” This means that we let the gate layers look at the cell state.<br>一个由Gers和Schmidhuber（2000）引入的流行LSTM变体是添加“窥视连接”。这意味着我们让门控层查看单元状态。</p><img src="/4579c6a3/14.png" class><p>The above diagram adds peepholes to all the gates, but many papers will give some peepholes and not others.<br>上图为所有门控添加了窥视连接，但许多论文会只为部分门控添加窥视连接，而不是全部。</p><p>Another variation is to use coupled forget and input gates. Instead of separately deciding what to forget and what we should add new information to, we make those decisions together. We only forget when we’re going to input something in its place. We only input new values to the state when we forget something older.<br>另一种变体是使用耦合的遗忘门和输入门。我们不是分别决定要忘记什么以及要添加什么新信息，而是将这些决策结合在一起。我们只有在要输入新信息时才会忘记某些内容。只有在忘记旧信息时，我们才会将新值输入到状态中。</p><img src="/4579c6a3/15.png" class><p>A slightly more dramatic variation on the LSTM is the Gated Recurrent Unit, or GRU, introduced by <a href="http://arxiv.org/pdf/1406.1078v3.pdf">Cho, et al. (2014)</a>. It combines the forget and input gates into a single “update gate.” It also merges the cell state and hidden state, and makes some other changes. The resulting model is simpler than standard LSTM models, and has been growing increasingly popular.<br>LSTM的一个稍微更显著的变体是门控循环单元（GRU），由Cho等人（2014）引入。它将遗忘门和输入门组合成一个“更新门”。它还合并了单元状态和隐藏状态，并做了一些其他的改变。最终的模型比标准的LSTM模型更简单，并且越来越受欢迎。</p><img src="/4579c6a3/16.png" class><p>These are only a few of the most notable LSTM variants. There are lots of others, like Depth Gated RNNs by <a href="http://arxiv.org/pdf/1508.03790v2.pdf">Yao, et al. (2015)</a>. There’s also some completely different approach to tackling long-term dependencies, like Clockwork RNNs by <a href="http://arxiv.org/pdf/1402.3511v1.pdf">Koutnik, et al. (2014)</a>.<br>这些只是一些最著名的LSTM变体。还有许多其他变体，例如Yao等人（2015）提出的深度门控RNN。此外，还有一些完全不同的方法来解决长期依赖问题，例如Koutnik等人（2014）提出的时钟式RNN。</p><p>Which of these variants is best? Do the differences matter? <a href="http://arxiv.org/pdf/1503.04069.pdf">Greff, et al. (2015)</a> do a nice comparison of popular variants, finding that they’re all about the same. <a href="http://jmlr.org/proceedings/papers/v37/jozefowicz15.pdf">Jozefowicz, et al. (2015)</a> tested more than ten thousand RNN architectures, finding some that worked better than LSTMs on certain tasks.<br>这些变体中哪一个最好？差异重要吗？Greff等人（2015）对流行变体进行了很好的比较，发现它们的表现几乎相同。Jozefowicz等人（2015）测试了超过一万种RNN架构，发现其中一些在某些任务上的表现比LSTMs更好。</p><h1 id="conclusion-结论"><a href="#Conclusion-结论" class="headerlink" title="Conclusion 结论"></a>Conclusion 结论</h1><p>Earlier, I mentioned the remarkable results people are achieving with RNNs. Essentially all of these are achieved using LSTMs. They really work a lot better for most tasks!<br>前面，我提到了人们用递归神经网络（RNNs）取得的显著成果。基本上所有这些成果都是使用LSTMs实现的。对于大多数任务，LSTMs的效果确实要好得多！</p><p>Written down as a set of equations, LSTMs look pretty intimidating. Hopefully, walking through them step by step in this essay has made them a bit more approachable.<br>作为一组方程写下来，LSTMs看起来相当令人生畏。希望通过在本文中一步一步地讲解它们，使它们变得更容易理解。</p><p>LSTMs were a big step in what we can accomplish with RNNs. It’s natural to wonder: is there another big step? A common opinion among researchers is: “Yes! There is a next step and it’s attention!” The idea is to let every step of an RNN pick information to look at from some larger collection of information. For example, if you are using an RNN to create a caption describing an image, it might pick a part of the image to look at for every word it outputs. In fact, <a href="http://arxiv.org/pdf/1502.03044v2.pdf">Xu, _et al._ (2015)</a> do exactly this – it might be a fun starting point if you want to explore attention! There’s been a number of really exciting results using attention, and it seems like a lot more are around the corner…<br>LSTMs是我们用RNNs能实现的一个大进步。很自然地会有人问：还有另一个大进步吗？研究人员的一个普遍看法是：“是的！下一个进步是注意力机制！”这个想法是让RNN的每一步都从一些更大的信息集合中选择要看的信息。例如，如果你使用RNN来创建描述图像的标题，它可能会为它输出的每个单词选择图像的一部分。事实上，Xu等人（2015）正是这样做的——如果你想探索注意力机制，这可能是一个有趣的起点！使用注意力机制已经取得了许多非常令人兴奋的成果，似乎还会有更多的成果即将到来……</p><p>Attention isn’t the only exciting thread in RNN research. For example, Grid LSTMs by <a href="http://arxiv.org/pdf/1507.01526v1.pdf">Kalchbrenner, _et al._ (2015)</a> seem extremely promising. Work using RNNs in generative models – such as <a href="http://arxiv.org/pdf/1502.04623.pdf">Gregor, _et al._ (2015)</a>, <a href="http://arxiv.org/pdf/1506.02216v3.pdf">Chung, _et al._ (2015)</a>, or <a href="http://arxiv.org/pdf/1411.7610v3.pdf">Bayer &amp; Osendorfer (2015)</a> – also seems very interesting. The last few years have been an exciting time for recurrent neural networks, and the coming ones promise to only be more so!<br>注意力机制并不是RNN研究中唯一令人兴奋的方向。例如，Kalchbrenner等人（2015）的Grid LSTMs看起来非常有前途。在生成模型中使用RNN的工作——例如Gregor等人（2015）、Chung等人（2015）或Bayer和Osendorfer（2015）的工作——也非常有趣。过去几年是递归神经网络的激动人心的时期，未来几年只会更加激动人心！</p><h1 id="acknowledgments-确认"><a href="#Acknowledgments-确认" class="headerlink" title="Acknowledgments 确认"></a>Acknowledgments 确认</h1><p>I’m grateful to a number of people for helping me better understand LSTMs, commenting on the visualizations, and providing feedback on this post.<br>我感谢许多人帮助我更好地理解 LSTM，对可视化进行评论，并对这篇文章提供反馈。</p><p>I’m very grateful to my colleagues at Google for their helpful feedback, especially <a href="http://research.google.com/pubs/OriolVinyals.html">Oriol Vinyals</a>, <a href="http://research.google.com/pubs/GregCorrado.html">Greg Corrado</a>, <a href="http://research.google.com/pubs/JonathonShlens.html">Jon Shlens</a>, <a href="http://people.cs.umass.edu/~luke/">Luke Vilnis</a>, and <a href="http://www.cs.toronto.edu/~ilya/">Ilya Sutskever</a>. I’m also thankful to many other friends and colleagues for taking the time to help me, including <a href="https://www.linkedin.com/pub/dario-amodei/4/493/393">Dario Amodei</a>, and <a href="http://cs.stanford.edu/~jsteinhardt/">Jacob Steinhardt</a>. I’m especially thankful to <a href="http://www.kyunghyuncho.me/">Kyunghyun Cho</a> for extremely thoughtful correspondence about my diagrams.<br>我非常感谢 Google 同事提供的有益反馈，尤其是 Oriol Vinyals、Greg Corrado、Jon Shlens、Luke Villnis 和 Ilya Sutskever。我还要感谢许多其他朋友和同事抽出时间帮助我，包括 Dario Amodei 和 Jacob Steinhardt。我特别感谢 Kyunghyun Cho 对我的图表进行了非常周到的通信。</p><p>Before this post, I practiced explaining LSTMs during two seminar series I taught on neural networks. Thanks to everyone who participated in those for their patience with me, and for their feedback.<br>在这篇文章之前，我在我教授的关于神经网络的两个系列研讨会上练习了解释 LSTM。感谢所有参与活动的人对我的耐心和反馈。</p><h1 id="注释-如何理解门控结构的计算"><a href="#注释-如何理解门控结构的计算" class="headerlink" title="注释-如何理解门控结构的计算"></a>注释-如何理解门控结构的计算</h1><p>根据前面的文章， 我们已经知道基础 神经网络和 基础RNN 中，数据从输入层到隐藏层到输出层的计算，这里再复习一下</p><h2 id="基础神经网络"><a href="#基础神经网络" class="headerlink" title="基础神经网络"></a>基础神经网络</h2><p><strong>隐藏层</strong><br>$h_t​=f(W_{xh​}x_t​+b_h​)$</p><ul><li>$x_t$​：当前输入</li><li>$W_{xh}$：输入层到隐藏层的权重矩阵</li><li>$b_h$​：偏置</li><li>$f$：激活函数（如tanh或ReLU）</li></ul><p>计算隐藏状态分为2个步骤</p><ol><li>计算隐藏层的输入加权和：</li><li>应用激活函数，计算隐藏层的输出<h2 id="基础rnn"><a href="#基础RNN" class="headerlink" title="基础RNN"></a>基础RNN</h2></li></ol><p>RNN的隐藏层具有循环连接，即多了一个隐藏层到隐藏层的权重矩阵参与计算 ，使得每个隐藏状态依赖于前一时间步的隐藏状态和当前时间步的输入。公式如下：<br>$h_t​=f(W_{hh}​h_{t−1}​+W_{xh​}x_t​+b_h​)$</p><ul><li>$h_t​$：当前时间步的隐藏状态</li><li>$h_{t-1}$：前一时间步的隐藏状态</li><li>$x_t$​：当前时间步的输入</li><li>$W_{hh}$​：隐藏状态到隐藏状态的权重矩阵</li><li>$W_{xh}$：输入到隐藏状态的权重矩阵</li><li>$b_h$​：偏置</li><li>$f$：激活函数（如tanh或ReLU）</li></ul><p>从上面文章中可以看到， 不论计算过程在复杂，都是要根据输入求输出。。 而在LSTM 中， 复杂的点在于。隐藏层的计算由简单的隐藏层-隐藏层权重矩阵参与计算 拆分成了多个步骤</p><h2 id="lstm"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h2><h3 id="1-遗忘门forget-gate"><a href="#1-遗忘门（Forget-Gate）" class="headerlink" title="1. 遗忘门（Forget Gate）"></a>1. 遗忘门（Forget Gate）</h3><p>遗忘门控制单元状态中哪些信息需要被保留或丢弃。遗忘门接收当前时间步的输入 $x_t$和前一时间步的隐藏状态 $h_{t-1}$，通过一个$Sigmoid$函数计算得到一个介于0和1之间的标量（或向量），用于缩放前一时间步的细胞状态。</p><p>公式如下： $f_t = \sigma(W_f \cdot [h_{t-1}, x_t] + b_f)$<br>如果把层级关系也在公式中体现出来，该公式可以细化成如下格式：<br>$f_t^l = \sigma(W_f \cdot [h_{t-1}^l, x_t^{l-1}] + b_f)$</p><p>其中 $x$  也可以替换成其他变量，只要是代表当前时间步的输入即可。<br>例如在 <a href="https://arxiv.org/pdf/1409.2329">RECURRENT NEURAL NETWORK REGULARIZATION</a>   该公式就表示成了 $f_t^l = \sigma(W_f \cdot [h_{t-1}^l, h_t^{l-1}] + b_f)$</p><ul><li>$[h_t, x_{t-1}]$或者$[h_t^{l-1}, h_{t-1}^l]$表示将当前输入和前一时间步的隐藏状态向量拼接成一个向量。</li><li>$W_f​$ 是该遗忘门的权重矩阵。</li><li>$b_f$​ 是偏置向量。</li><li>$\sigma$ 是$sigmoid$ 非线性激活函数，输出范围在0到1之间。</li></ul><h3 id="2-输入门input-gate"><a href="#2-输入门（Input-Gate）" class="headerlink" title="2. 输入门（Input Gate）"></a>2. 输入门（Input Gate）</h3><p>输入门控制新信息写入单元状态的过程。输入门同样接收当前时间步的输入 $x_t$和前一时间步的隐藏状态 $h_{t-1}$，并通过Sigmoid函数生成一个介于0和1之间的标量，表示允许多少新信息进入细胞状态。0表示完全不允许新信息进入，1表示完全允许新信息进入。<br>$tanh$层生成候选单元状态。</p><p>公式如下：<br>$i_t = \sigma(W_i \cdot [h_{t-1}, x_t] + b_i)$</p><p>$\tilde{C}_t = \tanh(W_C \cdot [h_{t-1}, x_t] + b_C)$</p><p>$W_i​$：输入门的权重矩阵，用于将前一时间步的隐藏状态和当前时间步的输入进行线性变换。<br>$W_C​$：候选细胞状态的权重矩阵，用于将前一时间步的隐藏状态和当前时间步的输入进行线性变换。</p><h3 id="3-单元状态cell-state"><a href="#3-单元状态（Cell-State）" class="headerlink" title="3. 单元状态（Cell State）"></a>3. 单元状态（Cell State）</h3><p>单元状态 $C_t$​ 是LSTM单元内部的长期记忆，它在时间步之间几乎直接传递，通过遗忘门和输入门的调节进行更新。新的单元状态由前一时间步的单元状态乘以遗忘门的输出加上输入门输出和候选值的乘积得到。</p><p>公式如下：$C_t = f_t \cdot C_{t-1} + i_t \cdot \tilde{C}_t$</p><h3 id="4-输出门output-gate-得到隐藏状态"><a href="#4-输出门（Output-Gate）-得到隐藏状态" class="headerlink" title="4. 输出门（Output Gate）- 得到隐藏状态"></a>4. 输出门（Output Gate）- 得到隐藏状态</h3><p>输出门决定哪些信息从细胞状态传递到隐藏状态（LSTM单元的输出）。输出门通过Sigmoid函数决定哪些信息将被输出，并将细胞状态通过Tanh层处理后乘以该输出。</p><p>公式如下：<br>$o_t = \sigma(W_o \cdot [h_{t-1}, x_t] + b_o)$<br>$h_t = o_t \cdot \tanh(C_t)$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://colah.github.io/posts/2015-08-Understanding-LSTMs/&quot;&gt;Understanding LSTM Networks&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;recurrent-neural-network</summary>
      
    
    
    
    
    <category term="AI" scheme="http://example.com/tags/AI/"/>
    
    <category term="神经网络" scheme="http://example.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Ilya sutskever‘s 30  papers" scheme="http://example.com/tags/Ilya-sutskever%E2%80%98s-30-papers/"/>
    
  </entry>
  
  <entry>
    <title>RECURRENT NEURAL NETWORK REGULARIZATION</title>
    <link href="http://example.com/7057a5e3/"/>
    <id>http://example.com/7057a5e3/</id>
    <published>2024-06-12T10:10:58.000Z</published>
    <updated>2024-06-16T14:23:22.616Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://arxiv.org/pdf/1409.2329">RECURRENT NEURAL NETWORK REGULARIZATION</a></p><h1 id="abstract-摘要"><a href="#ABSTRACT-摘要" class="headerlink" title="ABSTRACT 摘要"></a>ABSTRACT 摘要</h1><p>We present a simple regularization technique for Recurrent Neural Networks (RNNs) with Long Short-Term Memory (LSTM) units. Dropout, the most suc- cessful technique for regularizing neural networks, does not work well with RNNs and LSTMs. In this paper, we show how to correctly apply dropout to LSTMs, and show that it substantially reduces overfitting on a variety of tasks. These tasks include language modeling, speech recognition, image caption generation, and machine translation.<br>我们提出了一种用于长短期记忆（LSTM）单元的循环神经网络（RNN）的简单正则化技术。最成功的正则化神经网络技术——Dropout，在RNN和LSTM上效果不好。在本文中，我们展示了如何正确地将Dropout应用于LSTM，并证明它在各种任务上显著减少了过拟合。这些任务包括语言建模、语音识别、图像描述生成和机器翻译。</p><h1 id="1-introduction-引言"><a href="#1-INTRODUCTION-引言" class="headerlink" title="1 INTRODUCTION  引言"></a>1 INTRODUCTION  引言</h1><p>The Recurrent Neural Network (RNN) is neural sequence model that achieves state of the art per- formance on important tasks that include language modeling Mikolov (2012), speech recognition Graves et al. (2013), and machine translation Kalchbrenner &amp; Blunsom (2013). It is known that successful applications of neural networks require good regularization. Unfortunately, dropout Srivastava (2013), the most powerful regularization method for feedforward neural networks, does not work well with RNNs. As a result, practical applications of RNNs often use models that are too small because large RNNs tend to overfit. Existing regularization methods give relatively small improvements for RNNs Graves (2013). In this work, we show that dropout, when correctly used, greatly reduces overfitting in LSTMs, and evaluate it on three different problems.</p><p>The code for this work can be found in <a href="https://github.com/wojzaremba/lstm">https://github.com/wojzaremba/lstm</a>.</p><p>递归神经网络（RNN）是一种神经序列模型，可在重要任务上实现最先进的性能，包括语言建模Mikolov（2012），语音识别Graves等人（2013）和机器翻译Kalchbrenner&amp;Blunsom（2013）。众所周知，神经网络的成功应用需要良好的正则化。不幸的是，dropout Srivastava （2013） 是前馈神经网络最强大的正则化方法，但不能很好地用于 RNN。因此，RNN 的实际应用通常使用太小的模型，因为大型 RNN 往往会过度拟合。现有的正则化方法对RNNs Graves（2013）进行了相对较小的改进。在这项工作中，我们表明，如果正确使用，压差可以大大减少LSTM中的过拟合，并在三个不同的问题上对其进行评估。</p><p>此工作的代码可以在<a href="https://github.com/wojzaremba/lstm%E6%89%BE%E5%88%B0%E3%80%82">https://github.com/wojzaremba/lstm</a>找到。</p><h1 id="2-related-work"><a href="#2-RELATED-WORK" class="headerlink" title="2 RELATED WORK"></a>2 RELATED WORK</h1><p>Dropout Srivastava (2013) is a recently introduced regularization method that has been very suc- cessful with feed-forward neural networks. While much work has extended dropout in various ways Wang &amp; Manning (2013); Wan et al. (2013), there has been relatively little research in applying it to RNNs. The only paper on this topic is by Bayer et al. (2013), who focuses on “marginalized dropout” Wang &amp; Manning (2013), a noiseless deterministic approximation to standard dropout. Bayer et al. (2013) claim that conventional dropout does not work well with RNNs because the re- currence amplifies noise, which in turn hurts learning. In this work, we show that this problem can be fixed by applying dropout to a certain subset of the RNNs’ connections. As a result, RNNs can now also benefit from dropout.<br>Dropout Srivastava（2013）是一种最近引入的正则化方法，在前馈神经网络中非常成功。尽管很多工作以各种方式扩展了Dropout Wang &amp; Manning（2013）；Wan等（2013），但在RNN上应用它的研究相对较少。关于这个主题的唯一论文是Bayer等人（2013）的，他们专注于“边缘化Dropout” Wang &amp; Manning（2013），这是标准Dropout的一种无噪声确定性近似。Bayer等人（2013）认为传统的Dropout在RNN上效果不好，因为递归放大了噪声，进而影响了学习。在这项工作中，我们展示了通过将Dropout应用于RNN连接的某个子集可以解决这个问题。因此，RNN现在也可以受益于Dropout。</p><p>Independently of our work, Pham et al. (2013) developed the very same RNN regularization method and applied it to handwriting recognition. We rediscovered this method and demonstrated strong empirical results over a wide range of problems. Other work that applied dropout to LSTMs is Pachitariu &amp; Sahani (2013).<br>独立于我们的工作，Pham等人（2013）开发了完全相同的RNN正则化方法并将其应用于手写识别。我们重新发现了这种方法，并在广泛的问题上展示了强大的实证结果。其他将Dropout应用于LSTM的工作包括Pachitariu &amp; Sahani（2013）。</p><p>There have been a number of architectural variants of the RNN that perform better on problems with long term dependencies Hochreiter &amp; Schmidhuber (1997); Graves et al. (2009); Cho et al. (2014); Jaeger et al. (2007); Koutník et al. (2014); Sundermeyer et al. (2012). In this work, we show how to correctly apply dropout to LSTMs, the most commonly-used RNN variant; this way of applying dropout is likely to work well with other RNN architectures as well. In this paper, we consider the following tasks: language modeling, speech recognition, and machine translation. Language modeling is the first task where RNNs have achieved substantial success Mikolov et al. (2010; 2011); Pascanu et al. (2013). RNNs have also been successfully used for speech recognition Robinson et al. (1996); Graves et al. (2013) and have recently been applied to machine translation, where they are used for language modeling, re-ranking, or phrase modeling Devlin et al. (2014); Kalchbrenner &amp; Blunsom (2013); Cho et al. (2014); Chow et al. (1987); Mikolov et al. (2013).<br>已经有许多RNN的架构变体在处理长期依赖问题上表现更好： Hochreiter &amp; Schmidhuber (1997); Graves等（2009）；Cho等（2014）；Jaeger等（2007）；Koutník等（2014）；Sundermeyer等（2012）。在这项工作中，我们展示了如何正确地将dropout应用于LSTM，这是最常用的RNN变体；这种应用dropout的方法也可能适用于其他RNN架构。在本文中，我们考虑了以下任务：语言建模、语音识别和机器翻译。语言建模是RNN首次取得显著成功的任务 Mikolov等（2010；2011）；Pascanu等（2013）。RNN也已成功应用于语音识别 Robinson等（1996）；Graves等（2013），并且最近被应用于机器翻译，在那里它们被用于语言建模、重排序或短语建模 Devlin等（2014）；Kalchbrenner &amp; Blunsom（2013）；Cho等（2014）；Chow等（1987）；Mikolov等（2013）。</p><h1 id="3-regularizing-rnns-with-lstm-cells-使用lstm单元对rnn进行正则化"><a href="#3-REGULARIZING-RNNS-WITH-LSTM-CELLS-使用LSTM单元对RNN进行正则化" class="headerlink" title="3 REGULARIZING RNNS WITH LSTM CELLS 使用LSTM单元对RNN进行正则化"></a>3 REGULARIZING RNNS WITH LSTM CELLS 使用LSTM单元对RNN进行正则化</h1><p>In this section we describe the deep LSTM (Section 3.1). Next, we show how to regularize them (Section 3.2), and explain why our regularization scheme works.<br>在本节中，我们描述了深度LSTM（3.1节）。接下来，我们展示如何对它们进行正则化（3.2节），并解释我们的正则化方案为何有效。</p><p>We let subscripts denote timesteps and superscripts denote layers. All our states are n-dimensional. Let $h_t^l \in \mathbb{R}^n$ be a hidden state in layer$l$ in timestep $t$. Moreover, let $T_{n,m} : \mathbb{R}^n \to \mathbb{R}^m$be an affine transform ($Wx + b$ for some $W$ and $b$). Let $\odot$ be element-wise multiplication and let $h_t^0​$ be an input word vector at timestep $k$. We use the activations $h_t^L$​ to predict $y_t$​, since $L$ is the number of layers in our deep LSTM.<br>我们用下标表示时间步长，用上标表示层次。我们所有的状态都是n维的。令$h_t^l \in \mathbb{R}^n$ 为时间步$t$中层$l$的隐藏状态。此外，令$T_{n,m} : \mathbb{R}^n \to \mathbb{R}^m$为仿射变换（某些$W$和$b$,$Wx + b$）。令$\odot$为逐元素乘法，并令$h_t^0$​为时间步$k$的输入词向量。我们使用激活值$h_t^L$​来预测$y_t​$，因为$L$是我们深度LSTM的层数。</p><h2 id="31-long-short-term-memory-units-长短期记忆单元"><a href="#3-1-LONG-SHORT-TERM-MEMORY-UNITS-长短期记忆单元" class="headerlink" title="3.1 LONG-SHORT TERM MEMORY UNITS 长短期记忆单元"></a><strong>3.1 LONG-SHORT TERM MEMORY UNITS</strong> 长短期记忆单元</h2><p>The RNN dynamics can be described using deterministic transitions from previous to current hidden states. The deterministic state transition is a function<br>RNN的动态可以用从先前隐藏状态到当前隐藏状态的确定性转换来描述。确定性状态转换是一个函数</p><p>RNN : $h_t^{l-1}​$, $h_{t-1}^l \rightarrow h_t^l$</p><p>For classical RNNs, this function is given by<br>$h_t^l = f(T_{n,n} h_t^{l-1} + T_{n,n} h_{t-1}^l), where f \in \{\text{sigm, tanh}\}$</p><p>The LSTM has complicated dynamics that allow it to easily “memorize” information for an extended number of timesteps. The “long term” memory is stored in a vector of memory cells $c_t^l \in \mathbb{R}^n$. Although many LSTM architectures that differ in their connectivity structure and activation functions, all LSTM architectures have explicit memory cells for storing information for long periods of time. The LSTM can decide to overwrite the memory cell, retrieve it, or keep it for the next time step. The LSTM architecture used in our experiments is given by the following equations Graves et al. (2013):<br>LSTM具有复杂的动态，允许它轻松地“记住”多个时间步长的信息。“长期”记忆存储在记忆单元向量$c_t^l \in \mathbb{R}^n$中。尽管许多LSTM架构在连接结构和激活函数上有所不同，但所有LSTM架构都有明确的记忆单元用于长时间存储信息。LSTM可以决定覆盖记忆单元、检索或者在下一个时间步中保留它。我们实验中使用的LSTM架构由以下方程给出 Graves等（2013）：</p><p>LSTM : $h_t^{l-1}$, $h_{t-1}^l$, $c_{t-1}^l \rightarrow h_t^l$​, $c_t^l$</p><p>$\left( \begin{array}{c} i \ f \ o \ g \end{array} \right) = \left( \begin{array}{c} \text{sigm} \ \text{sigm} \ \text{sigm} \ \text{tanh} \end{array} \right) T_{2n,4n} \left( \begin{array}{c} h_{t}^{l-1} \ h_{t-1}^{l} \end{array} \right)​$</p><p>$c_t^l = f \odot c_{t-1}^l + i \odot g$</p><p>$h_t^l = o \odot \text{tanh}(c_t^l)$<br>In these equations, sigm and tanh are applied element-wise. Figure 1 illustrates the LSTM equations.<br>在这些方程中，sigm和tanh逐元素应用。图1展示了LSTM方程</p><h2 id="32-regularization-with-dropout"><a href="#3-2-REGULARIZATION-WITH-DROPOUT" class="headerlink" title="3.2 REGULARIZATION WITH DROPOUT"></a>3.2 REGULARIZATION WITH DROPOUT</h2><p>The main contribution of this paper is a recipe for applying dropout to LSTMs in a way that success-fully reduces overfitting. The main idea is to apply the dropout operator only to the non-recurrent<br>本文的主要贡献是提供了一种将dropout应用于LSTM的方法，从而成功地减少了过拟合。主要思想是仅将dropout操作符应用于非递归连接。<br><img src="/7057a5e3/1.png" class><br>Figure 1: A graphical representation of LSTM memory cells used in this paper (there are minor differences in comparison to Graves (2013)).<br>图1：本文中使用的LSTM记忆单元的图形表示（与Graves（2013）相比有细微差别）。<br><img src="/7057a5e3/2.png" class></p><p>Figure 2: Regularized multilayer RNN. The dashed arrows indicate connections where dropout is applied, and the solid lines indicate connections where dropout is not applied.<br>图2：正则化的多层RNN。虚线箭头表示应用了dropout的连接，实线表示未应用dropout的连接。<br>⚠️： x 表示输入层， y 表示输出层</p><p>connections (Figure 2). The following equation describes it more precisely, where D is the dropoutoperator that sets a random subset of its argument to zero:<br>连接（图2）。以下方程更准确地描述了这一点，其中 $D$ 是将其参数的随机子集设置为零的dropout操作符：</p><p>$\left( \begin{array}{c} i \ f \ o \ g \end{array} \right) = \left( \begin{array}{c} \text{sigm} \ \text{sigm} \ \text{sigm} \ \text{tanh} \end{array} \right) T_{2n,4n} \left( \begin{array}{c} {D}(h_{t}^{l-1}) \ h_{t-1}^{l} \end{array} \right)​$</p><p>$c_t^l = f \odot c_{t-1}^l + i \odot g$</p><p>$h_t^l = o \odot \text{tanh}(c_t^l)$</p><p>Our method works as follows. The dropout operator corrupts the information carried by the units,forcing them to perform their intermediate computations more robustly. At the same time, we do not want to erase all the information from the units. It is especially important that the units remember<br>events that occurred many timesteps in the past. Figure 3 shows how information could flow from an event that occurred at timestep t − 2 to the prediction in timestep t + 2 in our implementation of dropout. We can see that the information is corrupted by the dropout operator exactly L + 1 times,<br>我们的方法如下。dropout 运算符会破坏单元携带的信息，迫使它们更稳健地执行中间计算。同时，我们不想抹去单元的所有信息。特别重要的是，单元需要记住许多时间步长之前发生的事件。图3显示了在我们实现的dropout中，信息如何从时间步 $t-2$ 传递到时间步 $t+2$ 的预测。我们可以看到，信息恰好被dropout操作符破坏了 $L+1$ 次。</p><img src="/7057a5e3/3.png" class><p>Figure 3: The thick line shows a typical path of information flow in the LSTM. The information is affected by dropout L + 1 times, where L is depth of network.<br>图 3：粗线显示了 LSTM 中信息流的典型路径。信息受 L + 1 次的dropout影响，其中 L 是网络深度。</p><img src="/7057a5e3/4.png" class><p>Figure 4: Some interesting samples drawn from a large regularized model conditioned on “The meaning of life is”. We have removed “unk”, “N”, “$” from the set of permissible words.<br>图4：从一个以“The meaning of life is”为条件的大型正则化模型中抽取的一些有趣样本。我们已经从允许的单词集中移除了“unk”、“N”、“$”。</p><p>and this number is independent of the number of timesteps traversed by the information. Standard dropout perturbs the recurrent connections, which makes it difficult for the LSTM to learn to store information for long periods of time. By not using dropout on the recurrent connections, the LSTM can benefit from dropout regularization without sacrificing its valuable memorization ability.<br>这个数字与信息经过的时间步数无关。标准的dropout会扰乱递归连接，这使得LSTM难以学习长时间存储信息。通过不在递归连接上使用dropout，LSTM可以从dropout正则化中受益，而不牺牲其宝贵的记忆能力。</p><h1 id="4-experiments-实验"><a href="#4-EXPERIMENTS-实验" class="headerlink" title="4 EXPERIMENTS   实验"></a>4 EXPERIMENTS   实验</h1><p>We present results in three domains: language modeling (Section 4.1), speech recognition (Section 4.2), machine translation (Section 4.3), and image caption generation (Section 4.4).<br>我们在三个领域中展示了结果：语言建模（第4.1节）、语音识别（第4.2节）、机器翻译（第4.3节）和图像描述生成（第4.4节）。</p><h2 id="41-language-modeling-语言建模"><a href="#4-1-LANGUAGE-MODELING-语言建模" class="headerlink" title="4.1 LANGUAGE MODELING   语言建模"></a>4.1 LANGUAGE MODELING   语言建模</h2><p>We conducted word-level prediction experiments on the Penn Tree Bank (PTB) dataset Marcus et al. (1993), which consists of 929k training words, 73k validation words, and 82k test words. It has 10k words in its vocabulary. We downloaded it from Tomas Mikolov’s webpage†. We trained regularized LSTMs of two sizes; these are denoted the medium LSTM and large LSTM. Both LSTMs have two layers and are unrolled for 35 steps. We initialize the hidden states to zero. We then use the final hidden states of the current minibatch as the initial hidden state of the subsequent minibatch (successive minibatches sequentially traverse the training set). The size of each minibatch is 20.<br>我们在Penn Tree Bank (PTB)数据集上进行了词级预测实验，该数据集包括92.9万个训练词、7.3万个验证词和8.2万个测试词。其词汇表有1万个单词。我们从Tomas Mikolov的网页下载了该数据集。我们训练了两种规模的正则化LSTM；它们分别被称为中型LSTM和大型LSTM。两个LSTM都有两层，展开35步。我们将隐藏状态初始化为零。然后我们使用当前小批量的最终隐藏状态作为后续小批量的初始隐藏状态（连续的小批量依次遍历训练集）。每个小批量的大小为20。<br><img src="/7057a5e3/5.png" class></p><p>The medium LSTM has 650 units per layer and its parameters are initialized uniformly in [−0.05, 0.05]. As described earlier, we apply 50% dropout on the non-recurrent connections. We train the LSTM for 39 epochs with a learning rate of 1, and after 6 epochs we decrease it by a factor of 1.2 after each epoch. We clip the norm of the gradients (normalized by minibatch size) at 5. Training this network takes about half a day on an NVIDIA K20 GPU.<br>中型LSTM每层有650个单元，其参数在[−0.05, 0.05]范围内均匀初始化。如前所述，我们在非递归连接上应用50%的dropout。我们用学习率为1训练LSTM共39个周期，在第6个周期后，每个周期将学习率按1.2的因子递减。我们将梯度的范数（按小批量大小归一化）剪裁到5。训练该网络在NVIDIA K20 GPU上大约需要半天时间。</p><p>The large LSTM has 1500 units per layer and its parameters are initialized uniformly in [−0.04, 0.04]. We apply 65% dropout on the non-recurrent connections. We train the model for 55 epochs with a learning rate of 1; after 14 epochs we start to reduce the learning rate by a factor of 1.15 after each epoch. We clip the norm of the gradients (normalized by minibatch size) at 10 Mikolov et al. (2010). Training this network takes an entire day on an NVIDIA K20 GPU.<br>大型LSTM每层有1500个单元，其参数在[−0.04, 0.04]范围内均匀初始化。我们在非递归连接上应用65%的dropout。我们用学习率为1训练模型共55个周期；在第14个周期后，每个周期开始按1.15的因子递减学习率。我们将梯度的范数（按小批量大小归一化）剪裁到10 Mikolov等（2010）。训练该网络在NVIDIA K20 GPU上需要整整一天时间。</p><p>For comparison, we trained a non-regularized network. We optimized its parameters to get the best validation performance. The lack of regularization effectively constrains size of the network, forcing us to use small network because larger networks overfit. Our best performing non-regularized LSTM has two hidden layers with 200 units per layer, and its weights are initialized uniformly in [−0.1, 0.1]. We train it for 4 epochs with a learning rate of 1 and then we decrease the learning rate by a factor of 2 after each epoch, for a total of 13 training epochs. The size of each minibatch is 20, and we unroll the network for 20 steps. Training this network takes 2-3 hours on an NVIDIA K20 GPU.<br>为了比较，我们训练了一个未正则化的网络。我们优化其参数以获得最佳验证性能。缺乏正则化有效地限制了网络的大小，迫使我们使用小型网络，因为较大的网络会过拟合。我们表现最好的未正则化LSTM有两层隐藏层，每层200个单元，其权重在[−0.1, 0.1]范围内均匀初始化。我们用学习率为1训练了4个周期，然后每个周期将学习率按2的因子递减，总共训练13个周期。每个小批量的大小为20，我们展开网络20步。训练该网络在NVIDIA K20 GPU上需要2-3小时。</p><p>Table 1 compares previous results with our LSTMs, and Figure 4 shows samples drawn from a single large regularized LSTM.<br>表1比较了以前的结果和我们的LSTM，图4显示了从单个大型正则化LSTM中抽取的样本。</p><h2 id="42-speech-recognition-语音识别"><a href="#4-2-SPEECH-RECOGNITION-语音识别" class="headerlink" title="4.2 SPEECH RECOGNITION   语音识别"></a>4.2 SPEECH RECOGNITION   语音识别</h2><p>Deep Neural Networks have been used for acoustic modeling for over half a century (see Bourlard &amp; Morgan (1993) for a good review). Acoustic modeling is a key component in mapping acoustic signals to sequences of words, as it models $p(s_t|X)$ where $s_t$​ is the phonetic state at time $t$ and $X$ is the acoustic observation. Recent work has shown that LSTMs can achieve excellent performance on acoustic modeling Sak et al. (2014), yet relatively small LSTMs (in terms of the number of their parameters) can easily overfit the training set. A useful metric for measuring the performance of acoustic models is frame accuracy, which is measured at each sts_tst​ for all timesteps ttt. Generally, this metric correlates with the actual metric of interest, the Word Error Rate (WER).<br>深度神经网络已经被用于声学建模超过半个世纪（参见Bourlard &amp; Morgan (1993)的良好综述）。声学建模是将声学信号映射到单词序列中的关键组成部分，因为它对p(st∣X)p(s_t|X)p(st​∣X)建模，其中sts_tst​是时间ttt的语音状态，XXX是声学观测。最近的工作表明，LSTM在声学建模上可以取得优异的性能 Sak等（2014），但相对较小的LSTM（就参数数量而言）很容易对训练集过拟合。衡量声学模型性能的一个有用指标是帧准确率，它在所有时间步长ttt处测量每个sts_tst​的准确率。通常，这个指标与实际感兴趣的指标，即单词错误率（WER）相关。</p><img src="/7057a5e3/6.png" class><p>Since computing the WER involves using a language model and tuning the decoding parameters for every change in the acoustic model, we decided to focus on frame accuracy in these experiments. Table 2 shows that dropout improves the frame accuracy of the LSTM. Not surprisingly, the training frame accuracy drops due to the noise added during training, but as is often the case with dropout, this yields models that generalize better to unseen data. Note that the test set is easier than the training set, as its accuracy is higher. We report the performance of an LSTM on an internal Google Icelandic Speech dataset, which is relatively small (93k utterances), so overfitting is a great concern.<br>由于计算WER涉及使用语言模型并调整声学模型每次变化的解码参数，我们决定在这些实验中专注于帧准确率。表2显示了dropout提高了LSTM的帧准确率。不出所料，由于训练过程中加入的噪声，训练帧准确率下降了，但与dropout经常出现的情况一样，这使得模型在未见数据上的泛化能力更强。请注意，测试集比训练集更容易，因为它的准确率更高。我们报告了LSTM在Google内部冰岛语语音数据集上的性能，该数据集相对较小（93k句子），因此过拟合是一个很大的问题。</p><h2 id="43-machine-translation-机器翻译"><a href="#4-3-MACHINE-TRANSLATION-机器翻译" class="headerlink" title="4.3 MACHINE TRANSLATION  机器翻译"></a>4.3 MACHINE TRANSLATION  机器翻译</h2><p>We formulate a machine translation problem as a language modelling task, where an LSTM is trained to assign high probability to a correct translation of a source sentence. Thus, the LSTM is trained on concatenations of source sentences and their translations Sutskever et al. (2014) (see also Cho et al. (2014)). We compute a translation by approximating the most probable sequence of words using a simple beam search with a beam of size 12. We ran an LSTM on the WMT’14 English to French dataset, on the “selected” subset from Schwenk (2014) which has 340M French words and 304M English words. Our LSTM has 4 hidden layers, and both its layers and word embeddings have 1000 units. Its English vocabulary has 160,000 words and its French vocabulary has 80,000 words. The optimal dropout probability was 0.2. Table 3 shows the performance of an LSTM trained with and without dropout. While our LSTM does not beat the phrase-based LIUM SMT system Schwenk et al. (2011), our results show that dropout improves the translation performance of the LSTM.<br>我们将机器翻译问题表述为一个语言建模任务，其中LSTM被训练为对源句子的正确翻译赋予高概率。因此，LSTM在源句子及其翻译的串联上进行训练 Sutskever等（2014）（另见Cho等（2014））。我们通过使用大小为12的简单束搜索来近似最可能的单词序列来计算翻译。我们在WMT’14英法数据集上的“selected”子集（来自Schwenk（2014），包含3.4亿个法语单词和3.04亿个英语单词）上运行了一个LSTM。我们的LSTM有4个隐藏层，其层和词嵌入都有1000个单元。它的英语词汇量有160,000个单词，法语词汇量有80,000个单词。最佳的dropout概率是0.2。表3显示了使用和不使用dropout训练的LSTM的性能。虽然我们的LSTM没有击败基于短语的LIUM SMT系统 Schwenk等（2011），但我们的结果表明dropout提高了LSTM的翻译性能。</p><h2 id="44-image-caption-generation图像描述生成"><a href="#4-4-IMAGE-CAPTION-GENERATION图像描述生成" class="headerlink" title="4.4 IMAGE CAPTION GENERATION图像描述生成"></a>4.4 IMAGE CAPTION GENERATION图像描述生成</h2><p>We applied the dropout variant to the image caption generation model of Vinyals et al. (2014). The image caption generation is similar to the sequence-to-sequence model of Sutskever et al. (2014), but where the input image is mapped onto a vector with a highly-accurate pre-trained convolutional neural network (Szegedy et al., 2014), which is converted into a caption with a single-layer LSTM (see Vinyals et al. (2014) for the details on the architecture). We test our dropout scheme on LSTM as the convolutional neural network is not trained on the image caption dataset because it is not large (MSCOCO (Lin et al., 2014)).<br>我们将dropout变体应用于Vinyals等人（2014）的图像描述生成模型。图像描述生成类似于Sutskever等人（2014）的序列到序列模型，但输入图像被映射到一个具有高精度的预训练卷积神经网络（Szegedy等人，2014）的向量，该向量通过单层LSTM转换为描述（有关架构的详细信息，请参见Vinyals等人，2014）。我们在LSTM上测试了我们的dropout方案，因为卷积神经网络并未在图像描述数据集上进行训练，因为它不是很大（MSCOCO（Lin等人，2014））。</p><p>Our results are summarized in the following Table 4. In brief, dropout helps relative to not using dropout, but using an ensemble eliminates the gains attained by dropout. Thus, in this setting, the main effect of dropout is to produce a single model that is as good as an ensemble, which is a reasonable improvement given the simplicity of the technique.<br>我们的结果总结在以下表4中。简而言之，dropout相对于不使用dropout有帮助，但使用集成方法消除了通过dropout获得的收益。因此，在这种情况下，dropout的主要作用是产生一个与集成一样好的单一模型，考虑到该技术的简单性，这是一个合理的改进。</p><h1 id="5-conclusion"><a href="#5-CONCLUSION" class="headerlink" title="5 CONCLUSION"></a>5 CONCLUSION</h1><p>We presented a simple way of applying dropout to LSTMs that results in large performance increases on several problems in different domains. Our work makes dropout useful for RNNs, and our results suggest that our implementation of dropout could improve performance on a wide variety of applications.<br>我们提出了一种将dropout应用于LSTM的简单方法，这在不同领域的几个问题上导致了性能的大幅提升。我们的工作使dropout对RNN有用，并且我们的结果表明，我们实现的dropout可以提高各种应用的性能。<br><img src="/7057a5e3/7.png" class></p><h1 id="6-acknowledgments"><a href="#6-ACKNOWLEDGMENTS" class="headerlink" title="6 ACKNOWLEDGMENTS"></a>6 ACKNOWLEDGMENTS</h1><p>We wish to acknowledge Tomas Mikolov for useful comments on the first version of the paper.<br>我们希望感谢Tomas Mikolov对论文第一版提出的有益意见。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="1-元素乘法"><a href="#1-元素乘法" class="headerlink" title="1. 元素乘法"></a>1. 元素乘法</h2><p><strong>元素乘法</strong>（Element-wise multiplication），也称为Hadamard乘积（Hadamard product），是对两个同形矩阵或向量的对应元素进行逐一相乘的操作，广泛应用于各种线性代数和神经网络计算中。 用符号“⊙”表示。</p><h3 id="公式表示"><a href="#公式表示" class="headerlink" title="公式表示"></a>公式表示</h3><p>给定两个相同大小的矩阵或向量 $A$ 和 $B$，其元素乘法 $C$ 计算如下：<br>$C = A \odot B$</p><p>其中：</p><ul><li>$A = [a_1, a_2, …, a_n]$</li><li>$B = [b_1, b_2, …, b_n]$</li><li>$C = [c_1, c_2, …, c_n]$</li><li>$c_i = a_i \cdot b_i$<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3></li></ul><p>假设有两个向量 $A$ 和 $B$：</p><p>$A=[1,2,3]$<br>$B=[4,5,6]$</p><p>它们的元素乘法 $C$ 为：<br>$C = A \odot B = [1 \cdot 4, 2 \cdot 5, 3 \cdot 6] = [4, 10, 18]$</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><strong>神经网络中的LSTM</strong>：<ul><li>用于更新单元状态，如公式 $c_t = f \odot c_{t-1} + i \odot \tilde{c}_t$中。</li></ul></li><li><strong>图像处理</strong>：<ul><li>用于图像滤波，将滤波器应用于图像的每个像素。</li></ul></li><li><strong>数据处理</strong>：<ul><li>在数据预处理中，用于按元素缩放或调整数据。</li></ul></li></ol><h2 id="2-公式拆解rnn"><a href="#2-公式拆解-RNN" class="headerlink" title="2. 公式拆解:RNN"></a>2. 公式拆解:RNN</h2><p>RNN : $h_t^{l-1}​$, $h_{t-1}^l \rightarrow h_t^l$</p><p>表明在RNN中， 隐藏状态的计算结果依赖于当前时间步的输入 $h_t$和前一时间步的隐藏状态 $h_{t-1}$。 再细化一点，</p><ol><li>当前时间步的输入 $h_t$ 应该来源于上一层，所以是 $h_t^{l-1}​$</li><li>前一时间步的隐藏状态 $h_{t-1}$ ，应该是同一层的前一个时间步， 所以是$h_{t-1}^l$</li></ol><p>该状态转移过程，如果用具体的数学公式表示，可以如下所示<br>$h_t^l = f(T_{n,n} h_t^{l-1} + T_{n,n} h_{t-1}^l), where f \in \{\text{sigm, tanh}\}$</p><h2 id="3-公式拆解lstm-状态更新"><a href="#3-公式拆解-LSTM-状态更新" class="headerlink" title="3. 公式拆解:LSTM  状态更新"></a>3. 公式拆解:LSTM  状态更新</h2><p>LSTM : $h_t^{l-1}$, $h_{t-1}^l$, $c_{t-1}^l \rightarrow h_t^l$​, $c_t^l$<br>描述了LSTM如何通过当前层的输入向量 $h_t^{l-1}$、前一时间步的隐藏状态 $h_{t-1}^l$和单元状态 $c_{t-1}^l$ 来生成新的隐藏状态 $h_t^l$ 和单元状态 $c_t^l$。</p><ol><li>$h_t^{l-1}$：表示第 $l−1$ 层在时间步 $t$ 的隐藏状态向量。这是第 $l$ 层的当前输入。</li><li>$h_{t-1}^l$：表示第 $l$ 层在时间步 $t−1$ 的隐藏状态向量。这是第 $l$ 层的前一个时间步的状态。</li><li>$c_{t-1}^l$：表示第 $l$ 层在时间步 $t−1$的单元状态向量。这是第 $l$ 层的前一个时间步的单元状态。</li><li>$h_t^l$：表示第 $l$ 层在时间步 $t$ 的隐藏状态向量。这是经过第 $l$ 层计算后的新状态。</li><li>$c_t^l$：表示第 $l$ 层在时间步 $t$ 的新的单元状态向量。这是更新后的单元状态。</li></ol><p>$\left( \begin{array}{c} i \ f \ o \ g \end{array} \right) = \left( \begin{array}{c} \text{sigm} \ \text{sigm} \ \text{sigm} \ \text{tanh} \end{array} \right) T_{2n,4n} \left( \begin{array}{c} h_{t}^{l-1} \ h_{t-1}^{l} \end{array} \right)​$</p><p>描述了输入门 $i$、遗忘门 $f$、输出门 $o$ 和候选记忆单元 $g$ 的计算。这里，矩阵 $T_{2n,4n}$​ 包含了相应的权重，输入包括当前输入 $h_t^{l-1}$和前一时间步的隐藏状态 $h_{t-1}^l$​</p><ul><li><strong>输入门 $i$</strong> 和 <strong>遗忘门 $f$</strong> 控制信息的更新和遗忘，使用$sigmoid$激活函数。</li><li><strong>输出门 $o$</strong> 控制输出信息，使用$sigmoid$激活函数。</li><li><strong>候选记忆单元 $g$</strong> 提供新的信息内容，使用$tanh$激活函数。</li><li><strong>权重矩阵 $T_{2n,4n}$</strong>  一个大小为 $2n \times 4n$ 的矩阵，其中 $n$ 是隐藏状态向量的维度。将输入向量 $h_t^{l-1}$​ 和隐藏状态向量 $h_{t-1}^l$ 拼接起来（向量长度为 $2n$），并通过矩阵 $T_{2n,4n}$​ 进行线性变换，生成一个长度为 $4n$ 的输出向量,即 $i, f, o, g$ 四个部分<h3 id="1-遗忘门forget-gate"><a href="#1-遗忘门（Forget-Gate）" class="headerlink" title="1. 遗忘门（Forget Gate）"></a>1. 遗忘门（Forget Gate）</h3></li></ul><p>$f_t^l = \sigma(W_f \cdot [h_{t-1}^l, h_t^{l-1}] + b_f)$</p><ul><li>$[h_t^{l-1}, h_{t-1}^l]$表示将当前输入和前一时间步的隐藏状态向量拼接成一个向量。</li><li>$W_f​$ 是该拼接向量的权重矩阵。</li><li>$b_f$​ 是偏置向量。</li><li>$\sigma$ 是$sigmoid$激活函数，输出范围在0到1之间。</li></ul><p>假设 $n = 4$：</p><ul><li>当前输入向量 $h_t^{l-1}$为 $[h_1​,h_2​,h_3​,h_4​]$。</li><li>前一时间步的隐藏状态 $h_{t-1}^l$ 为 $[h_5, h_6, h_7, h_8]$</li></ul><p>拼接后的向量为：$[h_1, h_2, h_3, h_4, h_5, h_6, h_7, h_8]$</p><p>权重矩阵 $W_f​$ 将此向量进行线性变换，生成一个长度为 $n$ 的向量。</p><h4 id="线性变换"><a href="#线性变换" class="headerlink" title="线性变换"></a>线性变换</h4><p>进行线性变换的公式为：<br>$z_f = W_f \cdot [h_t^{l-1}, h_{t-1}^l] + b_f$</p><p>具体步骤：</p><ol><li><strong>矩阵乘法</strong>：<ul><li>$W_f$是一个 $n \times 2n$ 的矩阵，拼接向量是一个长度为 $2n$ 的向量。</li><li>通过矩阵乘法，结果是一个长度为 $n$ 的向量。</li></ul></li><li><strong>加偏置</strong>：<ul><li>将得到的向量与偏置向量 $b_f$ 相加，仍然是一个长度为 $n$ 的向量。</li></ul></li></ol><p>例如，假设 $W_f$​ 和 $b_f$​ 为：<br>$W_f = \begin{pmatrix} w_{11} &amp; w_{12} &amp; w_{13} &amp; w_{14} &amp; w_{15} &amp; w_{16} &amp; w_{17} &amp; w_{18} \ w_{21} &amp; w_{22} &amp; w_{23} &amp; w_{24} &amp; w_{25} &amp; w_{26} &amp; w_{27} &amp; w_{28} \ w_{31} &amp; w_{32} &amp; w_{33} &amp; w_{34} &amp; w_{35} &amp; w_{36} &amp; w_{37} &amp; w_{38} \ w_{41} &amp; w_{42} &amp; w_{43} &amp; w_{44} &amp; w_{45} &amp; w_{46} &amp; w_{47} &amp; w_{48} \end{pmatrix}$</p><p>拼接向量为：<br>$[h_1, h_2, h_3, h_4, h_5, h_6, h_7, h_8]$</p><p>矩阵乘法：<br>$z_f = W_f \cdot [h_1, h_2, h_3, h_4, h_5, h_6, h_7, h_8]$</p><p>计算每个元素：<br>$\begin{aligned} z_{f1} &amp;= w_{11}h_1 + w_{12}h_2 + w_{13}h_3 + w_{14}h_4 + w_{15}h_5 + w_{16}h_6 + w_{17}h_7 + w_{18}h_8 \ z_{f2} &amp;= w_{21}h_1 + w_{22}h_2 + w_{23}h_3 + w_{24}h_4 + w_{25}h_5 + w_{26}h_6 + w_{27}h_7 + w_{28}h_8 \ z_{f3} &amp;= w_{31}h_1 + w_{32}h_2 + w_{33}h_3 + w_{34}h_4 + w_{35}h_5 + w_{36}h_6 + w_{37}h_7 + w_{38}h_8 \ z_{f4} &amp;= w_{41}h_1 + w_{42}h_2 + w_{43}h_3 + w_{44}h_4 + w_{45}h_5 + w_{46}h_6 + w_{47}h_7 + w_{48}h_8 \end{aligned}$</p><p>加偏置：<br>$z_f = \begin{pmatrix} z_{f1} + b_1 \ z_{f2} + b_2 \ z_{f3} + b_3 \ z_{f4} + b_4 \end{pmatrix}$</p><h4 id="sigmoid-非线性激活"><a href="#sigmoid-非线性激活" class="headerlink" title="sigmoid 非线性激活"></a>sigmoid 非线性激活</h4><p>通过$sigmoid$激活函数得到遗忘门的激活值：<br>$f_t^l = \sigma(z_f)$<br>通过 $sigmoid$ 非线性激活函数，得到遗忘门的激活值。</p><h3 id="2-输入门input-gate"><a href="#2-输入门（Input-Gate）" class="headerlink" title="2. 输入门（Input Gate）"></a>2. 输入门（Input Gate）</h3><p>计算输入门的激活值，决定新的输入信息的哪些部分将更新单元状态： $i_t^l = \sigma(W_i \cdot [h_{t-1}^l, h_t^{l-1}] + b_i)$</p><p>输入调制门（Input Modulation Gate）输入调制门产生新的候选记忆内容，通过 tanh 函数进行激活。<br>它的数学表示为：$g_t = \tanh(W_g \cdot [h_{t-1}, h_t] + b_g)$</p><h3 id="3-单元状态"><a href="#3-单元状态" class="headerlink" title="3. 单元状态"></a>3. 单元状态</h3><p>结合遗忘门和输入门的信息，更新单元状态：</p><p>$c_t^l = f \odot c_{t-1}^l + i \odot g$</p><p>描述了如何更新单元状态。这里，$\odot$ 表示元素乘法（Hadamard乘积）。</p><ul><li>遗忘门$f$决定了前一时间步的单元状态 $c_{t-1}^l$有多少被保留。遗忘门的输出值在0和1之间：<ul><li>当 $f$​ 接近1时，表示大部分单元状态被保留。</li><li>当 $f$接近0时，表示大部分单元状态被遗忘。</li></ul></li><li>输入门 $i$ 和候选记忆单元 $g$ 决定了多少新的信息被添加到当前单元状态 $c_t^l$。</li></ul><h3 id="4-输出门"><a href="#4-输出门" class="headerlink" title="4. 输出门"></a>4. 输出门</h3><p>计算输出门的激活值，决定隐藏状态的更新：<br>输出门：$o_t^l = \sigma(W_o \cdot [h_{t-1}^l, h_t^{l-1}] + b_o)$<br>隐藏状态：$h_t^l = o_t^l * \tanh(c_t^l)$<br>输出门 $o$ 控制了从单元状态 $c_t^l$ 传递到隐藏状态 $h_t^l$​ 的信息，通过$tanh$函数进行非线性变换。</p><p>LSTM通过输入门、遗忘门、输出门和候选记忆单元的协同作用，有效地捕捉序列数据中的长短期依赖关系，解决了传统RNN中梯度消失和梯度爆炸的问题。这个更新机制使得LSTM在处理长序列数据时表现出色，能够有效地保留重要信息并过滤无关信息。</p><h3 id="5-更新隐藏状态hidden-state-update"><a href="#5-更新隐藏状态（Hidden-State-Update）" class="headerlink" title="5. 更新隐藏状态（Hidden State Update）"></a>5. 更新隐藏状态（Hidden State Update）</h3><p>结合新的单元状态和输出门的激活值，更新隐藏状态： $h_t^l = o_t^l * \tanh(c_t^l)$</p><h2 id="4-应用了dropout-的lstm"><a href="#4-应用了dropout-的LSTM" class="headerlink" title="4. 应用了dropout 的LSTM"></a>4. 应用了dropout 的LSTM</h2><p>从正文中可以看出，和标准的LSTM 状态更新过程相比， 其变化只是增加了一个$D$。<br>$D$ 是将其参数的随机子集设置为零的dropout操作符。</p><p>$\left( \begin{array}{c} i \ f \ o \ g \end{array} \right) = \left( \begin{array}{c} \text{sigm} \ \text{sigm} \ \text{sigm} \ \text{tanh} \end{array} \right) T_{2n,4n} \left( \begin{array}{c} {D}(h_{t}^{l-1}) \ h_{t-1}^{l} \end{array} \right)​$</p><p>如何理解其主要思想是仅将dropout操作符应用于非递归连接。<br>由于：</p><ol><li>$h_t^{l-1}$：表示第 $l−1$ 层在时间步 $t$ 的隐藏状态向量。这是第 $l$ 层的当前输入。</li><li>$h_{t-1}^l$：表示第 $l$ 层在时间步 $t−1$ 的隐藏状态向量。这是第 $l$ 层的前一个时间步的状态。<br>同一层前后时间步之间的数据流转 就是递归操作， 不同层之间的数据流转是非递归操作， 根据公式，$D$ 应用在了$h_t^{l-1}$上， 所以说$D$ 是应用在非递归连接上的操作符合</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/1409.2329&quot;&gt;RECURRENT NEURAL NETWORK REGULARIZATION&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;abstract-摘要&quot;&gt;&lt;a href=&quot;#ABSTRACT-摘要&quot; cla</summary>
      
    
    
    
    
    <category term="AI" scheme="http://example.com/tags/AI/"/>
    
    <category term="神经网络" scheme="http://example.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Ilya sutskever‘s 30  papers" scheme="http://example.com/tags/Ilya-sutskever%E2%80%98s-30-papers/"/>
    
  </entry>
  
  <entry>
    <title>The Unreasonable Effectiveness of Recurrent Neural Networks</title>
    <link href="http://example.com/2472be8a/"/>
    <id>http://example.com/2472be8a/</id>
    <published>2024-06-11T09:59:43.000Z</published>
    <updated>2024-06-16T14:23:22.626Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://karpathy.github.io/2015/05/21/rnn-effectiveness/">Andrej Karpathy blog:# The Unreasonable Effectiveness of Recurrent Neural Networks</a></p><p>There’s something magical about Recurrent Neural Networks (RNNs). I still remember when I trained my first recurrent network for <a href="http://cs.stanford.edu/people/karpathy/deepimagesent/">Image Captioning</a>. Within a few dozen minutes of training my first baby model (with rather arbitrarily-chosen hyperparameters) started to generate very nice looking descriptions of images that were on the edge of making sense. Sometimes the ratio of how simple your model is to the quality of the results you get out of it blows past your expectations, and this was one of those times. What made this result so shocking at the time was that the common wisdom was that RNNs were supposed to be difficult to train (with more experience I’ve in fact reached the opposite conclusion). Fast forward about a year: I’m training RNNs all the time and I’ve witnessed their power and robustness many times, and yet their magical outputs still find ways of amusing me. This post is about sharing some of that magic with you.<br>循环神经网络（RNN）有其独特的魅力。我还记得第一次训练用于图像描述生成的循环神经网络时的情景。只用了短短几十分钟，即使是随意选择的超参数，这个初步模型已经开始生成看起来非常不错的图像描述，尽管这些描述有时只是勉强合理。有时，模型的简单程度与其输出结果的质量之间的比例会远远超出预期，这次就是一个典型的例子。这次结果如此令人震惊的原因在于，当时的普遍认知是，RNN很难训练（随着经验的增加，我实际上得出了相反的结论）。时间快进大约一年：我一直在训练RNN，目睹了它们的强大和稳健，尽管如此，它们神奇的输出依然能不断带给我惊喜。这篇文章旨在与大家分享这种魔力。</p><p>We’ll train RNNs to generate text character by character and ponder the question “how is that even possible?”<br>我们将训练循环神经网络（RNN）逐字符地生成文本，并思考这个问题：“这到底是怎么做到的？”</p><p>By the way, together with this post I am also releasing <a href="https://github.com/karpathy/char-rnn">code on Github</a> that allows you to train character-level language models based on multi-layer LSTMs. You give it a large chunk of text and it will learn to generate text like it one character at a time. You can also use it to reproduce my experiments below. But we’re getting ahead of ourselves; What are RNNs anyway?<br>顺便提一下，与这篇文章一起，我还在Github上发布了代码，这些代码可以用来训练基于多层LSTM的字符级语言模型。你只需提供一大段文本，它就会逐字符地学习生成类似的文本。你还可以使用它来重现我下面的实验。但在此之前，我们还是先回到正题上来：我们先来了解一下RNN到底是什么？</p><h1 id="recurrent-neural-networks-递归神经网络"><a href="#Recurrent-Neural-Networks-递归神经网络" class="headerlink" title="Recurrent Neural Networks  递归神经网络"></a>Recurrent Neural Networks  递归神经网络</h1><h2 id="sequences"><a href="#Sequences" class="headerlink" title="Sequences"></a>Sequences</h2><p><strong>Sequences</strong>. Depending on your background you might be wondering: _What makes Recurrent Networks so special_? A glaring limitation of Vanilla Neural Networks (and also Convolutional Networks) is that their API is too constrained: they accept a fixed-sized vector as input (e.g. an image) and produce a fixed-sized vector as output (e.g. probabilities of different classes). Not only that: These models perform this mapping using a fixed amount of computational steps (e.g. the number of layers in the model). The core reason that recurrent nets are more exciting is that they allow us to operate over _sequences_ of vectors: Sequences in the input, the output, or in the most general case both. A few examples may make this more concrete:<br>序列。根据你的背景，你可能会问：循环神经网络有什么特别之处？一个显而易见的限制是Vanilla 神经网络（以及卷积神经网络）的API过于受限：它们接受固定大小的向量作为输入（例如，一张图片），并产生固定大小的向量作为输出（例如，不同类别的概率）。不仅如此，这些模型使用固定数量的计算步骤来完成这个映射（例如，模型中的层数）。循环神经网络更令人兴奋的核心原因在于它们允许我们对向量序列进行操作：输入中的序列，输出中的序列，或者在最一般的情况下，两者都是序列。几个例子可以让这一点更加具体：</p><img src="/2472be8a/1.png" class><p>Each rectangle is a vector and arrows represent functions (e.g. matrix multiply). Input vectors are in red, output vectors are in blue and green vectors hold the RNN’s state (more on this soon). From left to right: <strong>(1)</strong> Vanilla mode of processing without RNN, from fixed-sized input to fixed-sized output (e.g. image classification). <strong>(2)</strong> Sequence output (e.g. image captioning takes an image and outputs a sentence of words). <strong>(3)</strong> Sequence input (e.g. sentiment analysis where a given sentence is classified as expressing positive or negative sentiment). <strong>(4)</strong> Sequence input and sequence output (e.g. Machine Translation: an RNN reads a sentence in English and then outputs a sentence in French). <strong>(5)</strong> Synced sequence input and output (e.g. video classification where we wish to label each frame of the video). Notice that in every case are no pre-specified constraints on the lengths sequences because the recurrent transformation (green) is fixed and can be applied as many times as we like.<br>每个矩形代表一个向量，箭头代表函数（例如矩阵乘法）。输入向量用红色表示，输出向量用蓝色表示，绿色向量表示RNN的状态（稍后会详细说明）。从左到右依次是：</p><p><strong>(1)</strong> 普通模式的处理，没有使用RNN，从固定大小的输入到固定大小的输出（例如图像分类）。</p><p><strong>(2)</strong> 序列输出（例如图像描述生成，输入一张图片，输出一个单词句子）。</p><p><strong>(3)</strong> 序列输入（例如情感分析，将给定的句子分类为表达正面或负面情感）。</p><p><strong>(4)</strong> 序列输入和序列输出（例如机器翻译：RNN读取一段英文句子，然后输出一段法文句子）。</p><p><strong>(5)</strong> 同步的序列输入和输出（例如视频分类，我们希望对视频的每一帧进行标签）。</p><p>注意，在每种情况下，序列长度都没有预先指定的限制，因为循环变换（绿色）是固定的，可以根据需要应用多次。</p><p>As you might expect, the sequence regime of operation is much more powerful compared to fixed networks that are doomed from the get-go by a fixed number of computational steps, and hence also much more appealing for those of us who aspire to build more intelligent systems. Moreover, as we’ll see in a bit, RNNs combine the input vector with their state vector with a fixed (but learned) function to produce a new state vector. This can in programming terms be interpreted as running a fixed program with certain inputs and some internal variables. Viewed this way, RNNs essentially describe programs. In fact, it is known that <a href="http://binds.cs.umass.edu/papers/1995_Siegelmann_Science.pdf">RNNs are Turing-Complete</a> in the sense that they can to simulate arbitrary programs (with proper weights). But similar to universal approximation theorems for neural nets you shouldn’t read too much into this. In fact, forget I said anything.<br>正如你所预料的那样，相较于受限于固定计算步骤的固定网络，序列操作模式要强大得多，因此对于那些希望构建更智能系统的人来说也更具吸引力。此外，正如我们稍后会看到的，RNN通过固定（但可学习）的函数将输入向量与其状态向量结合，生成一个新的状态向量。这在编程术语中可以理解为运行一个具有特定输入和一些内部变量的固定程序。从这个角度来看，RNN本质上是在描述程序。事实上，RNN被认为是图灵完备的，这意味着它们可以模拟任意程序（在适当的权重下）。但是，与神经网络的通用近似定理类似，你不应该对此过于解读。实际上，忘掉我刚才说的话吧。</p><blockquote><p>If training vanilla neural nets is optimization over functions, training recurrent nets is optimization over programs.<br>如果说训练普通神经网络是对函数的优化，那么训练循环网络就是对程序的优化。</p></blockquote><p><strong>Sequential processing in absence of sequences</strong>. You might be thinking that having sequences as inputs or outputs could be relatively rare, but an important point to realize is that even if your inputs/outputs are fixed vectors, it is still possible to use this powerful formalism to _process_ them in a sequential manner. For instance, the figure below shows results from two very nice papers from <a href="http://deepmind.com/">DeepMind</a>. On the left, an algorithm learns a recurrent network policy that steers its attention around an image; In particular, it learns to read out house numbers from left to right (<a href="http://arxiv.org/abs/1412.7755">Ba et al.</a>). On the right, a recurrent network _generates_ images of digits by learning to sequentially add color to a canvas (<a href="http://arxiv.org/abs/1502.04623">Gregor et al.</a>):<br>在没有序列的情况下进行顺序处理。您可能认为将序列作为输入或输出可能相对罕见，但需要意识到的重要一点是，即使你的输入/输出是固定向量，仍然可以使用这种强大的形式主义以顺序方式处理它们。例如，下图显示了 DeepMind 的两篇非常好的论文的结果。在左边，算法学习一个循环网络策略，将其注意力引导到图像周围;特别是，它学会了从左到右读出门牌号（Ba等人）。在右边，一个循环网络通过学习依次向画布添加颜色来生成数字图像：<br><img src="https://karpathy.github.io/assets/rnn/house_read.gif" alt> <img src="https://karpathy.github.io/assets/rnn/house_generate.gif" alt></p><p>The takeaway is that even if your data is not in form of sequences, you can still formulate and train powerful models that learn to process it sequentially. You’re learning stateful programs that process your fixed-sized data.<br>要点是，即使你的数据不是以序列形式存在，你仍然可以设计和训练强大的模型，使其学会以顺序方式处理这些数据。你正在学习的是处理固定大小数据的有状态程序。</p><h2 id="rnn-computation"><a href="#RNN-computation" class="headerlink" title="RNN computation"></a>RNN computation</h2><p><strong>RNN computation.</strong> So how do these things work? At the core, RNNs have a deceptively simple API: They accept an input vector <code>x</code> and give you an output vector <code>y</code>. However, crucially this output vector’s contents are influenced not only by the input you just fed in, but also on the entire history of inputs you’ve fed in in the past. Written as a class, the RNN’s API consists of a single <code>step</code> function:<br>RNN 计算。那么这些东西是如何工作的呢？在核心上，RNN 有一个看似简单的 API：它们接受一个输入向量 <code>x</code> 并给你一个输出向量 <code>y</code> 。然而，至关重要的是，这个输出向量的内容不仅受到你刚刚输入的输入的影响，还受到你过去输入的整个输入历史的影响。RNN 的 API 编写为一个类，由一个 <code>step</code> 函数组成：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rnn = RNN()</span><br><span class="line">y = rnn.step(x) # x is an input vector, y is the RNN&#x27;s output vector</span><br></pre></td></tr></table></figure><br>The RNN class has some internal state that it gets to update every time <code>step</code> is called. In the simplest case this state consists of a single _hidden_ vector <code>h</code>. Here is an implementation of the step function in a Vanilla RNN:<br>RNN 类具有一些内部状态，每次调用时 <code>step</code> 都会更新。在最简单的情况下，此状态由单个隐藏向量组成 <code>h</code> 。以下是 Vanilla RNN 中 step 函数的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class RNN:</span><br><span class="line">  # ...</span><br><span class="line">  def step(self, x):</span><br><span class="line">    # update the hidden state</span><br><span class="line">    self.h = np.tanh(np.dot(self.W_hh, self.h) + np.dot(self.W_xh, x))</span><br><span class="line">    # compute the output vector</span><br><span class="line">    y = np.dot(self.W_hy, self.h)</span><br><span class="line">    return y</span><br></pre></td></tr></table></figure><p>The above specifies the forward pass of a vanilla RNN. This RNN’s parameters are the three matrices <code>W_hh, W_xh, W_hy</code>. The hidden state <code>self.h</code> is initialized with the zero vector. The <code>np.tanh</code> function implements a non-linearity that squashes the activations to the range <code>[-1, 1]</code>. Notice briefly how this works: There are two terms inside of the tanh: one is based on the previous hidden state and one is based on the current input. In numpy <code>np.dot</code> is matrix multiplication. The two intermediates interact with addition, and then get squashed by the tanh into the new state vector. If you’re more comfortable with math notation, we can also write the hidden state update as $ℎ_𝑡=tanh⁡(𝑊_{ℎℎ}ℎ_{𝑡−1}+𝑊_{𝑥ℎ}𝑥_𝑡)$, where tanh is applied elementwise.<br>上述内容描述了一个基础RNN的前向传播过程。这个RNN的参数是三个矩阵W_hh、W_xh和W_hy。隐藏状态self.h初始化为零向量。np.tanh函数实现了一种非线性激活函数，将激活值压缩到[-1, 1]范围内。简要说明其工作原理：tanh内部有两个项，一个基于前一个时间步隐藏状态，另一个基于当前时间步输入。在numpy中，np.dot表示矩阵乘法。这两个中间结果通过加法相互作用，然后通过tanh函数压缩为新的状态向量。如果你对数学表示法更熟悉，我们也可以将隐藏状态的更新写成 $ℎ_𝑡=tanh⁡(𝑊_{ℎℎ}ℎ_{𝑡−1}+𝑊_{𝑥ℎ}𝑥_𝑡)$，其中tanh逐元素应用。</p><p>⚠️：numpy是Python中一个非常流行的数值计算库。np.tanh函数和np.dot函数都是numpy库中的函数。np.tanh函数用于计算元素级的双曲正切，而np.dot函数用于执行矩阵乘法。</p><p>We initialize the matrices of the RNN with random numbers and the bulk of work during training goes into finding the matrices that give rise to desirable behavior, as measured with some loss function that expresses your preference to what kinds of outputs $y$ you’d like to see in response to your input sequences $x$.<br>我们用随机数初始化RNN的矩阵，在训练过程中，大部分工作是找到能够产生理想行为的矩阵，这通过某种损失函数来衡量，该损失函数表达了你对输入序列$x$对应输出$y$的期望。</p><h2 id="going-deep"><a href="#Going-deep" class="headerlink" title="Going deep"></a>Going deep</h2><p><strong>Going deep</strong>. RNNs are neural networks and everything works monotonically better (if done right) if you put on your deep learning hat and start stacking models up like pancakes. For instance, we can form a 2-layer recurrent network as follows:<br>深入研究。RNN是神经网络的一种，如果方法得当，采用深度学习的方法并像叠煎饼一样将模型堆叠起来，一切都会单调地变得更好。例如，我们可以如下构建一个两层的循环神经网络：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y1 = rnn1.step(x)</span><br><span class="line">y = rnn2.step(y1)</span><br></pre></td></tr></table></figure></p><p>In other words we have two separate RNNs: One RNN is receiving the input vectors and the second RNN is receiving the output of the first RNN as its input. Except neither of these RNNs know or care - it’s all just vectors coming in and going out, and some gradients flowing through each module during backpropagation.<br>换句话说，我们有两个独立的 RNN：一个 RNN 接收输入向量，第二个 RNN 接收第一个 RNN 的输出作为其输入。除了这些 RNN 都不知道或不关心之外——它们都只是进出的向量，以及在反向传播过程中流过每个模块的一些梯度。</p><h2 id="getting-fancy"><a href="#Getting-fancy" class="headerlink" title="Getting fancy"></a>Getting fancy</h2><p><strong>Getting fancy</strong>. I’d like to briefly mention that in practice most of us use a slightly different formulation than what I presented above called a _Long Short-Term Memory_ (LSTM) network. The LSTM is a particular type of recurrent network that works slightly better in practice, owing to its more powerful update equation and some appealing backpropagation dynamics. I won’t go into details, but everything I’ve said about RNNs stays exactly the same, except the mathematical form for computing the update (the line <code>self.h = ...</code> ) gets a little more complicated. From here on I will use the terms “RNN/LSTM” interchangeably but all experiments in this post use an LSTM.<br>更复杂的模型。在实践中，我们大多数人使用的公式与我上面提到的稍有不同，被称为长短期记忆网络（LSTM）。LSTM是一种特定类型的循环神经网络，实际上效果更好，因为它具有更强大的更新方程和一些更具吸引力的反向传播动态。我不会深入讨论细节，但我所说的关于RNN的一切都完全相同，除了计算更新的数学形式（即self.h = …这一行）变得稍微复杂了一些。从现在开始，我会交替使用“RNN/LSTM”这两个术语，但本文中的所有实验都使用LSTM。</p><h1 id="character-level-language-models"><a href="#Character-Level-Language-Models" class="headerlink" title="Character-Level Language Models"></a>Character-Level Language Models</h1><p>字符级语言模型</p><p>Okay, so we have an idea about what RNNs are, why they are super exciting, and how they work. We’ll now ground this in a fun application: We’ll train RNN character-level language models. That is, we’ll give the RNN a huge chunk of text and ask it to model the probability distribution of the next character in the sequence given a sequence of previous characters. This will then allow us to generate new text one character at a time.<br>好的，所以我们已经对RNN是什么、为什么它们非常令人兴奋以及它们如何工作有了一定的了解。现在，我们将把这些知识应用到一个有趣的实际应用中：我们将训练RNN字符级别的语言模型。也就是说，我们会给RNN提供一大段文本，并让它根据前面字符的序列来建模下一个字符的概率分布。这样一来，我们就可以一次生成一个字符的新文本。</p><p>As a working example, suppose we only had a vocabulary of four possible letters “helo”, and wanted to train an RNN on the training sequence “hello”. This training sequence is in fact a source of 4 separate training examples: 1. The probability of “e” should be likely given the context of “h”, 2. “l” should be likely in the context of “he”, 3. “l” should also be likely given the context of “hel”, and finally 4. “o” should be likely given the context of “hell”.<br>作为一个实际例子，假设我们只有四个可能的字母“helo”的词汇表，并且想要在训练序列“hello”上训练一个RNN。这个训练序列实际上是四个独立的训练示例的来源：</p><ol><li>在“h”的上下文中，“e”的概率应该很大。</li><li>在“he”的上下文中，“l”的概率应该很大。</li><li>在“hel”的上下文中，“l”的概率也应该很大。</li><li>最后，在“hell”的上下文中，“o”的概率应该很大。</li></ol><p>Concretely, we will encode each character into a vector using 1-of-k encoding (i.e. all zero except for a single one at the index of the character in the vocabulary), and feed them into the RNN one at a time with the <code>step</code> function. We will then observe a sequence of 4-dimensional output vectors (one dimension per character), which we interpret as the confidence the RNN currently assigns to each character coming next in the sequence. Here’s a diagram:<br>具体来说，我们将使用1-of-k编码将每个字符编码成一个向量（即，除了在词汇表中字符索引处为1，其余全为0），然后用step函数将它们逐一输入RNN。随后，我们会得到一系列4维输出向量（每个字符一个维度），我们将这些输出向量解释为RNN当前对序列中下一个字符的置信度。以下是一个示意图：</p><img src="/2472be8a/2.png" class><p>An example RNN with 4-dimensional input and output layers, and a hidden layer of 3 units (neurons). This diagram shows the activations in the forward pass when the RNN is fed the characters “hell” as input. The output layer contains confidences the RNN assigns for the next character (vocabulary is “h,e,l,o”); We want the green numbers to be high and red numbers to be low.<br>具有 4 维输入和输出层的示例 RNN，以及 3 个单元（神经元）的隐藏层。此图显示了将字符“hell”作为输入馈送 RNN 时前向传递中的激活。输出层包含 RNN 为下一个字符分配的置信度（词汇为“h，e，l，o”）;我们希望绿色数字高，红色数字低。</p><p>⚠️： W_xh 指输入层和隐藏层之间的权重矩阵， W_hh 指隐藏层之间的权重矩阵， W_hy 指隐藏层和输出层之间的权重矩阵</p><p>For example, we see that in the first time step when the RNN saw the character “h” it assigned confidence of 1.0 to the next letter being “h”, 2.2 to letter “e”, -3.0 to “l”, and 4.1 to “o”. Since in our training data (the string “hello”) the next correct character is “e”, we would like to increase its confidence (green) and decrease the confidence of all other letters (red). Similarly, we have a desired target character at every one of the 4 time steps that we’d like the network to assign a greater confidence to. Since the RNN consists entirely of differentiable operations we can run the backpropagation algorithm (this is just a recursive application of the chain rule from calculus) to figure out in what direction we should adjust every one of its weights to increase the scores of the correct targets (green bold numbers). We can then perform a _parameter update_, which nudges every weight a tiny amount in this gradient direction. If we were to feed the same inputs to the RNN after the parameter update we would find that the scores of the correct characters (e.g. “e” in the first time step) would be slightly higher (e.g. 2.3 instead of 2.2), and the scores of incorrect characters would be slightly lower. We then repeat this process over and over many times until the network converges and its predictions are eventually consistent with the training data in that correct characters are always predicted next.<br>例如，我们看到在第一个时间步中，当RNN看到字符“h”时，它对下一个字符的置信度分配为：字符“h”是1.0，字符“e”是2.2，字符“l”是-3.0，字符“o”是4.1。由于在我们的训练数据（字符串“hello”）中，下一个正确字符是“e”，我们希望增加“e”的置信度（用绿色表示），并降低所有其他字符的置信度（用红色表示）。类似地，在每一个时间步上，我们都有一个期望的目标字符，希望网络能对其分配更高的置信度。由于RNN完全由可微操作组成，我们可以运行反向传播算法（这只是微积分中链式法则的递归应用）来确定应调整每个权重的方向，以提高正确目标的得分（绿色加粗数字）。然后，我们可以执行参数更新，将每个权重在该梯度方向上微调一个小量。如果在参数更新后再次将相同的输入提供给RNN，我们会发现正确字符的得分（例如，第一个时间步中的“e”）会略有提高（例如，从2.2提高到2.3），而错误字符的得分会略有降低。然后，我们反复进行这个过程多次，直到网络收敛，其预测最终与训练数据一致，即总是预测出正确的下一个字符。</p><p>⚠️：图中output 层 数字并不是置信度，而是logits, 这些logits并不直接表示概率/置信度,要将这些logits转化为概率（置信度），我们通常使用Softmax函数。</p><p>A more technical explanation is that we use the standard Softmax classifier (also commonly referred to as the cross-entropy loss) on every output vector simultaneously. The RNN is trained with mini-batch Stochastic Gradient Descent and I like to use <a href="http://arxiv.org/abs/1502.04390">RMSProp</a> or Adam (per-parameter adaptive learning rate methods) to stablilize the updates.<br>更技术性的解释是，我们在每个输出向量上 同时使用标准的Softmax分类器（也常被称为交叉熵损失）。RNN使用小批量随机梯度下降法进行训练，我喜欢使用RMSProp或Adam（每个参数的自适应学习率方法）来稳定更新。</p><p>Notice also that the first time the character “l” is input, the target is “l”, but the second time the target is “o”. The RNN therefore cannot rely on the input alone and must use its recurrent connection to keep track of the context to achieve this task.<br>另请注意，第一次输入字符“l”时，目标是“l”，但第二次目标是“o”。因此，RNN 不能单独依赖输入，必须使用其循环连接来跟踪上下文以实现此任务。</p><p>At <strong>test time</strong>, we feed a character into the RNN and get a distribution over what characters are likely to come next. We sample from this distribution, and feed it right back in to get the next letter. Repeat this process and you’re sampling text! Lets now train an RNN on different datasets and see what happens.<br>在测试时，我们将一个字符输入RNN，并获得下一个字符可能出现的概率分布。我们从这个分布中采样，并将采样得到的字符再次输入RNN以获取下一个字符。重复这个过程，就可以生成文本了！现在，让我们在不同的数据集上训练一个RNN，看看会发生什么。</p><p>To further clarify, for educational purposes I also wrote a <a href="https://gist.github.com/karpathy/d4dee566867f8291f086">minimal character-level RNN language model in Python/numpy</a>. It is only about 100 lines long and hopefully it gives a concise, concrete and useful summary of the above if you’re better at reading code than text. We’ll now dive into example results, produced with the much more efficient Lua/Torch codebase.<br>为了进一步说明，我还用Python和numpy编写了一个最小的字符级RNN语言模型。它只有大约100行代码，希望能为你提供一个简洁、具体且有用的总结，如果你更擅长阅读代码而不是文字。现在，我们将深入探讨使用更加高效的Lua/Torch代码库生成的示例结果。</p><h1 id="fun-with-rnns"><a href="#Fun-with-RNNs" class="headerlink" title="Fun with RNNs"></a>Fun with RNNs</h1><p>All 5 example character models below were trained with the <a href="https://github.com/karpathy/char-rnn">code</a> I’m releasing on Github. The input in each case is a single file with some text, and we’re training an RNN to predict the next character in the sequence.<br>下面的所有 5 个示例字符模型都是使用我在 Github 上发布的代码训练的。每种情况下的输入都是一个包含一些文本的单个文件，我们正在训练一个 RNN 来预测序列中的下一个字符。</p><h3 id="paul-graham-generator-保罗格雷厄姆发电机"><a href="#Paul-Graham-generator-保罗·格雷厄姆发电机" class="headerlink" title="Paul Graham generator 保罗·格雷厄姆发电机"></a>Paul Graham generator 保罗·格雷厄姆发电机</h3><p>Lets first try a small dataset of English as a sanity check. My favorite fun dataset is the concatenation of <a href="http://www.paulgraham.com/articles.html">Paul Graham’s essays</a>. The basic idea is that there’s a lot of wisdom in these essays, but unfortunately Paul Graham is a relatively slow generator. Wouldn’t it be great if we could sample startup wisdom on demand? That’s where an RNN comes in.<br>让我们首先尝试一个小型的英文数据集来进行基本检查。我最喜欢的有趣数据集是保罗·格雷厄姆（Paul Graham）的文章合集。基本想法是，这些文章中有很多智慧，但遗憾的是，保罗·格雷厄姆的写作速度相对较慢。如果我们能按需采样创业智慧，那不是很棒吗？这正是RNN的用武之地。</p><p>Concatenating all pg essays over the last ~5 years we get approximately 1MB text file, or about 1 million characters (this is considered a very small dataset by the way). _Technical:_ Lets train a 2-layer LSTM with 512 hidden nodes (approx. 3.5 million parameters), and with dropout of 0.5 after each layer. We’ll train with batches of 100 examples and truncated backpropagation through time of length 100 characters. With these settings one batch on a TITAN Z GPU takes about 0.46 seconds (this can be cut in half with 50 character BPTT at negligible cost in performance). Without further ado, lets see a sample from the RNN:<br>将过去大约5年间的所有保罗·格雷厄姆的文章合并起来，我们得到了一个大约1MB的文本文件，约100万个字符（顺便说一下，这被认为是一个非常小的数据集）。技术细节：让我们训练一个具有2层、每层512个隐藏节点的LSTM（大约350万个参数），并在每层之后使用0.5的dropout。我们将使用100个样本的批次和长度为100字符的截断时间反向传播进行训练。在这些设置下，在TITAN Z GPU上处理一个批次大约需要0.46秒（使用50字符的截断时间反向传播，几乎不会影响性能，可以将时间减半）。事不宜迟，让我们看看RNN生成的一个样本：</p><p>_“The surprised in investors weren’t going to raise money. I’m not the company with the time there are all interesting quickly, don’t have to get off the same programmers. There’s a super-angel round fundraising, why do you can do. If you have a different physical investment are become in people who reduced in a startup with the way to argument the acquirer could see them just that you’re also the founders will part of users’ affords that and an alternation to the idea. [2] Don’t work at first member to see the way kids will seem in advance of a bad successful startup. And if you have to act the big company too.”_<br>_“投资者的惊讶是，他们并不打算筹集资金。我不是那个有时间的公司，有趣的事情很快就会出现，不需要让相同的程序员离开。有一个超级天使轮的融资，你为什么要这样做。如果你有不同的实体投资，会成为那些在初创公司里减少的人中争论的方式，收购者可能会看到他们只是创始人将成为用户努力的一部分，这是对想法的一种替代。[2] 一开始不要在成员身上工作，看孩子们将如何提前在一个失败的成功初创公司中表现出来。而且，如果你必须行动，那么大公司也一样。”_</p><p>Okay, clearly the above is unfortunately not going to replace Paul Graham anytime soon, but remember that the RNN had to learn English completely from scratch and with a small dataset (including where you put commas, apostrophes and spaces). I also like that it learns to support its own arguments (e.g. [2], above). Sometimes it says something that offers a glimmer of insight, such as _“a company is a meeting to think to investors”_. <a href="http://cs.stanford.edu/people/karpathy/char-rnn/pg.txt">Here’s</a> a link to 50K character sample if you’d like to see more.<br>好的，很明显，以上内容暂时还无法替代保罗·格雷厄姆，但请记住，RNN必须从零开始学习英语，而且是用一个小数据集（包括逗号、撇号和空格的位置）。我也喜欢它学会了支持自己的论点（例如，上文中的[2]）。有时，它会说出一些略带启发性的话，比如“a company is a meeting to think to investors”（公司是与投资者思考的会议）。如果你想查看更多，这里有一个50K字符的样本链接。</p><p><strong>Temperature.</strong> We can also play with the temperature of the Softmax during sampling. Decreasing the temperature from 1 to some lower number (e.g. 0.5) makes the RNN more confident, but also more conservative in its samples. Conversely, higher temperatures will give more diversity but at cost of more mistakes (e.g. spelling mistakes, etc). In particular, setting temperature very near zero will give the most likely thing that Paul Graham might say:<br>温度。我们也可以在采样过程中调整Softmax的温度。将温度从1降低到某个较低的数值（例如0.5），会使RNN更有信心，但也更保守于其采样结果。相反，较高的温度会带来更多的多样性，但代价是会有更多的错误（例如拼写错误等）。特别是，将温度设置得非常接近零，会产生最有可能是保罗·格雷厄姆会说的话：</p><p>_“is that they were all the same thing that was a startup is that they were all the same thing that was a startup is that they were all the same thing that was a startup is that they were all the same”<br>“他们都是一样的，创业公司是，他们都是创业公司，他们都是一样的创业公司，他们都是一样的，创业公司是一样的”_</p><p>looks like we’ve reached an infinite loop about startups.<br>看起来我们已经达到了一个关于初创公司的无限循环。</p><h3 id="shakespeare-莎士比亚"><a href="#Shakespeare-莎士比亚" class="headerlink" title="Shakespeare 莎士比亚"></a>Shakespeare 莎士比亚</h3><p>It looks like we can learn to spell English words. But how about if there is more structure and style in the data? To examine this I downloaded all the works of Shakespeare and concatenated them into a single (4.4MB) file. We can now afford to train a larger network, in this case lets try a 3-layer RNN with 512 hidden nodes on each layer. After we train the network for a few hours we obtain samples such as:<br>看起来我们可以学会拼写英语单词。但如果数据中有更多的结构和风格呢？为此，我下载了莎士比亚的所有作品，并将它们合并成一个单一的（4.4MB）文件。我们现在有能力训练一个更大的网络，在这种情况下，让我们尝试一个3层的RNN，每层有512个隐藏节点。经过几个小时的训练，我们得到如下样本：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">PANDARUS:</span><br><span class="line">Alas, I think he shall be come approached and the day</span><br><span class="line">When little srain would be attain&#x27;d into being never fed,</span><br><span class="line">And who is but a chain and subjects of his death,</span><br><span class="line">I should not sleep.</span><br><span class="line"></span><br><span class="line">Second Senator:</span><br><span class="line">They are away this miseries, produced upon my soul,</span><br><span class="line">Breaking and strongly should be buried, when I perish</span><br><span class="line">The earth and thoughts of many states.</span><br><span class="line"></span><br><span class="line">DUKE VINCENTIO:</span><br><span class="line">Well, your wit is in the care of side and that.</span><br><span class="line"></span><br><span class="line">Second Lord:</span><br><span class="line">They would be ruled after this chamber, and</span><br><span class="line">my fair nues begun out of the fact, to be conveyed,</span><br><span class="line">Whose noble souls I&#x27;ll have the heart of the wars.</span><br><span class="line"></span><br><span class="line">Clown:</span><br><span class="line">Come, sir, I will make did behold your worship.</span><br><span class="line"></span><br><span class="line">VIOLA:</span><br><span class="line">I&#x27;ll drink it.</span><br></pre></td></tr></table></figure></p><p>Remember, all the RNN knows are characters, so in particular it samples both speaker’s names and the contents. Sometimes we also get relatively extented monologue passages, such as:<br>请记住，RNN所知道的只有字符，因此它既采样说话者的名字，也采样内容。有时我们还会得到相对较长的独白段落，例如：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VIOLA:</span><br><span class="line">Why, Salisbury must find his flesh and thought</span><br><span class="line">That which I am not aps, not a man and in fire,</span><br><span class="line">To show the reining of the raven and the wars</span><br><span class="line">To grace my hand reproach within, and not a fair are hand,</span><br><span class="line">That Caesar and my goodly father&#x27;s world;</span><br><span class="line">When I was heaven of presence and our fleets,</span><br><span class="line">We spare with hours, but cut thy council I am great,</span><br><span class="line">Murdered and by thy master&#x27;s ready there</span><br><span class="line">My power to give thee but so much as hell:</span><br><span class="line">Some service in the noble bondman here,</span><br><span class="line">Would show him to her wine.</span><br><span class="line"></span><br><span class="line">KING LEAR:</span><br><span class="line">O, if you were a feeble sight, the courtesy of your law,</span><br><span class="line">Your sight and several breath, will wear the gods</span><br><span class="line">With his heads, and my hands are wonder&#x27;d at the deeds,</span><br><span class="line">So drop upon your lordship&#x27;s head, and your opinion</span><br><span class="line">Shall be against your honour.</span><br></pre></td></tr></table></figure></p><p>I can barely recognize these samples from actual Shakespeare :) If you like Shakespeare, you might appreciate this 100,000 character sample. Of course, you can also generate an infinite amount of your own samples at different temperatures with the provided code.<br>我几乎无法辨认这些样本是否真的是莎士比亚的作品 :) 如果你喜欢莎士比亚，你可能会喜欢这个10万字符的样本。当然，你也可以使用提供的代码在不同温度下生成无限量的样本。</p><h3 id="wikipedia-维基百科"><a href="#Wikipedia-维基百科" class="headerlink" title="Wikipedia 维基百科"></a>Wikipedia 维基百科</h3><p>We saw that the LSTM can learn to spell words and copy general syntactic structures. Lets further increase the difficulty and train on structured markdown. In particular, lets take the <a href="http://prize.hutter1.net/">Hutter Prize</a> 100MB dataset of raw Wikipedia and train an LSTM. Following <a href="http://arxiv.org/abs/1308.0850">Graves et al.</a>, I used the first 96MB for training, the rest for validation and ran a few models overnight. We can now sample Wikipedia articles! Below are a few fun excerpts. First, some basic markdown output:<br>我们已经看到LSTM可以学会拼写单词和复制一般的句法结构。让我们进一步增加难度，训练在结构化的Markdown上。特别是，让我们使用Hutter Prize的100MB原始维基百科数据集来训练一个LSTM。按照Graves等人的方法，我使用前96MB进行训练，剩余的用于验证，并在一夜之间运行了几个模型。现在我们可以采样生成维基百科文章了！以下是一些有趣的摘录。首先，是一些基本的Markdown输出：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Naturalism and decision for the majority of Arab countries&#x27; capitalide was grounded</span><br><span class="line">by the Irish language by [[John Clair]], [[An Imperial Japanese Revolt]], associated </span><br><span class="line">with Guangzham&#x27;s sovereignty. His generals were the powerful ruler of the Portugal </span><br><span class="line">in the [[Protestant Immineners]], which could be said to be directly in Cantonese </span><br><span class="line">Communication, which followed a ceremony and set inspired prison, training. The </span><br><span class="line">emperor travelled back to [[Antioch, Perth, October 25|21]] to note, the Kingdom </span><br><span class="line">of Costa Rica, unsuccessful fashioned the [[Thrales]], [[Cynth&#x27;s Dajoard]], known </span><br><span class="line">in western [[Scotland]], near Italy to the conquest of India with the conflict. </span><br><span class="line">Copyright was the succession of independence in the slop of Syrian influence that </span><br><span class="line">was a famous German movement based on a more popular servicious, non-doctrinal </span><br><span class="line">and sexual power post. Many governments recognize the military housing of the </span><br><span class="line">[[Civil Liberalization and Infantry Resolution 265 National Party in Hungary]], </span><br><span class="line">that is sympathetic to be to the [[Punjab Resolution]]</span><br><span class="line">(PJS)[http://www.humah.yahoo.com/guardian.</span><br><span class="line">cfm/7754800786d17551963s89.htm Official economics Adjoint for the Nazism, Montgomery </span><br><span class="line">was swear to advance to the resources for those Socialism&#x27;s rule, </span><br><span class="line">was starting to signing a major tripad of aid exile.]]</span><br></pre></td></tr></table></figure></p><p>In case you were wondering, the yahoo url above doesn’t actually exist, the model just hallucinated it. Also, note that the model learns to open and close the parenthesis correctly. There’s also quite a lot of structured markdown that the model learns, for example sometimes it creates headings, lists, etc.:<br>如果你在好奇，上述的Yahoo网址实际上并不存在，这是模型臆想出来的。此外，请注意，模型学会了正确地打开和关闭括号。模型还学习了大量的结构化Markdown，例如，有时它会创建标题、列表等内容：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123; &#123; cite journal | id=Cerling Nonforest Department|format=Newlymeslated|none &#125; &#125;</span><br><span class="line">&#x27;&#x27;www.e-complete&#x27;&#x27;.</span><br><span class="line"></span><br><span class="line">&#x27;&#x27;&#x27;See also&#x27;&#x27;&#x27;: [[List of ethical consent processing]]</span><br><span class="line"></span><br><span class="line">== See also ==</span><br><span class="line">*[[Iender dome of the ED]]</span><br><span class="line">*[[Anti-autism]]</span><br><span class="line"></span><br><span class="line">===[[Religion|Religion]]===</span><br><span class="line">*[[French Writings]]</span><br><span class="line">*[[Maria]]</span><br><span class="line">*[[Revelation]]</span><br><span class="line">*[[Mount Agamul]]</span><br><span class="line"></span><br><span class="line">== External links==</span><br><span class="line">* [http://www.biblegateway.nih.gov/entrepre/ Website of the World Festival. The labour of India-county defeats at the Ripper of California Road.]</span><br><span class="line"></span><br><span class="line">==External links==</span><br><span class="line">* [http://www.romanology.com/ Constitution of the Netherlands and Hispanic Competition for Bilabial and Commonwealth Industry (Republican Constitution of the Extent of the Netherlands)]</span><br></pre></td></tr></table></figure><br>Sometimes the model snaps into a mode of generating random but valid XML:<br>有时，模型会进入生成随机但有效的 XML 的模式：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;page&gt;</span><br><span class="line">  &lt;title&gt;Antichrist&lt;/title&gt;</span><br><span class="line">  &lt;id&gt;865&lt;/id&gt;</span><br><span class="line">  &lt;revision&gt;</span><br><span class="line">    &lt;id&gt;15900676&lt;/id&gt;</span><br><span class="line">    &lt;timestamp&gt;2002-08-03T18:14:12Z&lt;/timestamp&gt;</span><br><span class="line">    &lt;contributor&gt;</span><br><span class="line">      &lt;username&gt;Paris&lt;/username&gt;</span><br><span class="line">      &lt;id&gt;23&lt;/id&gt;</span><br><span class="line">    &lt;/contributor&gt;</span><br><span class="line">    &lt;minor /&gt;</span><br><span class="line">    &lt;comment&gt;Automated conversion&lt;/comment&gt;</span><br><span class="line">    &lt;text xml:space=&quot;preserve&quot;&gt;#REDIRECT [[Christianity]]&lt;/text&gt;</span><br><span class="line">  &lt;/revision&gt;</span><br><span class="line">&lt;/page&gt;</span><br></pre></td></tr></table></figure></p><p>The model completely makes up the timestamp, id, and so on. Also, note that it closes the correct tags appropriately and in the correct nested order. Here are <a href="http://cs.stanford.edu/people/karpathy/char-rnn/wiki.txt">100,000 characters of sampled wikipedia</a> if you’re interested to see more.<br>该模型完全由时间戳、id 等组成。另外，请注意，它正确地关闭了标签，并且按照正确的嵌套顺序。这里有 100,000 个字符的样本维基百科，如果您有兴趣查看更多。</p><h3 id="algebraic-geometry-latex-代数几何latex"><a href="#Algebraic-Geometry-Latex-代数几何（Latex）" class="headerlink" title="Algebraic Geometry (Latex)  代数几何（Latex）"></a>Algebraic Geometry (Latex)  代数几何（Latex）</h3><p>The results above suggest that the model is actually quite good at learning complex syntactic structures. Impressed by these results, my labmate (<a href="http://cs.stanford.edu/people/jcjohns/">Justin Johnson</a>) and I decided to push even further into structured territories and got a hold of <a href="http://stacks.math.columbia.edu/">this book</a> on algebraic stacks/geometry. We downloaded the raw Latex source file (a 16MB file) and trained a multilayer LSTM. Amazingly, the resulting sampled Latex _almost_ compiles. We had to step in and fix a few issues manually but then you get plausible looking math, it’s quite astonishing:<br>上述结果表明，模型在学习复杂句法结构方面实际上相当不错。这些结果给我留下了深刻的印象，我的实验室同事Justin Johnson和我决定进一步探索结构化领域，并找到了一本关于代数叠/几何的书。我们下载了原始的Latex源文件（一个16MB的文件）并训练了一个多层LSTM。令人惊讶的是，生成的Latex几乎可以编译。我们不得不手动修复一些问题，但最终得到了看起来很合理的数学表达，这真是令人惊叹：<br><img src="/2472be8a/3.png" class><br>Sampled (fake) algebraic geometry. <a href="http://cs.stanford.edu/people/jcjohns/fake-math/4.pdf">Here’s the actual pdf.</a><br>采样（假）代数几何。这是实际的pdf。</p><p>Here’s another sample: 下面是另一个示例：<br><img src="/2472be8a/4.png" class><br>More hallucinated algebraic geometry. Nice try on the diagram (right).<br>更多幻觉的代数几何。不错的尝试图（右）。</p><p>As you can see above, sometimes the model tries to generate latex diagrams, but clearly it hasn’t really figured them out. I also like the part where it chooses to skip a proof (_“Proof omitted.”_, top left). Of course, keep in mind that latex has a relatively difficult structured syntactic format that I haven’t even fully mastered myself. For instance, here is a raw sample from the model (unedited):<br>正如你在上面看到的，有时模型尝试生成Latex图表，但显然它还没有真正掌握这种技能。我也喜欢它选择跳过证明的部分（“Proof omitted.”，左上角）。当然，请记住，Latex有一个相对复杂的结构化句法格式，我自己都还没有完全掌握。例如，下面是模型生成的一个原始样本（未编辑）：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;proof&#125;</span><br><span class="line">We may assume that $\mathcal&#123;I&#125;$ is an abelian sheaf on $\mathcal&#123;C&#125;$.</span><br><span class="line">\item Given a morphism $\Delta : \mathcal&#123;F&#125; \to \mathcal&#123;I&#125;$</span><br><span class="line">is an injective and let $\mathfrak q$ be an abelian sheaf on $X$.</span><br><span class="line">Let $\mathcal&#123;F&#125;$ be a fibered complex. Let $\mathcal&#123;F&#125;$ be a category.</span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">\item \hyperref[setain-construction-phantom]&#123;Lemma&#125;</span><br><span class="line">\label&#123;lemma-characterize-quasi-finite&#125;</span><br><span class="line">Let $\mathcal&#123;F&#125;$ be an abelian quasi-coherent sheaf on $\mathcal&#123;C&#125;$.</span><br><span class="line">Let $\mathcal&#123;F&#125;$ be a coherent $\mathcal&#123;O&#125;_X$-module. Then</span><br><span class="line">$\mathcal&#123;F&#125;$ is an abelian catenary over $\mathcal&#123;C&#125;$.</span><br><span class="line">\item The following are equivalent</span><br><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line">\item $\mathcal&#123;F&#125;$ is an $\mathcal&#123;O&#125;_X$-module.</span><br><span class="line">\end&#123;lemma&#125;</span><br></pre></td></tr></table></figure></p><p>This sample from a relatively decent model illustrates a few common mistakes. For example, the model opens a <code>\begin&#123;proof&#125;</code> environment but then ends it with a <code>\end&#123;lemma&#125;</code>. This is an example of a problem we’d have to fix manually, and is likely due to the fact that the dependency is too long-term: By the time the model is done with the proof it has forgotten whether it was doing a proof or a lemma. Similarly, it opens an <code>\begin&#123;enumerate&#125;</code> but then forgets to close it. We observed that these became less common with larger/better models, but nonetheless, these are the kinds of mistakes that come up.<br>这个来自相对不错模型的样本展示了一些常见的错误。例如，模型打开了一个 \begin{proof} 环境，但随后却以 \end{lemma} 结束。这是一个我们必须手动修复的问题的例子，可能是由于依赖关系过于长期：到模型完成证明时，它已经忘记了自己是在进行证明还是引理。类似地，它打开了一个 \begin{enumerate}，但随后忘记了关闭它。我们注意到，这些错误在较大/更好的模型中变得不那么常见，但这些都是可能出现的错误类型。</p><h3 id="linux-source-code-linux-源代码"><a href="#Linux-Source-Code-Linux-源代码" class="headerlink" title="Linux Source Code Linux 源代码"></a>Linux Source Code Linux 源代码</h3><p>I wanted to push structured data to its limit, so for the final challenge I decided to use code. In particular, I took all the source and header files found in the <a href="https://github.com/torvalds/linux">Linux repo on Github</a>, concatenated all of them in a single giant file (474MB of C code) (I was originally going to train only on the kernel but that by itself is only ~16MB). Then I trained several as-large-as-fits-on-my-GPU 3-layer LSTMs over a period of a few days. These models have about 10 million parameters, which is still on the lower end for RNN models. The results are superfun:<br>我想将结构化数据推向极限，因此在最后的挑战中我决定使用代码。具体来说，我收集了Github上Linux仓库中的所有源文件和头文件，将它们合并成一个巨大的文件（474MB的C代码）（我本来打算只训练内核代码，但它本身只有大约16MB）。然后，我在几天内训练了多个尽可能适应GPU容量的三层LSTM模型。这些模型大约有1000万个参数，这在RNN模型中仍然算是较少的。结果非常有趣：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Increment the size file of the new incorrect UI_FILTER group information</span><br><span class="line"> * of the size generatively.</span><br><span class="line"> */</span><br><span class="line">static int indicate_policy(void)</span><br><span class="line">&#123;</span><br><span class="line">  int error;</span><br><span class="line">  if (fd == MARN_EPT) &#123;</span><br><span class="line">    /*</span><br><span class="line">     * The kernel blank will coeld it to userspace.</span><br><span class="line">     */</span><br><span class="line">    if (ss-&gt;segment &lt; mem_total)</span><br><span class="line">      unblock_graph_and_set_blocked();</span><br><span class="line">    else</span><br><span class="line">      ret = 1;</span><br><span class="line">    goto bail;</span><br><span class="line">  &#125;</span><br><span class="line">  segaddr = in_SB(in.addr);</span><br><span class="line">  selector = seg / 16;</span><br><span class="line">  setup_works = true;</span><br><span class="line">  for (i = 0; i &lt; blocks; i++) &#123;</span><br><span class="line">    seq = buf[i++];</span><br><span class="line">    bpf = bd-&gt;bd.next + i * search;</span><br><span class="line">    if (fd) &#123;</span><br><span class="line">      current = blocked;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  rw-&gt;name = &quot;Getjbbregs&quot;;</span><br><span class="line">  bprm_self_clearl(&amp;iv-&gt;version);</span><br><span class="line">  regs-&gt;new = blocks[(BPF_STATS &lt;&lt; info-&gt;historidac)] | PFMR_CLOBATHINC_SECONDS &lt;&lt; 12;</span><br><span class="line">  return segtable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>The code looks really quite great overall. Of course, I don’t think it compiles but when you scroll through the generate code it feels very much like a giant C code base. Notice that the RNN peppers its code with comments here and there at random. It is also very good at making very few syntactic errors. For example, it uses strings properly, pointer notation, etc. It also opens and closes brackets {   correctly and learns to indent its code very well. A common error is that it can’t keep track of variable names: It often uses undefined variables (e.g. rw above), declares variables it never uses (e.g. int error), or returns non-existing variables. Lets see a few more examples. Here’s another snippet that shows a wider array of operations that the RNN learns:</p><p>总体来说，这些代码看起来非常不错。当然，我不认为它能编译，但当你滚动查看生成的代码时，它确实给人一种巨大的C代码库的感觉。注意，RNN会随机在代码中插入注释，并且在语法错误方面表现得非常出色。例如，它能正确使用字符串、指针符号等，还能正确地打开和关闭大括号{}，并很好地学习代码缩进。<br>一个常见的错误是它无法跟踪变量名：它经常使用未定义的变量（例如上面的rw），声明从未使用的变量（例如int error），或者返回不存在的变量。让我们再看一些例子。下面是另一个代码片段，展示了RNN学到的更广泛的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * If this error is set, we will need anything right after that BSD.</span><br><span class="line"> */</span><br><span class="line">static void action_new_function(struct s_stat_info *wb)</span><br><span class="line">&#123;</span><br><span class="line">  unsigned long flags;</span><br><span class="line">  int lel_idx_bit = e-&gt;edd, *sys &amp; ~((unsigned long) *FIRST_COMPAT);</span><br><span class="line">  buf[0] = 0xFFFFFFFF &amp; (bit &lt;&lt; 4);</span><br><span class="line">  min(inc, slist-&gt;bytes);</span><br><span class="line">  printk(KERN_WARNING &quot;Memory allocated %02x/%02x, &quot;</span><br><span class="line">    &quot;original MLL instead\n&quot;),</span><br><span class="line">    min(min(multi_run - s-&gt;len, max) * num_data_in),</span><br><span class="line">    frame_pos, sz + first_seg);</span><br><span class="line">  div_u64_w(val, inb_p);</span><br><span class="line">  spin_unlock(&amp;disk-&gt;queue_lock);</span><br><span class="line">  mutex_unlock(&amp;s-&gt;sock-&gt;mutex);</span><br><span class="line">  mutex_unlock(&amp;func-&gt;mutex);</span><br><span class="line">  return disassemble(info-&gt;pending_bh);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void num_serial_settings(struct tty_struct *tty)</span><br><span class="line">&#123;</span><br><span class="line">  if (tty == tty)</span><br><span class="line">    disable_single_st_p(dev);</span><br><span class="line">  pci_disable_spool(port);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static void do_command(struct seq_file *m, void *v)</span><br><span class="line">&#123;</span><br><span class="line">  int column = 32 &lt;&lt; (cmd[2] &amp; 0x80);</span><br><span class="line">  if (state)</span><br><span class="line">    cmd = (int)(int_state ^ (in_8(&amp;ch-&gt;ch_flags) &amp; Cmd) ? 2 : 1);</span><br><span class="line">  else</span><br><span class="line">    seq = 1;</span><br><span class="line">  for (i = 0; i &lt; 16; i++) &#123;</span><br><span class="line">    if (k &amp; (1 &lt;&lt; 1))</span><br><span class="line">      pipe = (in_use &amp; UMXTHREAD_UNCCA) +</span><br><span class="line">        ((count &amp; 0x00000000fffffff8) &amp; 0x000000f) &lt;&lt; 8;</span><br><span class="line">    if (count == 0)</span><br><span class="line">      sub(pid, ppc_md.kexec_handle, 0x20000000);</span><br><span class="line">    pipe_set_bytes(i, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  /* Free our user pages pointer to place camera if all dash */</span><br><span class="line">  subsystem_info = &amp;of_changes[PAGE_SIZE];</span><br><span class="line">  rek_controls(offset, idx, &amp;soffset);</span><br><span class="line">  /* Now we want to deliberately put it to device */</span><br><span class="line">  control_check_polarity(&amp;context, val, 0);</span><br><span class="line">  for (i = 0; i &lt; COUNTER; i++)</span><br><span class="line">    seq_puts(s, &quot;policy &quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notice that in the second function the model compares tty == tty, which is vacuously true. On the other hand, at least the variable tty exists in the scope this time! In the last function, notice that the code does not return anything, which happens to be correct since the function signature is void. However, the first two functions were also declared void and did return values. This is again a form of a common mistake due to long-term interactions.<br>注意在第二个函数中，模型比较了tty == tty，这是显然为真的。另一方面，至少这次变量tty存在于作用域中！在最后一个函数中，注意代码没有返回任何东西，这正好是正确的，因为函数签名是void。然而，前两个函数也声明为void，但却返回了值。这再次是一种由于长时间交互而导致的常见错误形式。</p><p>Sometimes the model decides that it’s time to sample a new file. This is usually a very amusing part: The model first recites the GNU license character by character, samples a few includes, generates some macros and then dives into the code:<br>有时，模型会决定是时候采样一个新文件了。这通常是非常有趣的部分：模型首先逐字符地背诵GNU许可证，采样几个include语句，生成一些宏，然后深入到代码中：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> *  Copyright (c) 2006-2010, Intel Mobile Communications.  All rights reserved.</span><br><span class="line"> *</span><br><span class="line"> *   This program is free software; you can redistribute it and/or modify it</span><br><span class="line"> * under the terms of the GNU General Public License version 2 as published by</span><br><span class="line"> * the Free Software Foundation.</span><br><span class="line"> *</span><br><span class="line"> *        This program is distributed in the hope that it will be useful,</span><br><span class="line"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span><br><span class="line"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span><br><span class="line"> *</span><br><span class="line"> *  GNU General Public License for more details.</span><br><span class="line"> *</span><br><span class="line"> *   You should have received a copy of the GNU General Public License</span><br><span class="line"> *    along with this program; if not, write to the Free Software Foundation,</span><br><span class="line"> *  Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#include &lt;linux/kexec.h&gt;</span><br><span class="line">#include &lt;linux/errno.h&gt;</span><br><span class="line">#include &lt;linux/io.h&gt;</span><br><span class="line">#include &lt;linux/platform_device.h&gt;</span><br><span class="line">#include &lt;linux/multi.h&gt;</span><br><span class="line">#include &lt;linux/ckevent.h&gt;</span><br><span class="line"></span><br><span class="line">#include &lt;asm/io.h&gt;</span><br><span class="line">#include &lt;asm/prom.h&gt;</span><br><span class="line">#include &lt;asm/e820.h&gt;</span><br><span class="line">#include &lt;asm/system_info.h&gt;</span><br><span class="line">#include &lt;asm/setew.h&gt;</span><br><span class="line">#include &lt;asm/pgproto.h&gt;</span><br><span class="line"></span><br><span class="line">#define REG_PG    vesa_slot_addr_pack</span><br><span class="line">#define PFM_NOCOMP  AFSR(0, load)</span><br><span class="line">#define STACK_DDR(type)     (func)</span><br><span class="line"></span><br><span class="line">#define SWAP_ALLOCATE(nr)     (e)</span><br><span class="line">#define emulate_sigs()  arch_get_unaligned_child()</span><br><span class="line">#define access_rw(TST)  asm volatile(&quot;movd %%esp, %0, %3&quot; : : &quot;r&quot; (0));   \</span><br><span class="line">  if (__type &amp; DO_READ)</span><br><span class="line"></span><br><span class="line">static void stat_PC_SEC __read_mostly offsetof(struct seq_argsqueue, \</span><br><span class="line">          pC&gt;[1]);</span><br><span class="line"></span><br><span class="line">static void</span><br><span class="line">os_prefix(unsigned long sys)</span><br><span class="line">&#123;</span><br><span class="line">#ifdef CONFIG_PREEMPT</span><br><span class="line">  PUT_PARAM_RAID(2, sel) = get_state_state();</span><br><span class="line">  set_pid_sum((unsigned long)state, current_state_str(),</span><br><span class="line">           (unsigned long)-1-&gt;lr_full; low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>There are too many fun parts to cover- I could probably write an entire blog post on just this part. I’ll cut it short for now, but here is <a href="http://cs.stanford.edu/people/karpathy/char-rnn/linux.txt">1MB of sampled Linux code</a> for your viewing pleasure.<br>有太多有趣的部分要涵盖 - 我可能会写一整篇关于这部分的博客文章。我现在会缩短它，但这里有 1MB 的 Linux 代码样本供您查看。</p><h3 id="generating-baby-names-生成婴儿名字"><a href="#Generating-Baby-Names-生成婴儿名字" class="headerlink" title="Generating Baby Names 生成婴儿名字"></a>Generating Baby Names 生成婴儿名字</h3><p>Lets try one more for fun. Lets feed the RNN a large text file that contains 8000 baby names listed out, one per line (names obtained from <a href="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/nlp/corpora/names/">here</a>). We can feed this to the RNN and then generate new names! Here are some example names, only showing the ones that do not occur in the training data (90% don’t):<br>再来试一个有趣的实验。我们向RNN输入一个包含8000个婴儿名字的大文本文件，每行一个名字（名字从这里获得）。我们可以将其输入RNN，然后生成新的名字！以下是一些示例名字，只展示那些没有出现在训练数据中的名字（90%都不在训练数据中）：<br>_Rudi Levette Berice Lussa Hany Mareanne Chrestina Carissy Marylen Hammine Janye Marlise Jacacrie Hendred Romand Charienna Nenotto Ette Dorane Wallen Marly Darine Salina Elvyn Ersia Maralena Minoria Ellia Charmin Antley Nerille Chelon Walmor Evena Jeryly Stachon Charisa Allisa Anatha Cathanie Geetra Alexie Jerin Cassen Herbett Cossie Velen Daurenge Robester Shermond Terisa Licia Roselen Ferine Jayn Lusine Charyanne Sales Sanny Resa Wallon Martine Merus Jelen Candica Wallin Tel Rachene Tarine Ozila Ketia Shanne Arnande Karella Roselina Alessia Chasty Deland Berther Geamar Jackein Mellisand Sagdy Nenc Lessie Rasemy Guen Gavi Milea Anneda Margoris Janin Rodelin Zeanna Elyne Janah Ferzina Susta Pey Castina_</p><p>You can see many more <a href="http://cs.stanford.edu/people/karpathy/namesGenUnique.txt">here</a>. Some of my favorites include “Baby” (haha), “Killie”, “Char”, “R”, “More”, “Mars”, “Hi”, “Saddie”, “With” and “Ahbort”. Well that was fun.﻿ Of course, you can imagine this being quite useful inspiration when writing a novel, or naming a new startup :)<br>你可以在这里看到更多。我最喜欢的一些包括“宝贝”（haha）、“Killie”、“Char”、“R”、“More”、“Mars”、“Hi”、“Saddie”、“With”和“Ahbort”。嗯，这很有趣。当然，你可以想象这在写小说或命名新的创业公司时是非常有用的灵感:)</p><h1 id="understanding-whats-going-on"><a href="#Understanding-what’s-going-on" class="headerlink" title="Understanding what’s going on"></a>Understanding what’s going on</h1><p>We saw that the results at the end of training can be impressive, but how does any of this work? Lets run two quick experiments to briefly peek under the hood.<br>我们看到训练结束时的结果令人印象深刻，但这些是如何实现的呢？让我们进行两个快速实验，简要探究一下其内部工作原理。</p><h2 id="the-evolution-of-samples-while-training"><a href="#The-evolution-of-samples-while-training" class="headerlink" title="The evolution of samples while training"></a>The evolution of samples while training</h2><p>训练时样本的演变<br>First, it’s fun to look at how the sampled text evolves while the model trains. For example, I trained an LSTM of Leo Tolstoy’s War and Peace and then generated samples every 100 iterations of training. At iteration 100 the model samples random jumbles:<br>首先，观察模型训练过程中生成文本的演变是很有趣的。例如，我训练了一个基于列夫·托尔斯泰的《战争与和平》的LSTM，并在每100次迭代训练后生成样本。在第100次迭代时，模型生成的样本是随机混杂的字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tyntd-iafhatawiaoihrdemot  lytdws  e ,tfti, astai f ogoh eoase rrranbyne &#x27;nhthnee e </span><br><span class="line">plia tklrgd t o idoe ns,smtt   h ne etie h,hregtrs nigtike,aoaenns lng</span><br></pre></td></tr></table></figure><p>However, notice that at least it is starting to get an idea about words separated by spaces. Except sometimes it inserts two spaces. It also doesn’t know that comma is amost always followed by a space. At 300 iterations we see that the model starts to get an idea about quotes and periods:<br>然而，请注意至少模型开始有了关于单词由空格分隔的概念。尽管有时它会插入两个空格。它还不知道逗号后几乎总是跟着一个空格。在训练300次迭代时，我们看到模型开始了解引号和句号的用法：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;Tmont thithey&quot; fomesscerliund</span><br><span class="line">Keushey. Thom here</span><br><span class="line">sheulke, anmerenith ol sivh I lalterthend Bleipile shuwy fil on aseterlome</span><br><span class="line">coaniogennc Phe lism thond hon at. MeiDimorotion in ther thize.&quot;</span><br></pre></td></tr></table></figure><br>The words are now also separated with spaces and the model starts to get the idea about periods at the end of a sentence. At iteration 500:<br>现在，单词之间也用空格分隔，模型开始理解句末的句号。在第500次迭代时：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">we counter. He stutn co des. His stanted out one ofler that concossions and was </span><br><span class="line">to gearang reay Jotrets and with fre colt otf paitt thin wall. Which das stimn </span><br></pre></td></tr></table></figure><br>the model has now learned to spell the shortest and most common words such as “we”, “He”, “His”, “Which”, “and”, etc. At iteration 700 we’re starting to see more and more English-like text emerge:<br>模型现在已经学会了拼写最短和最常见的单词，比如“we”、“He”、“His”、“Which”、“and”等。在第700次迭代时，我们开始看到越来越多类似英语的文本出现：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Aftair fall unsuch that the hall for Prince Velzonski&#x27;s that me of</span><br><span class="line">her hearly, and behs to so arwage fiving were to it beloge, pavu say falling misfort </span><br><span class="line">how, and Gogition is so overelical and ofter.</span><br></pre></td></tr></table></figure></p><p>At iteration 1200 we’re now seeing use of quotations and question/exclamation marks. Longer words have now been learned as well:<br>在第1200次迭代时，我们现在看到了引号和问号/感叹号的使用。更长的单词也已经被学会了：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Kite vouch!&quot; he repeated by her</span><br><span class="line">door. &quot;But I would be done and quarts, feeling, then, son is people....&quot;</span><br></pre></td></tr></table></figure><br>Until at last we start to get properly spelled words, quotations, names, and so on by about iteration 2000:<br>直到最后，在大约第2000次迭代时，我们开始得到正确拼写的单词、引号、名字等：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;Why do what that day,&quot; replied Natasha, and wishing to himself the fact the</span><br><span class="line">princess, Princess Mary was easier, fed in had oftened him.</span><br><span class="line">Pierre aking his soul came to the packs and drove up his father-in-law women.</span><br></pre></td></tr></table></figure></p><p>The picture that emerges is that the model first discovers the general word-space structure and then rapidly starts to learn the words; First starting with the short words and then eventually the longer ones. Topics and themes that span multiple words (and in general longer-term dependencies) start to emerge only much later.<br>出现的情况是，模型首先发现了整体的单词-空格结构，然后迅速开始学习单词；先是短单词，然后逐渐学习长单词。跨越多个单词的主题和主题（以及一般的长期依赖关系）要到很久以后才会开始出现。</p><h2 id="visualizing-the-predictions-and-the-neuron-firings-in-the-rnn"><a href="#Visualizing-the-predictions-and-the-“neuron”-firings-in-the-RNN" class="headerlink" title="Visualizing the predictions and the “neuron” firings in the RNN"></a>Visualizing the predictions and the “neuron” firings in the RNN</h2><p>可视化 RNN 中的预测和“神经元”放电</p><p>Another fun visualization is to look at the predicted distributions over characters. In the visualizations below we feed a Wikipedia RNN model character data from the validation set (shown along the blue/green rows) and under every character we visualize (in red) the top 5 guesses that the model assigns for the next character. The guesses are colored by their probability (so dark red = judged as very likely, white = not very likely). For example, notice that there are stretches of characters where the model is extremely confident about the next letter (e.g., the model is very confident about characters during the _<a href="http://www._">http://www._</a> sequence).<br>另一个有趣的可视化是查看模型对字符的预测分布。在下面的可视化中，我们向一个训练好的Wikipedia RNN模型，提供验证集的字符数据（显示在蓝色/绿色行上），并在每个字符下方可视化（用红色表示）模型对下一个字符的前5个猜测。猜测根据其概率进行着色（深红色=被认为非常可能，白色=不太可能）。例如，请注意在某些字符序列中，模型对下一个字符极为自信(例如，模型对 <a href="http://www">http://www</a> 序列中的字符非常有信心）</p><p>The input character sequence (blue/green) is colored based on the _firing_ of a randomly chosen neuron in the hidden representation of the RNN. Think about it as green = very excited and blue = not very excited (for those familiar with details of LSTMs, these are values between [-1,1] in the hidden state vector, which is just the gated and tanh’d LSTM cell state). Intuitively, this is visualizing the firing rate of some neuron in the “brain” of the RNN while it reads the input sequence. Different neurons might be looking for different patterns; Below we’ll look at 4 different ones that I found and thought were interesting or interpretable (many also aren’t):<br>输入字符序列（蓝色/绿色）是根据RNN隐藏表示中随机选择的一个神经元的激活情况进行着色的。可以理解为绿色=非常激动，蓝色=不太激动（对于熟悉LSTM细节的人来说，这些值在隐藏状态向量中介于[-1,1]之间，这是经过门控和tanh函数处理的LSTM单元状态）。直观地说，这是在可视化RNN“脑中”某个神经元在读取输入序列时的激活率。不同的神经元可能在寻找不同的模式；下面我们将查看4个我发现有趣或可解释的神经元（也有很多是无法解释的）：</p><img src="/2472be8a/5.png" class><p>The neuron highlighted in this image seems to get very excited about URLs and turns off outside of the URLs. The LSTM is likely using this neuron to remember if it is inside a URL or not.<br>此图像中突出显示的神经元似乎对 URL 非常兴奋，并在 URL 之外关闭。LSTM 可能使用这个神经元来记住它是否在 URL 内。</p><img src="/2472be8a/6.png" class><p>The highlighted neuron here gets very excited when the RNN is inside the [[ ]] markdown environment and turns off outside of it. Interestingly, the neuron can’t turn on right after it sees the character “[“, it must wait for the second “[“ and then activate. This task of counting whether the model has seen one or two “[“ is likely done with a different neuron.<br>当 RNN 位于 [[ ]] markdown 环境内部并在其外部关闭时，此处突出显示的神经元会非常兴奋。有趣的是，神经元在看到字符“[”后无法立即打开，它必须等待第二个“[”然后激活。计算模型是否看到一个或两个“[”的任务可能是用不同的神经元完成的。</p><img src="/2472be8a/7.png" class><p>Here we see a neuron that varies seemingly linearly across the [[ ]] environment. In other words its activation is giving the RNN a time-aligned coordinate system across the [[ ]] scope. The RNN can use this information to make different characters more or less likely depending on how early/late it is in the [[ ]] scope (perhaps?).<br>在这里，我们看到一个神经元，它在[[ ]]环境中似乎呈线性变化。换句话说，它的激活为 RNN 提供了一个跨 [[ ]] 范围的时间对齐坐标系。RNN 可以使用此信息或多或少地使不同的字符更有可能，具体取决于它在 [[ ]] 范围内的早/晚（也许？</p><img src="/2472be8a/8.png" class><p>Here is another neuron that has very local behavior: it is relatively silent but sharply turns off right after the first “w” in the “www” sequence. The RNN might be using this neuron to count up how far in the “www” sequence it is, so that it can know whether it should emit another “w”, or if it should start the URL.<br>这是另一个具有非常局部行为的神经元：它相对安静，但在“www”序列中的第一个“w”之后急剧关闭。RNN 可能正在使用这个神经元来计算它在“www”序列中的距离，以便它可以知道它是否应该发出另一个“w”，或者它是否应该启动 URL。</p><p>Of course, a lot of these conclusions are slightly hand-wavy as the hidden state of the RNN is a huge, high-dimensional and largely distributed representation. These visualizations were produced with custom HTML/CSS/Javascript, you can see a sketch of what’s involved <a href="http://cs.stanford.edu/people/karpathy/viscode.zip">here</a> if you’d like to create something similar.<br>当然，很多这些结论都有些笼统，因为RNN的隐藏状态是一个巨大的、高维的、广泛分布的表示。这些可视化是使用自定义的HTML/CSS/Javascript生成的，如果你想创建类似的东西，可以在这里看到涉及的内容示例。</p><p>We can also condense this visualization by excluding the most likely predictions and only visualize the text, colored by activations of a cell. We can see that in addition to a large portion of cells that do not do anything interpretible, about 5% of them turn out to have learned quite interesting and interpretible algorithms:<br>我们还可以通过排除最可能的预测并仅根据单元激活情况对文本进行着色来简化这种可视化。我们可以看到，除了大部分不可解释的单元外，大约有5%的单元学会了相当有趣且可解释的算法：<br><img src="/2472be8a/9.png" class><br><img src="/2472be8a/10.png" class><br>Again, what is beautiful about this is that we didn’t have to hardcode at any point that if you’re trying to predict the next character it might, for example, be useful to keep track of whether or not you are currently inside or outside of quote. We just trained the LSTM on raw data and it decided that this is a useful quantitity to keep track of. In other words one of its cells gradually tuned itself during training to become a quote detection cell, since this helps it better perform the final task. This is one of the cleanest and most compelling examples of where the power in Deep Learning models (and more generally end-to-end training) is coming from.<br>再次强调，这其中的美妙之处在于，我们不需要在任何时候硬编码，例如在预测下一个字符时需要跟踪当前是否在引号内或引号外。我们只是对LSTM进行原始数据的训练，它自己决定跟踪这个信息是有用的。换句话说，其中一个单元在训练过程中逐渐调整自己，变成了一个引号检测单元，因为这有助于它更好地完成最终任务。这是深度学习模型（更广泛地说，端到端训练）力量的最清晰和最有说服力的例子之一。</p><h1 id="source-code-源代码"><a href="#Source-Code-源代码" class="headerlink" title="Source Code 源代码"></a>Source Code 源代码</h1><p>I hope I’ve convinced you that training character-level language models is a very fun exercise. You can train your own models using the <a href="https://github.com/karpathy/char-rnn">char-rnn code</a> I released on Github (under MIT license). It takes one large text file and trains a character-level model that you can then sample from. Also, it helps if you have a GPU or otherwise training on CPU will be about a factor of 10x slower. In any case, if you end up training on some data and getting fun results let me know! And if you get lost in the Torch/Lua codebase remember that all it is is just a more fancy version of this <a href="https://gist.github.com/karpathy/d4dee566867f8291f086">100-line gist</a>.<br>我希望我已经让你相信，训练字符级语言模型是一个非常有趣的练习。你可以使用我在Github上发布的char-rnn代码（基于MIT许可证）来训练你自己的模型。它需要一个大型文本文件，并训练一个字符级模型，你可以从中进行采样。此外，如果你有GPU，这会更有帮助，否则在CPU上训练的速度大约会慢10倍。不管怎样，如果你在一些数据上训练并得到了有趣的结果，请告诉我！如果你在Torch/Lua代码库中迷失了方向，请记住，这只是这个100行代码示例的更复杂版本。</p><p>_Brief digression._ The code is written in <a href="http://torch.ch/">Torch 7</a>, which has recently become my favorite deep learning framework. I’ve only started working with Torch/LUA over the last few months and it hasn’t been easy (I spent a good amount of time digging through the raw Torch code on Github and asking questions on their _gitter_ to get things done), but once you get a hang of things it offers a lot of flexibility and speed. I’ve also worked with Caffe and Theano in the past and I believe Torch, while not perfect, gets its levels of abstraction and philosophy right better than others. In my view the desirable features of an effective framework are:<br>简单插曲一下。这段代码是用Torch 7编写的，它最近成为了我最喜欢的深度学习框架。我只是过去几个月才开始使用Torch/LUA，过程并不容易（我花了大量时间在Github上挖掘Torch的源代码，并在他们的gitter上提问以解决问题），但一旦你掌握了它，它就能提供很大的灵活性和速度。我过去也使用过Caffe和Theano，我认为Torch虽然不完美，但它在抽象层次和理念上做得比其他框架更好。在我看来，一个有效框架的理想特性是：</p><ol><li>CPU/GPU transparent Tensor library with a lot of functionality (slicing, array/matrix operations, etc. )<br><strong>CPU/GPU透明的张量库</strong>：具有丰富的功能（切片、数组/矩阵操作等）。）</li><li>An entirely separate code base in a scripting language (ideally Python) that operates over Tensors and implements all Deep Learning stuff (forward/backward, computation graphs, etc)<br><strong>完全独立的脚本语言代码库</strong>：理想情况下是Python，操作张量并实现所有深度学习相关功能（前向/后向传播、计算图等）。</li><li>It should be possible to easily share pretrained models (Caffe does this well, others don’t), and crucially<br><strong>能够轻松共享预训练模型</strong>：Caffe在这方面做得很好，其他框架则不尽如人意。</li><li>NO compilation step (or at least not as currently done in Theano). The trend in Deep Learning is towards larger, more complex networks that are are time-unrolled in complex graphs. It is critical that these do not compile for a long time or development time greatly suffers. Second, by compiling one gives up interpretability and the ability to log/debug effectively. If there is an _option_ to compile the graph once it has been developed for efficiency in prod that’s fine.<br><strong>没有编译步骤</strong>：或至少不像Theano目前那样。深度学习的发展趋势是使用更大、更复杂的网络，这些网络在复杂的计算图中进行时间展开。关键是这些图不应长时间编译，否则会严重影响开发时间。其次，通过编译，会失去可解释性和有效记录/调试的能力。如果有选项可以在开发完成后编译图以提高生产效率，那也很好。</li></ol><h1 id="further-reading-延伸阅读"><a href="#Further-Reading-延伸阅读" class="headerlink" title="Further Reading 延伸阅读"></a>Further Reading 延伸阅读</h1><p>Before the end of the post I also wanted to position RNNs in a wider context and provide a sketch of the current research directions. RNNs have recently generated a significant amount of buzz and excitement in the field of Deep Learning. Similar to Convolutional Networks they have been around for decades but their full potential has only recently started to get widely recognized, in large part due to our growing computational resources. Here’s a brief sketch of a few recent developments (definitely not complete list, and a lot of this work draws from research back to 1990s, see related work sections):<br>在文章的结尾，我还想把RNN放在更广泛的背景中，并提供当前研究方向的概述。最近，RNN在深度学习领域引起了大量关注和兴奋。类似于卷积网络，RNN已经存在了几十年，但它们的全部潜力直到最近才开始被广泛认可，这在很大程度上要归功于我们不断增长的计算资源。以下是一些最近发展的简要概述（绝不是完整的列表，其中很多工作可以追溯到1990年代，详见相关研究部分）：</p><p>In the domain of <strong>NLP/Speech</strong>, RNNs <a href="http://www.jmlr.org/proceedings/papers/v32/graves14.pdf">transcribe speech to text</a>, perform <a href="http://arxiv.org/abs/1409.3215">machine translation</a>, <a href="http://www.cs.toronto.edu/~graves/handwriting.html">generate handwritten text</a>, and of course, they have been used as powerful language models <a href="http://www.cs.utoronto.ca/~ilya/pubs/2011/LANG-RNN.pdf">(Sutskever et al.)</a> <a href="http://arxiv.org/abs/1308.0850">(Graves)</a> <a href="http://www.rnnlm.org/">(Mikolov et al.)</a> (both on the level of characters and words). Currently it seems that word-level models work better than character-level models, but this is surely a temporary thing.<br>在NLP/Speech领域，RNN用于将语音转录为文本、执行机器翻译、生成手写文本，当然，它们也被用作强大的语言模型（Sutskever等人）（Graves）（Mikolov等人）（包括字符级和单词级）。目前看来，单词级模型比字符级模型效果更好，但这肯定只是暂时的。</p><p><strong>Computer Vision.</strong> RNNs are also quickly becoming pervasive in Computer Vision. For example, we’re seeing RNNs in frame-level <a href="http://arxiv.org/abs/1411.4389">video classification</a>, <a href="http://arxiv.org/abs/1411.4555">image captioning</a> (also including my own work and many others), <a href="http://arxiv.org/abs/1505.00487">video captioning</a> and very recently <a href="http://arxiv.org/abs/1505.02074">visual question answering</a>. My personal favorite RNNs in Computer Vision paper is <a href="http://arxiv.org/abs/1406.6247">Recurrent Models of Visual Attention</a>, both due to its high-level direction (sequential processing of images with glances) and the low-level modeling (REINFORCE learning rule that is a special case of policy gradient methods in Reinforcement Learning, which allows one to train models that perform non-differentiable computation (taking glances around the image in this case)). I’m confident that this type of hybrid model that consists of a blend of CNN for raw perception coupled with an RNN glance policy on top will become pervasive in perception, especially for more complex tasks that go beyond classifying some objects in plain view.<br>计算机视觉。RNN也迅速在计算机视觉领域普及。例如，我们看到RNN用于帧级视频分类、图像描述生成（包括我自己的工作和许多其他人的工作）、视频描述生成以及最近的视觉问答。我个人最喜欢的计算机视觉领域的RNN论文是《视觉注意力的递归模型》，因为它在高层次方向（通过扫视对图像进行顺序处理）和低层次建模（REINFORCE学习规则，这是强化学习中策略梯度方法的特例，允许训练执行不可微计算的模型（在本例中是环顾图像））上都很出色。我相信这种混合模型，即结合了用于原始感知的CNN和用于扫视策略的RNN的模型，将在感知领域普及，特别是在超越简单对象分类的复杂任务中。</p><p><strong>Inductive Reasoning, Memories and Attention.</strong> Another extremely exciting direction of research is oriented towards addressing the limitations of vanilla recurrent networks. One problem is that RNNs are not inductive: They memorize sequences extremely well, but they don’t necessarily always show convincing signs of generalizing in the _correct_ way (I’ll provide pointers in a bit that make this more concrete). A second issue is they unnecessarily couple their representation size to the amount of computation per step. For instance, if you double the size of the hidden state vector you’d quadruple the amount of FLOPS at each step due to the matrix multiplication. Ideally, we’d like to maintain a huge representation/memory (e.g. containing all of Wikipedia or many intermediate state variables), while maintaining the ability to keep computation per time step fixed.<br>归纳推理、记忆和注意力。另一个极其令人兴奋的研究方向是解决普通循环网络的局限性。一个问题是RNN不具备归纳能力：它们非常擅长记忆序列，但不一定总是能以正确的方式表现出令人信服的泛化能力（稍后我会提供一些具体的例子）。第二个问题是它们不必要地将表示大小与每步计算量耦合在一起。例如，如果你将隐藏状态向量的大小加倍，那么由于矩阵乘法，每步的浮点运算量（FLOPS）将增加四倍。理想情况下，我们希望保持一个巨大的表示/记忆（例如包含整个维基百科或许多中间状态变量），同时保持每个时间步的计算量固定。</p><p>The first convincing example of moving towards these directions was developed in DeepMind’s <a href="http://arxiv.org/abs/1410.5401">Neural Turing Machines</a> paper. This paper sketched a path towards models that can perform read/write operations between large, external memory arrays and a smaller set of memory registers (think of these as our working memory) where the computation happens. Crucially, the NTM paper also featured very interesting memory addressing mechanisms that were implemented with a (soft, and fully-differentiable) attention model. The concept of <strong>soft attention</strong> has turned out to be a powerful modeling feature and was also featured in <a href="http://arxiv.org/abs/1409.0473">Neural Machine Translation by Jointly Learning to Align and Translate</a> for Machine Translation and <a href="http://arxiv.org/abs/1503.08895">Memory Networks</a> for (toy) Question Answering. In fact, I’d go as far as to say that<br>第一个朝着这些方向前进的令人信服的例子是DeepMind的《神经图灵机》（Neural Turing Machines）论文。这篇论文勾画了一个模型的路径，这些模型可以在大型外部存储阵列和一小组计算发生的存储寄存器（可以将这些视为我们的工作记忆）之间执行读/写操作。至关重要的是，NTM论文还展示了非常有趣的记忆寻址机制，这些机制通过一个（软且完全可微分的）注意力模型实现。软注意力的概念被证明是一个强大的建模特性，它也出现在《通过联合学习对齐和翻译的神经机器翻译》和《记忆网络用于（玩具）问答》中。实际上，我甚至可以说</p><p>The concept of <strong>attention</strong> is the most interesting recent architectural innovation in neural networks.<br>注意力的概念是神经网络中最近最有趣的架构创新。</p><p>Now, I don’t want to dive into too many details but a soft attention scheme for memory addressing is convenient because it keeps the model fully-differentiable, but unfortunately one sacrifices efficiency because everything that can be attended to is attended to (but softly). Think of this as declaring a pointer in C that doesn’t point to a specific address but instead defines an entire distribution over all addresses in the entire memory, and dereferencing the pointer returns a weighted sum of the pointed content (that would be an expensive operation!). This has motivated multiple authors to swap soft attention models for <strong>hard attention</strong> where one samples a particular chunk of memory to attend to (e.g. a read/write action for some memory cell instead of reading/writing from all cells to some degree). This model is significantly more philosophically appealing, scalable and efficient, but unfortunately it is also non-differentiable. This then calls for use of techniques from the Reinforcement Learning literature (e.g. REINFORCE) where people are perfectly used to the concept of non-differentiable interactions. This is very much ongoing work but these hard attention models have been explored, for example, in <a href="http://arxiv.org/abs/1503.01007">Inferring Algorithmic Patterns with Stack-Augmented Recurrent Nets</a>, <a href="http://arxiv.org/abs/1505.00521">Reinforcement Learning Neural Turing Machines</a>, and <a href="http://arxiv.org/abs/1502.03044">Show Attend and Tell</a>.<br>现在，我不想深入研究太多细节，但用于内存寻址的软注意力方案很方便，因为它使模型保持完全可微分，但不幸的是，人们牺牲了效率，因为所有可以处理的东西都被处理了（但很软）。可以把它想象成在 C 语言中声明一个指针，该指针不指向特定地址，而是在整个内存中的所有地址上定义整个分布，并且取消引用指针会返回指向内容的加权总和（这将是一个昂贵的操作！这促使多位作者将软注意力模型换成硬注意力模型，其中一个人对要关注的特定内存块进行采样（例如，对某些记忆单元进行读/写操作，而不是在某种程度上从所有单元读取/写入）。这个模型在哲学上更具吸引力、可扩展性和效率，但不幸的是，它也是不可微分的。然后，这需要使用强化学习文献中的技术（例如REINFORCE），在这些技术中，人们完全习惯了不可微分交互的概念。这是一项正在进行的工作，但这些硬注意力模型已经被探索过，例如，在使用堆栈增强的循环网络推断算法模式、强化学习神经图灵机和显示、出席和讲述中。</p><p><strong>People</strong>. If you’d like to read up on RNNs I recommend theses from <a href="http://www.cs.toronto.edu/~graves/">Alex Graves</a>, <a href="http://www.cs.toronto.edu/~ilya/">Ilya Sutskever</a> and <a href="http://www.rnnlm.org/">Tomas Mikolov</a>. For more about REINFORCE and more generally Reinforcement Learning and policy gradient methods (which REINFORCE is a special case of) <a href="http://www0.cs.ucl.ac.uk/staff/d.silver/web/Home.html">David Silver</a>’s class, or one of <a href="http://www.cs.berkeley.edu/~pabbeel/">Pieter Abbeel</a>’s classes.<br>人。如果你想深入了解RNN，我推荐阅读Alex Graves、Ilya Sutskever和Tomas Mikolov的论文。关于REINFORCE和更广泛的强化学习及策略梯度方法（REINFORCE是其特例），可以参考David Silver的课程，或Pieter Abbeel的课程之一。</p><p><strong>Code</strong>. If you’d like to play with training RNNs I hear good things about <a href="https://github.com/fchollet/keras">keras</a> or <a href="https://github.com/IndicoDataSolutions/Passage">passage</a> for Theano, the <a href="https://github.com/karpathy/char-rnn">code</a> released with this post for Torch, or <a href="https://gist.github.com/karpathy/587454dc0146a6ae21fc">this gist</a> for raw numpy code I wrote a while ago that implements an efficient, batched LSTM forward and backward pass. You can also have a look at my numpy-based <a href="https://github.com/karpathy/neuraltalk">NeuralTalk</a> which uses an RNN/LSTM to caption images, or maybe this <a href="http://jeffdonahue.com/lrcn/">Caffe</a> implementation by Jeff Donahue.<br>代码。如果你想尝试训练RNN，我听说keras或passage for Theano的评价很好，可以参考本文发布的用于Torch的代码，或者我之前编写的这个实现了高效批量LSTM前向和后向传递的纯numpy代码。你也可以看看我基于numpy的NeuralTalk，它使用RNN/LSTM生成图像描述，或者看看Jeff Donahue的这个Caffe实现。</p><h1 id="conclusion-结论"><a href="#Conclusion-结论" class="headerlink" title="Conclusion 结论"></a>Conclusion 结论</h1><p>We’ve learned about RNNs, how they work, why they have become a big deal, we’ve trained an RNN character-level language model on several fun datasets, and we’ve seen where RNNs are going. You can confidently expect a large amount of innovation in the space of RNNs, and I believe they will become a pervasive and critical component to intelligent systems.<br>我们已经了解了RNN，它们是如何工作的，为什么它们变得如此重要。我们在几个有趣的数据集上训练了一个RNN字符级语言模型，并且看到了RNN的发展方向。你可以自信地期待在RNN领域出现大量的创新，我相信它们将成为智能系统中普遍且关键的组成部分。</p><p>Lastly, to add some <strong>meta</strong> to this post, I trained an RNN on the source file of this blog post. Unfortunately, at about 46K characters I haven’t written enough data to properly feed the RNN, but the returned sample (generated with low temperature to get a more typical sample) is:<br>最后，为了给这篇文章增加一些元内容，我用这篇博客文章的源文件训练了一个RNN。不幸的是，大约46K字符的数据量还不足以充分训练RNN，但生成的样本（在低温下生成，以获得更典型的样本）如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;ve the RNN with and works, but the computed with program of the </span><br><span class="line">RNN with and the computed of the RNN with with and the code</span><br></pre></td></tr></table></figure><p>Yes, the post was about RNN and how well it works, so clearly this works :). See you next time!<br>是的，这篇文章是关于 RNN 及其工作情况的，所以很明显这:)工作。下次再见！</p><h1 id="edit-extra-links-编辑额外链接"><a href="#EDIT-extra-links-编辑（额外链接）" class="headerlink" title="EDIT (extra links): 编辑（额外链接）"></a>EDIT (extra links): 编辑（额外链接）</h1><p>Videos: 视频：</p><ul><li>I gave a talk on this work at the <a href="https://skillsmatter.com/skillscasts/6611-visualizing-and-understanding-recurrent-networks">London Deep Learning meetup (video)</a>.<br>我在伦敦深度学习聚会上就这项工作发表了演讲（视频）。</li></ul><p>Discussions: 讨论：</p><ul><li><a href="https://news.ycombinator.com/item?id=9584325">HN discussion HN 讨论</a></li><li>Reddit discussion on <a href="http://www.reddit.com/r/MachineLearning/comments/36s673/the_unreasonable_effectiveness_of_recurrent/">r/machinelearning</a><br>Reddit 关于 r/machinelearning 的讨论</li><li>Reddit discussion on <a href="http://www.reddit.com/r/programming/comments/36su8d/the_unreasonable_effectiveness_of_recurrent/">r/programming</a><br>Reddit 上关于 r/programming 的讨论</li></ul><p>Replies: 答复：</p><ul><li><a href="https://twitter.com/yoavgo">Yoav Goldberg</a> compared these RNN results to <a href="http://nbviewer.ipython.org/gist/yoavg/d76121dfde2618422139">n-gram maximum likelihood (counting) baseline</a><br>Yoav Goldberg 将这些 RNN 结果与 n-gram 最大似然（计数）基线进行了比较</li><li><a href="https://twitter.com/nylk">@nylk</a> trained char-rnn on <a href="https://gist.github.com/nylki/1efbaa36635956d35bcc">cooking recipes</a>. They look great!<br>@nylk培训了char-rnn的烹饪食谱。它们看起来很棒！</li><li><a href="https://twitter.com/MrChrisJohnson">@MrChrisJohnson</a> trained char-rnn on Eminem lyrics and then synthesized a rap song with robotic voice reading it out. Hilarious :)<br>@MrChrisJohnson用 Eminem 的歌词训练了 char-rnn，然后合成了一首带有机器人声音的说唱歌曲。搞笑:)</li><li><a href="https://twitter.com/samim">@samim</a> trained char-rnn on <a href="https://medium.com/@samim/obama-rnn-machine-generated-political-speeches-c8abd18a2ea0">Obama Speeches</a>. They look fun!<br>@samim培训了奥巴马演讲的char-rnn。他们看起来很有趣！</li><li><a href="https://twitter.com/seaandsailor">João Felipe</a> trained char-rnn irish folk music and <a href="https://soundcloud.com/seaandsailor/sets/char-rnn-composes-irish-folk-music">sampled music</a><br>若昂·费利佩（João Felipe）训练了char-rnn爱尔兰民间音乐并采样了音乐</li><li><a href="https://twitter.com/boblsturm">Bob Sturm</a> also trained char-rnn on <a href="https://highnoongmt.wordpress.com/2015/05/22/lisls-stis-recurrent-neural-networks-for-folk-music-generation/">music in ABC notation</a><br>鲍勃·斯特姆（Bob Sturm）还对char-rnn进行了ABC记谱法的音乐培训</li><li><a href="https://twitter.com/RNN_Bible">RNN Bible bot</a> by <a href="https://twitter.com/the__glu/with_replies">Maximilien</a><br>RNN Bible bot 的 Maximilien</li><li><a href="http://cpury.github.io/learning-holiness/">Learning Holiness</a> learning the Bible<br>学习圣洁 学习圣经</li><li><a href="https://www.terminal.com/tiny/ZMcqdkWGOM">Terminal.com snapshot</a> that has char-rnn set up and ready to go in a browser-based virtual machine (thanks <a href="https://www.twitter.com/samim">@samim</a>)<br>Terminal.com 已设置 char-rnn 并准备在基于浏览器的虚拟机中使用的快照（感谢 @samim）</li></ul><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><h2 id="1vanilla-神经网络"><a href="#1-Vanilla-神经网络" class="headerlink" title="1.Vanilla 神经网络"></a>1.Vanilla 神经网络</h2><p>“Vanilla 神经网络”通常指的是最基本、最简单的神经网络模型，没有使用任何特殊的层或复杂的架构。具体来说，它一般指的是简单的前馈神经网络（Feedforward Neural Network, FNN）</p><h2 id="2-向量vectorvs-序列sequence"><a href="#2-向量（Vector）vs-序列（Sequence）" class="headerlink" title="2. 向量（Vector）vs 序列（Sequence）"></a>2. 向量（Vector）vs 序列（Sequence）</h2><p><strong>向量（Vector）</strong>：</p><ul><li><strong>定义</strong>：在数学和计算机科学中，向量是一组有序的数值。这些数值可以表示多维空间中的一个点或某个特定的数据结构。</li><li><strong>特性</strong>：<ul><li>固定长度：向量的长度是固定的，例如一个包含三个数值的向量$x_1, x_2, x_3$。 这种处理方式对于图像分类、固定长度的文本分类等任务非常有效。</li><li>无时间依赖：向量中的元素没有时间或顺序上的依赖关系。例如，一张图片的像素数据可以作为输入向量，但这些像素之间没有时间顺序上的关系。</li></ul></li><li><strong>示例</strong>：<ul><li>图像处理中的像素值向量。</li><li>静态文本分类中的单词向量。</li></ul></li><li><strong>向量输入输出</strong>：向量输入输出通常指的是神经网络处理固定长度的向量，即一组固定大小的数值输入和输出。</li><li><strong>应用场景</strong>：<ul><li>图像分类：输入是一个固定大小的图像向量，输出是一个类别标签向量。</li><li>静态文本分类：输入是一个表示单个文档的向量，输出是分类标签。</li></ul></li></ul><p><strong>序列（Sequence）</strong>：</p><ul><li><strong>定义</strong>：序列是一组按特定顺序排列的数据，通常是时间或顺序相关的。</li><li><strong>特性</strong>：<ul><li>变长：序列的长度可以变化，例如一段文本可以是一个字符序列$c_1, c_2, …, c_t$</li><li>有时间依赖：序列中的元素有时间或顺序上的依赖关系。后续元素依赖于前面出现的元素。例如，在自然语言处理中，一个句子的单词顺序决定了句子的意义。</li></ul></li><li><strong>示例</strong>：<ul><li>时间序列数据，如股票价格的每日记录。</li><li>文本数据，如一段句子中的单词序列。</li></ul></li><li><strong>序列输入输出</strong>：序列输入输出指的是神经网络处理一系列的输入数据，这些数据有时间或顺序上的依赖关系。RNN（循环神经网络）就是处理序列数据的典型模型。</li><li><strong>应用场景</strong>：<ul><li>语言模型和文本生成：输入是一个文本序列，输出是下一个字符或单词的预测序列。</li><li>机器翻译：输入是源语言的句子序列，输出是目标语言的句子序列。</li><li>语音识别：输入是语音信号的时间序列，输出是对应的文本序列。</li></ul></li></ul><h2 id="3-rnn-computation"><a href="#3-RNN-computation" class="headerlink" title="3. RNN computation"></a>3. RNN computation</h2><p>论文正文中对该过程的描述文字较多，我反倒觉得结合数学公式后更好理解。<br>这里描述就是 RNN 的前向传播过程， 如果你了解了基础神经网络的前向传播过程，那么RNN也非常好理解。</p><p>简单理解就是 相比在神经网络一文中讲述的基础 前向传播过程中，递归神经网络在此基础上增加了一个隐藏层到隐藏层的权重矩阵参与计算。</p><p>这3个权重矩阵分别对应文中W_hh（隐藏层到隐藏层）、W_xh（输入层到隐藏层）和W_hy（隐藏层到输出层）,下面以$ℎ_𝑡=tanh⁡(𝑊_{ℎℎ}ℎ_{𝑡−1}+𝑊_{𝑥ℎ}𝑥_𝑡)$ 来拆解整个过程</p><p>假设网络结构和参数如下</p><ol><li><strong>输入层</strong>：2个节点，表示输入特征 $x_1$ 和 $x_2$。</li><li><strong>隐藏层</strong>：2个节点，表示隐藏状态 $h_1$ 和 $h_2$​，,使用tanh激活函数。</li><li><strong>输出层</strong>：1个节点，表示输出 $y$，使用线性激活函数。</li></ol><h4 id="权重矩阵"><a href="#权重矩阵" class="headerlink" title="权重矩阵"></a>权重矩阵</h4><ol><li><p><strong>输入层到隐藏层的权重</strong>： $W_{xh} = \begin{bmatrix} W_{11} &amp; W_{12} \ W_{21} &amp; W_{22} \end{bmatrix}$</p><p>$W_{11}$、$W_{12}$​ 连接 $x_1$​ 到 $h_1$​ 和 $h_2$​，$W_{21}$、$W_{22}$​ 连接 $x_2$​ 到 $h_1$​ 和 $h_2$。</p></li><li><p><strong>隐藏层到隐藏层的权重</strong>：$W_{hh} = \begin{bmatrix} U_{11} &amp; U_{12} \ U_{21} &amp; U_{22} \end{bmatrix}$</p><ul><li>$U_{11}$和 $U_{12}$ 连接 $h_1(t-1)$到 $h_1(t)$ 和 $h_2(t)$。</li><li>$U_{21}$ 和 $U_{22}$ 连接 $h_2(t-1)$ 到 $h_1(t)$ 和 $h_2(t)$。<br>[[#5. 序列数据的处理]]</li></ul></li><li><p><strong>隐藏层到输出层的权重</strong>： $W_{hy} = \begin{bmatrix} W_{31} &amp; W_{32} \end{bmatrix}$</p><ul><li>$W_{31}$​ 和 $W_{32}$分别连接$h_1$ 和$h_2$到 $y$。</li></ul></li></ol><h3 id="前向传播过程"><a href="#前向传播过程" class="headerlink" title="前向传播过程"></a>前向传播过程</h3><p>对于每个时间步 $t$，前向传播的计算步骤如下：</p><h4 id="1-输入层到隐藏层"><a href="#1-输入层到隐藏层" class="headerlink" title="1. 输入层到隐藏层"></a>1. <strong>输入层到隐藏层</strong></h4><p>计算当前时间步的隐藏状态, 即正文中的“隐藏状态的更新”<br>$ℎ_𝑡=tanh⁡(𝑊_{ℎℎ}ℎ_{𝑡−1}+𝑊_{𝑥ℎ}𝑥_𝑡)$<br>其中，$\mathbf{x}_t$​ 是当前时间步的输入向量，$\mathbf{h}_{t-1}$是前一时间步的隐藏状态。<br>具体展开如下：</p><p>$\begin{bmatrix} h_{1t} \ h_{2t} \end{bmatrix} = \text{tanh} \left( \begin{bmatrix} W_{11} &amp; W_{12} \ W_{21} &amp; W_{22} \end{bmatrix} \begin{bmatrix} x_{1t} \ x_{2t} \end{bmatrix} + \begin{bmatrix} U_{11} &amp; U_{12} \ U_{21} &amp; U_{22} \end{bmatrix} \begin{bmatrix} h_{1(t-1)} \ h_{2(t-1)} \end{bmatrix} + \begin{bmatrix} b_1 \ b_2 \end{bmatrix} \right)$</p><p>分开计算：<br>$h_{1t} = \text{tanh}(W_{11} x_{1t} + W_{12} x_{2t} + U_{11} h_{1(t-1)} + U_{12} h_{2(t-1)} )$</p><p>$h_{2t} = \text{tanh}(W_{21} x_{1t} + W_{22} x_{2t} + U_{21} h_{1(t-1)} + U_{22} h_{2(t-1)})$</p><h4 id="2-隐藏层到输出层"><a href="#2-隐藏层到输出层" class="headerlink" title="2.  隐藏层到输出层"></a>2.  <strong>隐藏层到输出层</strong></h4><p>计算当前时间步的输出。 $y_t = W_{hy} \mathbf{h}_t$<br>具体展开如下：<br>$y_t = \begin{bmatrix} W_{31} &amp; W_{32} \end{bmatrix} \begin{bmatrix} h_{1t} \ h_{2t} \end{bmatrix}$</p><p>分开计算：</p><p>$y_t = W_{31} h_{1t} + W_{32} h_{2t}$</p><p>⚠️： tanh 是非线性激活函数</p><h2 id="4-1-of-k编码"><a href="#4-1-of-k编码" class="headerlink" title="4. 1-of-k编码"></a>4. 1-of-k编码</h2><p>1-of-k编码，也称为独热编码（One-Hot Encoding），是一种将分类数据转换为二进制向量的方法。它的目的是将非数值型的类别变量转化为适合于机器学习算法处理的数值型数据。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>假设有一个类别变量，它有 $k$ 个不同的类别。1-of-k编码将每个类别表示为一个长度为 $k$ 的二进制向量，其中只有一个位置为1，其他位置为0。</p><p>例如，考虑一个有四个类别的变量：”A”, “B”, “C”, “D”。其1-of-k编码如下：</p><div class="table-container"><table><thead><tr><th>类别</th><th>1-of-k编码</th></tr></thead><tbody><tr><td>A</td><td>[1, 0, 0, 0]</td></tr><tr><td>B</td><td>[0, 1, 0, 0]</td></tr><tr><td>C</td><td>[0, 0, 1, 0]</td></tr><tr><td>D</td><td>[0, 0, 0, 1]</td></tr></tbody></table></div><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><strong>消除排序关系</strong>：独热编码将分类变量转化为二进制向量，避免了对分类变量的误解，即认为它们之间存在排序关系。</li><li><strong>适合模型处理</strong>：许多机器学习算法（如线性回归、逻辑回归等）无法直接处理非数值型数据，1-of-k编码使这些数据适合于这些算法。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><strong>高维度问题</strong>：当类别数量较多时，编码后的向量长度会变得很长，导致高维度问题，增加计算和存储成本。</li></ul><h4 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h4><ul><li><strong>文本处理</strong>：在自然语言处理（NLP）任务中，1-of-k编码常用于将单词转化为二进制向量。</li><li><strong>分类任务</strong>：在分类任务中，用于将类别标签转化为模型可以处理的数值型数据。</li></ul><p>1-of-k编码是数据预处理中的一种重要技术，广泛应用于各种机器学习和深度学习任务中。它帮助将分类数据转化为数值数据，使得各种模型能够更好地处理这些数据。</p><h2 id="5-置信度"><a href="#5-置信度" class="headerlink" title="5. 置信度"></a>5. 置信度</h2><p>在机器学习中，置信度（confidence）是衡量模型预测结果确定性的一个指标。置信度可以理解为模型对其预测的某个结果是正确的信心程度。</p><p>在机器学习中，置信度通常以概率值的形式表示，反映了模型对某个预测的确定性。例如，在分类任务中，模型对某个样本属于某一类的置信度可能是80%，表示模型认为该样本属于该类的概率为80%。<br>具体应用：</p><ul><li><strong>分类任务</strong>：如图像分类，模型输出每个类别的概率分布。例如，对于一张图片，模型可能输出：[猫: 0.7, 狗: 0.2, 兔子: 0.1]，其中猫的置信度最高。</li><li><p><strong>置信度阈值</strong>：在某些应用中，可能会设置一个置信度阈值，只有当预测的置信度超过某个值时，才认为预测有效。</p><h4 id="置信度的计算"><a href="#置信度的计算" class="headerlink" title="置信度的计算"></a>置信度的计算</h4></li><li><p><strong>概率分布</strong>：使用Softmax函数将模型输出的logits转化为概率分布，这些概率值即为置信度。</p></li><li><strong>Softmax公式</strong>：对于第 $i$ 个输出节点，置信度 $P(y_i)$ 为： $P(y_i) = \frac{e^{z_i}}{\sum_{j} e^{z_j}}$ 其中， $z_i$ 是第 $i$ 个节点的logit。<h3 id="logits"><a href="#Logits" class="headerlink" title="Logits"></a>Logits</h3></li></ul><p>Logits 是神经网络在分类任务中的输出层的原始得分。它们是未经过归一化的数值，用于表示每个类别的相对置信度。Logits 是通过前向传播计算得到的，表示模型对每个可能的类别的初始估计。</p><h4 id="具体理解"><a href="#具体理解" class="headerlink" title="具体理解"></a>具体理解</h4><ol><li><strong>原始得分</strong>：Logits 是神经网络最后一层输出的原始分数，这些分数还没有被转换为概率。</li><li><strong>用途</strong>：在分类任务中，Logits 被用来计算每个类别的概率，这通常通过 Softmax 函数完成。</li><li><strong>Softmax 转换</strong>：Softmax 函数将 Logits 转换为概率分布，使得这些概率的和为1。公式如上</li></ol><h2 id="6-softmax"><a href="#6-Softmax" class="headerlink" title="6. Softmax"></a>6. Softmax</h2><p>[[0-神经网络（Neural Networks）#^cfe178]]</p><h1 id="7-超参数-temperature-温度"><a href="#7-超参数-Temperature-温度" class="headerlink" title="7. 超参数 Temperature 温度"></a>7. 超参数 Temperature 温度</h1><p>Temperature是在模型使用或调优过程中设定的参数，并不通过模型训练过程中的优化算法来更新，因此它属于超参数。<br>Temperature作为超参数，在神经网络中用来控制Softmax输出的概率分布平滑程度，它的作用是调节模型生成样本的多样性和确定性。</p><h4 id="temperature的公式"><a href="#Temperature的公式" class="headerlink" title="Temperature的公式"></a>Temperature的公式</h4><p>Softmax函数带有Temperature的公式如下：</p><p>$P(y_i) = \frac{e^{z_i / T}}{\sum_{j} e^{z_j / T}}$</p><p>其中，$z_i$ 是logits值，$T$ 是Temperature参数。</p><h4 id="temperature的影响"><a href="#Temperature的影响" class="headerlink" title="Temperature的影响"></a>Temperature的影响</h4><ol><li><p><strong>高Temperature（T &gt; 1）</strong>：</p><ul><li><strong>平滑分布</strong>：使概率分布更加平滑，增加生成样本的多样性。</li><li><strong>增加随机性</strong>：输出类别之间的概率差距缩小，使得选择更随机。</li></ul><p>示例：假设 logits 为 $[2.0,1.0,0.1]$，使用 $T = 2$ 时，概率可能变得更接近，如 $[0.4,0.35,0.25]$。</p></li><li><p><strong>低Temperature（0 &lt; T &lt; 1）</strong>：</p><ul><li><strong>尖锐分布</strong>：使概率分布更加尖锐，增加生成样本的确定性。</li><li><strong>减少随机性</strong>：输出类别之间的概率差距加大，使得选择更确定。</li></ul><p>示例：假设 logits 为 $[2.0,1.0,0.1]$，使用 $T = 0.5$ 时，概率可能变得更尖锐，如 $[0.7,0.25,0.05]$。</p></li><li><p><strong>Temperature等于1</strong>：</p><ul><li><strong>标准Softmax</strong>：概率分布保持原样，不做任何调整。</li></ul></li></ol><h4 id="作用及应用场景"><a href="#作用及应用场景" class="headerlink" title="作用及应用场景"></a>作用及应用场景</h4><ol><li><strong>文本生成</strong>：<ul><li>控制生成文本的多样性和创造性。在文本生成任务中，高Temperature可能生成更有创意但不一定合理的句子，而低Temperature可能生成更合理但缺乏多样性的句子。</li></ul></li><li><strong>探索与利用</strong>：<ul><li>在强化学习中，高Temperature用于探索多样性策略，低Temperature用于利用已知的最佳策略。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://karpathy.github.io/2015/05/21/rnn-effectiveness/&quot;&gt;Andrej Karpathy blog:# The Unreasonable Effectiveness of Recurrent Neu</summary>
      
    
    
    
    
    <category term="AI" scheme="http://example.com/tags/AI/"/>
    
    <category term="神经网络" scheme="http://example.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Ilya sutskever‘s 30  papers" scheme="http://example.com/tags/Ilya-sutskever%E2%80%98s-30-papers/"/>
    
  </entry>
  
  <entry>
    <title>递归神经网络（Recurrent Neural Networks, RNNs）</title>
    <link href="http://example.com/6ac941eb/"/>
    <id>http://example.com/6ac941eb/</id>
    <published>2024-06-07T14:03:29.000Z</published>
    <updated>2024-06-16T14:25:26.622Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前置概念"><a href="#前置概念" class="headerlink" title="前置概念"></a>前置概念</h1><h2 id="1-时间步time-step和序列数据sequential-data"><a href="#1-时间步（Time-Step）和序列数据（Sequential-Data）" class="headerlink" title="1. 时间步（Time Step）和序列数据（Sequential Data）"></a>1. 时间步（Time Step）和序列数据（Sequential Data）</h2><h3 id="11-序列数据sequential-data"><a href="#1-1-序列数据（Sequential-Data）" class="headerlink" title="1.1 序列数据（Sequential Data）"></a>1.1 序列数据（Sequential Data）</h3><p>序列数据（Sequential Data）是指按照时间或其他顺序排列的数据，其中每个数据点的意义和价值都依赖于它在序列中的位置和前后数据点的关系。序列数据广泛存在于许多实际应用中，如时间序列、自然语言处理、语音识别等。</p><p><strong>序列数据的特点</strong></p><ol><li><strong>时间依赖性</strong>：序列数据中的每个数据点与其前后数据点存在依赖关系。这种依赖性可以是短期的（仅依赖于最近的数据点）或长期的（依赖于较早的数据点）。</li><li><strong>顺序关系</strong>：序列数据的顺序是至关重要的，数据点的顺序关系决定了其实际意义。例如，在语音信号中，音频帧的顺序决定了最终语音的内容。</li><li><strong>动态性</strong>：序列数据往往是动态变化的，数据点的值随时间或其他顺序变化而变化。</li></ol><h3 id="12-时间步"><a href="#1-2-时间步" class="headerlink" title="1.2 时间步"></a>1.2 时间步</h3><p>时间步指的是序列数据中的每一个元素在时间维度上的位置。例如，在一个时间序列中，每个时间点上的数据称为一个时间步。在递归神经网络中，输入序列按时间步逐步处理，每个时间步的输入不仅影响当前时间步的输出，还影响后续时间步的计算。</p><h3 id="13-序列数据与时间步的实际例子"><a href="#1-3-序列数据与时间步的实际例子" class="headerlink" title="1.3  序列数据与时间步的实际例子"></a>1.3  序列数据与时间步的实际例子</h3><p>序列数据可以分为多种类型，具体包括：</p><h4 id="1-时间序列数据"><a href="#1-时间序列数据" class="headerlink" title="1. 时间序列数据"></a>1. 时间序列数据</h4><p>时间序列数据是按照时间顺序排列的数据，常用于金融市场分析、气象预报等领域。<br><strong>示例</strong>：股票价格、温度记录等。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间：    t1   t2   t3   t4   t5</span><br><span class="line">股票价格： 100  102  101  103  104</span><br></pre></td></tr></table></figure></p><h4 id="2-自然语言处理数据"><a href="#2-自然语言处理数据" class="headerlink" title="2. 自然语言处理数据"></a>2. 自然语言处理数据</h4><p>自然语言处理中的数据是按照文本中的顺序排列的单词或字符，常用于文本分类、机器翻译等任务。</p><p><strong>示例</strong>：一段文本、一句话等。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间： t1   t2    t3    t4     t5</span><br><span class="line">句子： 我   喜欢   学习   机器   学习</span><br></pre></td></tr></table></figure></p><h4 id="3-语音信号数据"><a href="#3-语音信号数据" class="headerlink" title="3. 语音信号数据"></a>3. 语音信号数据</h4><p>语音信号是连续的音频帧序列，每个音频帧表示一小段时间内的声音特征，常用于语音识别、语音合成等任务。</p><p><strong>示例</strong>：一段语音信号。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间步：  t1    t2    t3    t4    t5</span><br><span class="line">音频帧：  F1    F2    F3    F4    F5</span><br></pre></td></tr></table></figure></p><h4 id="4-视频数据"><a href="#4-视频数据" class="headerlink" title="4. 视频数据"></a>4. 视频数据</h4><p>视频数据是由一系列按时间顺序排列的图像帧组成，常用于视频分类、目标检测等任务。</p><p><strong>示例</strong>：一段视频。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间步：  t1    t2    t3    t4    t5</span><br><span class="line">视频帧：  F1    F2    F3    F4    F5</span><br></pre></td></tr></table></figure></p><h3 id="14-序列数据的实际应用场景"><a href="#1-4-序列数据的实际应用场景" class="headerlink" title="1.4 序列数据的实际应用场景"></a>1.4 序列数据的实际应用场景</h3><ol><li><p>时间序列预测：通过分析历史数据，预测未来的值。<br><strong>示例</strong>：股票价格预测、天气预报、销售量预测等。</p></li><li><p>自然语言处理：处理和理解人类语言，执行各种语言相关任务。<br><strong>示例</strong>：文本分类、情感分析、机器翻译、文本生成等。</p></li><li><p>语音识别：将语音信号转换为文本，或者识别语音中的情感、语种等信息。<br><strong>示例</strong>：语音到文本转换、语音情感识别、语音翻译等。</p></li><li><p>视频处理：处理和分析视频数据，执行各种视频相关任务。<br><strong>示例</strong>：视频分类、目标检测、行为识别等</p></li></ol><h3 id="15-序列数据的处理"><a href="#1-5-序列数据的处理" class="headerlink" title="1.5 序列数据的处理"></a>1.5 序列数据的处理</h3><p>处理序列数据时，需要考虑数据的顺序和时间依赖性。以下是一些常见的处理方法和模型：</p><h4 id="1-递归神经网络recurrent-neural-networks-rnns"><a href="#1-递归神经网络（Recurrent-Neural-Networks-RNNs）" class="headerlink" title="1. 递归神经网络（Recurrent Neural Networks, RNNs）"></a>1. 递归神经网络（Recurrent Neural Networks, RNNs）</h4><p>RNNs通过循环结构能够记住和利用序列数据中的时间依赖性，适用于处理各种序列数据。</p><p><strong>特点</strong>：</p><ul><li>能够处理变长序列数据。</li><li>能够捕捉短期和长期依赖关系。</li></ul><h4 id="2-长短期记忆网络long-short-term-memory-lstm"><a href="#2-长短期记忆网络（Long-Short-Term-Memory-LSTM）" class="headerlink" title="2. 长短期记忆网络（Long Short-Term Memory, LSTM）"></a>2. 长短期记忆网络（Long Short-Term Memory, LSTM）</h4><p>LSTM是RNN的一种变体，专门用于解决RNN中的梯度消失和梯度爆炸问题，能够更好地捕捉长序列中的依赖关系。</p><p><strong>特点</strong>：</p><ul><li>通过引入遗忘门、输入门和输出门控制信息流动。</li><li>能够记住长时间的依赖关系。</li></ul><h4 id="3-门控循环单元gated-recurrent-unit-gru"><a href="#3-门控循环单元（Gated-Recurrent-Unit-GRU）" class="headerlink" title="3. 门控循环单元（Gated Recurrent Unit, GRU）"></a>3. 门控循环单元（Gated Recurrent Unit, GRU）</h4><p>GRU是LSTM的简化版本，具有类似的门控机制，但参数更少，计算效率更高。</p><p><strong>特点</strong>：</p><ul><li>通过更新门和重置门控制信息流动。</li><li>计算效率更高，适合处理长序列数据。</li></ul><h4 id="4-transformer模型"><a href="#4-Transformer模型" class="headerlink" title="4. Transformer模型"></a>4. Transformer模型</h4><p>Transformer模型通过自注意力机制（Self-Attention）处理序列数据，能够并行处理序列中的每个位置，解决了传统RNN的计算瓶颈问题。</p><p><strong>特点</strong>：</p><ul><li>通过注意力机制捕捉序列中任意位置之间的依赖关系。</li><li>计算效率高，适合处理长序列数据。</li></ul><h1 id="2-什么是rnn"><a href="#2-什么是RNN" class="headerlink" title="2. 什么是RNN"></a>2. 什么是RNN</h1><p>递归神经网络（Recurrent Neural Networks, RNNs）是一类专门用于处理序列数据的神经网络模型。RNNs通过循环结构使得网络能够捕捉和记忆输入数据中的时间依赖性，适用于各种序列数据处理任务，如时间序列预测、自然语言处理、语音识别等。</p><p>如果你已经对<a href="obsidian://open?vault=Documents&amp;file=second-brain%2F0-projects%2Filya%2027%E4%BE%BF%E8%AE%BA%E6%96%87%E8%A7%A3%E8%AF%BB%2F0-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88Neural%20Networks%EF%BC%89">基础神经网络的层次结构和前向传播过程</a>了解了， 那么RNN 与它的区别就是其隐藏层具有循环连接，使得当前时间步的隐藏状态不仅依赖于当前输入，还依赖于前一时间步的隐藏状态。</p><p>下面在 基础神经网络中的层次结构的基础上说明 RNN</p><h2 id="网络结构和参数"><a href="#网络结构和参数" class="headerlink" title="网络结构和参数"></a>网络结构和参数</h2><ol><li><strong>输入层</strong>：2个节点，表示输入特征 $x_1$ 和 $x_2​$。</li><li><strong>隐藏层</strong>：2个节点，表示隐藏状态 $h_1$ 和 $h_2$​，偏置向量分别为$b_1$、$b_2$,使用ReLU激活函数。</li><li><strong>输出层</strong>：1个节点，表示输出 $y$，偏置向量分别为$b_3$,使用线性激活函数。</li><li><p><strong>权重矩阵</strong></p><ol><li><strong>输入层到隐藏层的权重</strong>： $W_{xh} = \begin{bmatrix} W_{11} &amp; W_{12} \ W_{21} &amp; W_{22} \end{bmatrix}$</li></ol><p>$W_{11}​$、$W_{12}$​ 连接 $x_1$​ 到 $h_1$​ 和 $h_2$​，$W_{21}​$、$W_{22}$​ 连接 $x_2$​ 到 $h_1$​ 和 $h_2​$。</p><ol><li><p><strong>隐藏层到隐藏层的权重</strong>：$W_{hh} = \begin{bmatrix} U_{11} &amp; U_{12} \ U_{21} &amp; U_{22} \end{bmatrix}$</p><ul><li>$U_{11}​$和 $U_{12}​$ 连接 $h_1(t-1)$到 $h_1(t)$ 和 $h_2(t)$。</li><li>$U_{21}​$ 和 $U_{22}$ 连接 $h_2(t-1)$ 到 $h_1(t)$ 和 $h_2(t)$。</li></ul></li><li><strong>隐藏层到输出层的权重</strong>： $W_{hy} = \begin{bmatrix} W_{31} &amp; W_{32} \end{bmatrix}$<ul><li>$W_{31}$​ 和 $W_{32}$分别连接$h_1$ 和$h_2​$到 $y$。</li></ul></li></ol></li><li><p>偏置向量</p><ul><li><strong>隐藏层的偏置</strong>：$\mathbf{b}_h = \begin{bmatrix} b_1 \ b_2 \end{bmatrix}$</li><li><strong>输出层的偏置</strong>：$b_3$<h2 id="前向传播过程"><a href="#前向传播过程" class="headerlink" title="前向传播过程"></a>前向传播过程</h2></li></ul></li></ol><p>对于每个时间步 $t$，前向传播的计算步骤如下：</p><ol><li><strong>输入层到隐藏层</strong>：计算当前时间步的隐藏状态。$\mathbf{h}_t = \text{ReLU}(W_{xh} \mathbf{x}_t + W_{hh} \mathbf{h}_{t-1} + \mathbf{b}_h)$ 其中，$\mathbf{x}_t$​ 是当前时间步的输入向量，$\mathbf{h}_{t-1}​$是前一时间步的隐藏状态。<br>具体展开如下：</li></ol><p>$\begin{bmatrix} h_{1t} \ h_{2t} \end{bmatrix} = \text{ReLU} \left( \begin{bmatrix} W_{11} &amp; W_{12} \ W_{21} &amp; W_{22} \end{bmatrix} \begin{bmatrix} x_{1t} \ x_{2t} \end{bmatrix} + \begin{bmatrix} U_{11} &amp; U_{12} \ U_{21} &amp; U_{22} \end{bmatrix} \begin{bmatrix} h_{1(t-1)} \ h_{2(t-1)} \end{bmatrix} + \begin{bmatrix} b_1 \ b_2 \end{bmatrix} \right)$</p><p>分开计算：</p><p>$h_{1t} = \text{ReLU}(W_{11} x_{1t} + W_{12} x_{2t} + U_{11} h_{1(t-1)} + U_{12} h_{2(t-1)} + b_1)$</p><p>$h_{2t} = \text{ReLU}(W_{21} x_{1t} + W_{22} x_{2t} + U_{21} h_{1(t-1)} + U_{22} h_{2(t-1)} + b_2)$</p><ol><li><strong>隐藏层到输出层</strong>：计算当前时间步的输出。 $y_t = W_{hy} \mathbf{h}_t + b_3$<br>具体展开如下：</li></ol><p>$y_t = \begin{bmatrix} W_{31} &amp; W_{32} \end{bmatrix} \begin{bmatrix} h_{1t} \ h_{2t} \end{bmatrix} + b_3$</p><p>分开计算：</p><p>$y_t = W_{31} h_{1t} + W_{32} h_{2t} + b_3$</p><h3 id="dropout在rnn中的表现"><a href="#Dropout在RNN中的表现" class="headerlink" title="Dropout在RNN中的表现"></a>Dropout在RNN中的表现</h3><p>在传统的前馈神经网络中，Dropout被证明是非常有效的正则化方法。然而，直接将这种方法应用于RNN时，会破坏时间步之间的依赖关系，导致模型性能下降。</p><p>在RNN中，Dropout的效果确实没有在前馈神经网络中那么明显，原因如下：</p><ol><li><strong>时间步之间的依赖性</strong>：RNN中的隐藏层具有时间步之间的依赖关系，即当前时间步的隐藏状态依赖于前一时间步的隐藏状态。传统的Dropout方法在RNN中会破坏这种时间步之间的依赖关系，从而影响模型的学习效果。</li><li><strong>梯度传播的影响</strong>：RNN通过反向传播通过时间（Backpropagation Through Time, BPTT）来更新权重，Dropout会在时间步之间引入不稳定性，可能导致梯度传播过程中的问题，如梯度消失或梯度爆炸。</li></ol><h1 id="3-rnn中的梯度消失和梯度爆炸"><a href="#3-RNN中的梯度消失和梯度爆炸" class="headerlink" title="3. RNN中的梯度消失和梯度爆炸"></a>3. RNN中的梯度消失和梯度爆炸</h1><p>在训练循环神经网络（RNN）时，常常会遇到梯度消失和梯度爆炸问题，这两者都是由RNN的反向传播算法（BPTT, Backpropagation Through Time）引起的。</p><h4 id="1-梯度消失vanishing-gradient"><a href="#1-梯度消失（Vanishing-Gradient）" class="headerlink" title="1. 梯度消失（Vanishing Gradient）"></a>1. 梯度消失（Vanishing Gradient）</h4><p><strong>现象</strong>：</p><ul><li>当梯度在反向传播过程中逐层传递时，它的数值会逐渐变小，最终趋近于零。</li><li>这导致前面层的权重更新几乎停止，使网络难以训练。</li></ul><p><strong>原因</strong>：</p><ul><li>在反向传播过程中，梯度是通过链式法则逐层相乘的。如果某些层的梯度小于1（例如小于1的激活函数导数），则乘积会快速缩小。</li><li>常见的激活函数如tanh和sigmoid在输入值较大或较小时，其导数接近零，从而加剧了梯度消失问题。</li></ul><h4 id="2-梯度爆炸exploding-gradient"><a href="#2-梯度爆炸（Exploding-Gradient）" class="headerlink" title="2. 梯度爆炸（Exploding Gradient）"></a>2. 梯度爆炸（Exploding Gradient）</h4><p><strong>现象</strong>：</p><ul><li>当梯度在反向传播过程中逐层传递时，它的数值会逐渐变大，最终变得非常大。</li><li>这导致前面层的权重更新过大，使网络参数变得不稳定，甚至导致溢出。</li></ul><p><strong>原因</strong>：</p><ul><li>在反向传播过程中，如果某些层的梯度大于1（例如大于1的激活函数导数），则乘积会快速增大。</li><li>常见的原因包括不合理的初始化权重和未处理的数值不稳定问题。</li></ul><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><ol><li><strong>梯度裁剪（Gradient Clipping）</strong>：<ul><li>当梯度的范数超过某个阈值时，将其缩放到该阈值。</li><li>这可以有效防止梯度爆炸。</li></ul></li><li><strong>长短期记忆网络（LSTM）和门控循环单元（GRU）</strong>：<ul><li>这些是专门设计用于缓解梯度消失和梯度爆炸问题的RNN变种。</li><li>通过引入门机制，它们能够更好地保持长时间依赖。</li></ul></li><li><strong>适当的权重初始化</strong>：<ul><li>使用如Xavier初始化或He初始化来设置初始权重，可以减少梯度消失和爆炸的风险。</li></ul></li><li><strong>使用不同的激活函数</strong>：<ul><li>ReLU等激活函数在一定程度上可以缓解梯度消失问题。</li></ul></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前置概念&quot;&gt;&lt;a href=&quot;#前置概念&quot; class=&quot;headerlink&quot; title=&quot;前置概念&quot;&gt;&lt;/a&gt;前置概念&lt;/h1&gt;&lt;h2 id=&quot;1-时间步time-step和序列数据sequential-data&quot;&gt;&lt;a href=&quot;#1-时间步（Time-</summary>
      
    
    
    
    
    <category term="AI" scheme="http://example.com/tags/AI/"/>
    
    <category term="神经网络" scheme="http://example.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Ilya sutskever‘s 30  papers" scheme="http://example.com/tags/Ilya-sutskever%E2%80%98s-30-papers/"/>
    
  </entry>
  
  <entry>
    <title>神经网络（Neural Networks）</title>
    <link href="http://example.com/f27811be/"/>
    <id>http://example.com/f27811be/</id>
    <published>2024-06-07T09:16:16.000Z</published>
    <updated>2024-07-11T08:40:25.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-什么是神经网络-neural-networks"><a href="#0-什么是神经网络-Neural-Networks" class="headerlink" title="0. 什么是神经网络 (Neural Networks)"></a>0. 什么是神经网络 (Neural Networks)</h1><p>神经网络是实现AI 的一种技术手段，一种广泛用于机器学习（Machine Learning）和深度学习（Deep Learning）领域的计算模型/算法架构。</p><p>它受到人类大脑神经元（Neurons）和它们的互动方式的启发，它由多个层（Layers）组成，每层包含多个神经元，这些神经元通过权重（Weights）连接传递信息。</p><p>神经网络的训练过程基于机器学习的基本前提，即能够从数据中学习。通过向网络提供大量的数据样本（包括输入和期望的输出），神经网络可以学习到如何映射输入到输出，这种能力是通过调整内部结构（即权重）来实现的。</p><p>这一学习过程使用了机器学习中的核心概念，如损失函数（Loss Functions）、梯度下降（Gradient Descent）和反向传播算法（Backpropagation Algorithms）。这些都是机器学习领域的基本工具，用于训练模型以改进其性能。</p><h1 id="1-神经网络的层次结构"><a href="#1-神经网络的层次结构" class="headerlink" title="1. 神经网络的层次结构"></a>1. 神经网络的层次结构</h1><h2 id="11-节点nodes或神经元neurons"><a href="#1-1-节点（Nodes）或神经元（Neurons）" class="headerlink" title="1.1  节点（Nodes）或神经元（Neurons）"></a>1.1  节点（Nodes）或神经元（Neurons）</h2><p>节点是神经网络的基本单位，也称为神经元。每个节点接收输入信号，进行加权求和和非线性变换，然后将结果传递给下一层的节点。节点的主要功能包括：</p><ol><li><strong>接收输入</strong>：从前一层的所有节点接收输入信号。</li><li><strong>加权求和</strong>：对接收到的输入信号乘以相应的权重并求和。</li><li><strong>应用激活函数</strong>：对加权求和的结果应用激活函数，生成节点的输出。</li><li><strong>传递输出</strong>：将输出信号传递给下一层的节点。</li></ol><h2 id="12-层layers"><a href="#1-2-层（Layers）" class="headerlink" title="1.2  层（Layers）"></a>1.2  层（Layers）</h2><p>层是由多个节点组成的一个集合，在神经网络中起着分层处理输入数据的作用。每一层中的节点执行相同类型的计算，但每个节点有各自的权重和偏置。</p><p>一个典型的神经网络由以下几个部分组成：</p><ul><li><strong>输入层（Input Layer）</strong>：接收外部输入数据，每个节点代表一个输入特征。</li><li><strong>隐藏层（Hidden Layers）</strong>：位于输入层和输出层之间，用于特征提取和数据变换。一个神经网络可以有一个或多个隐藏层。</li><li><strong>输出层（Output Layer）</strong>：生成最终的预测结果，每个节点代表一个输出。</li></ul><h2 id="13-节点和层的关系"><a href="#1-3-节点和层的关系" class="headerlink" title="1.3  节点和层的关系"></a>1.3  节点和层的关系</h2><p>节点和层之间的关系可以概括如下：</p><ol><li><strong>层是节点的集合</strong>：每一层由多个节点组成，这些节点在同一层内进行相同类型的计算。</li><li><strong>数据传递和处理</strong>：数据在神经网络中逐层传递，每一层的节点接收前一层的输出，进行计算后将结果传递给下一层的节点。</li><li><strong>层次结构</strong>：神经网络的层次结构决定了数据处理的顺序和方式。输入数据经过输入层后，依次通过一个或多个隐藏层进行复杂的特征提取，最终通过输出层生成预测结果。</li></ol><h2 id="14-层与层之间的连接"><a href="#1-4-层与层之间的连接" class="headerlink" title="1.4 层与层之间的连接"></a>1.4 层与层之间的连接</h2><p>层与层之间的连接由权重矩阵决定。每一层的节点与下一层的每个节点相连，连接的强度由权重值决定。在前向传播过程中，输入层的节点将输入数据传递给第一个隐藏层的节点，后者再将处理后的数据传递给下一个隐藏层，依此类推，直到输出层。</p><h1 id="2-权重"><a href="#2-权重" class="headerlink" title="2. 权重"></a>2. 权重</h1><p>权重是连接神经网络中不同层节点的参数，用于调节输入信号在网络中的传递和变换强度。每个连接都有一个权重，表示输入信号对输出信号的影响力。</p><ul><li><strong>调节信号强度</strong>：权重乘以输入信号后，再通过求和和激活函数的变换，决定了输出信号的值。不同的权重值代表输入信号的重要程度。</li><li><strong>特征学习</strong>：通过学习和调整权重，神经网络能够识别和提取输入数据中的重要特征。</li><li><strong>优化</strong>：在训练过程中，权重被调整以最小化预测误差。通过反向传播算法，权重的值不断更新，使得模型的预测更加准确。</li></ul><h2 id="21-权重的存在形式"><a href="#2-1-权重的存在形式" class="headerlink" title="2.1 权重的存在形式"></a>2.1 权重的存在形式</h2><p>权重并不存在于单独的节点内，而是存在于节点之间的连接上。具体来说，每一层的节点与下一层的节点之间的连接由一组权重参数表示。权重矩阵表示了两个层之间所有节点连接的权重值。</p><h2 id="22-权重的初始化和调整"><a href="#2-2-权重的初始化和调整" class="headerlink" title="2.2 权重的初始化和调整"></a>2.2 权重的初始化和调整</h2><p>权重的初始化方法有多种，包括零初始化、随机初始化、Xavier初始化和He初始化等。这些方法旨在为模型提供一个良好的起点，以便更好地进行训练。</p><h2 id="23-权重的训练调整"><a href="#2-3-权重的训练调整" class="headerlink" title="2.3 权重的训练调整"></a>2.3 权重的训练调整</h2><p>在训练过程中，权重通过优化算法进行调整。最常用的优化算法是梯度下降（Gradient Descent）及其变种（如随机梯度下降、Adam优化算法等）。训练步骤如下：</p><ol><li><strong>前向传播</strong>：计算网络的预测输出。</li><li><strong>计算损失</strong>：通过损失函数衡量预测输出与真实标签之间的差距。</li><li><strong>反向传播</strong>：计算损失函数对每个权重的梯度。</li><li><strong>更新权重</strong>：使用梯度下降法更新权重，以最小化损失函数。</li></ol><h2 id="24-优化算法"><a href="#2-4-优化算法" class="headerlink" title="2.4 优化算法"></a>2.4 优化算法</h2><p>为了提高训练效率和稳定性，可以使用各种优化算法，包括：</p><ul><li><strong>动量（Momentum）</strong>：结合当前梯度和之前更新的方向，加速收敛。</li><li><strong>AdaGrad</strong>：根据过去的梯度调整学习率，适应性地进行参数更新。</li><li><strong>RMSProp</strong>：改进AdaGrad，使用指数加权平均计算梯度平方和，避免学习率过快减小。</li><li><strong>Adam</strong>：结合动量和RMSProp的优点，适应性地调整学习率和动量，广泛应用于各种神经网络训练。</li></ul><h2 id="25-权重在不同类型神经网络中的角色"><a href="#2-5-权重在不同类型神经网络中的角色" class="headerlink" title="2.5 权重在不同类型神经网络中的角色"></a>2.5 权重在不同类型神经网络中的角色</h2><p>不同类型的神经网络中，权重的具体作用可能有所不同：</p><ul><li><strong>前馈神经网络（Feedforward Neural Networks, FNNs）</strong>：权重连接每一层的所有节点，负责将输入数据逐层传递和变换。</li><li><strong>卷积神经网络（Convolutional Neural Networks, CNNs）</strong>：权重是卷积核的参数，负责在局部感知野上提取特征。</li><li><strong>递归神经网络（Recurrent Neural Networks, RNNs）</strong>：权重用于处理序列数据，包括当前时间步的输入与前一时间步的隐藏状态之间的关系。</li></ul><h1 id="3-偏置biases"><a href="#3-偏置（Biases）" class="headerlink" title="3. 偏置（Biases）"></a>3. 偏置（Biases）</h1><p>偏置是每个节点附加的一个参数，用于调整节点的输出独立于输入信号。偏置帮助神经网络学到更灵活的决策边界。</p><p><strong>作用</strong></p><ul><li><strong>调节输出</strong>：偏置提供一个额外的自由度，使得神经网络能够更好地拟合数据。</li><li><strong>避免零输出</strong>：在输入信号为零的情况下，偏置确保节点仍然能够产生非零输出。</li></ul><h1 id="4-激活函数activation-function"><a href="#4-激活函数（Activation-Function）" class="headerlink" title="4. 激活函数（Activation Function）"></a>4. 激活函数（Activation Function）</h1><p>激活函数（Activation Function）是神经网络中的一个关键组件，它引入了非线性变换，使得神经网络能够学习和表示复杂的非线性关系。如果没有激活函数，神经网络的每一层只进行线性变换，那么无论多少层的堆叠，整体仍然是一个线性变换。这将极大限制神经网络的表示能力。因此，激活函数对于神经网络的性能和能力至关重要。</p><p>线性（Linear）和非线性（Nonlinear）是数学和信号处理中两个基本的概念，这些概念在神经网络和机器学习中也具有重要意义。理解这两个概念有助于掌握为什么激活函数对神经网络的性能如此重要。</p><h2 id="41-线性linearvs-非线性nonlinear"><a href="#4-1-线性（Linear）vs-非线性（Nonlinear）" class="headerlink" title="4.1 线性（Linear）vs  非线性（Nonlinear）"></a>4.1 线性（Linear）vs  非线性（Nonlinear）</h2><h3 id="411-线性linear"><a href="#4-1-1-线性（Linear）" class="headerlink" title="4.1.1 线性（Linear）"></a>4.1.1 线性（Linear）</h3><p>线性关系是指两个变量之间的关系可以用一个线性方程表示。对于一个变量 $x$ 和其对应的输出 $y$，线性关系可以表示为：<br>$y = mx + b$<br>其中，$m$ 是斜率，$b$ 是截距。这意味着如果我们绘制 $y$ 对 $x$ 的图像，它将是一条直线。</p><p><strong>特点</strong></p><ul><li><strong>叠加性</strong>：线性系统满足叠加原理，即输入的线性组合会产生输出的线性组合。如果 $f(x_1) = y_1$​ 和$f(x_2) = y_2$，那么对于任何常数 $a$和 $b$，有 $f(ax_1 + bx_2) = ay_1 + by_2$​。</li><li><strong>同质性</strong>：线性系统满足同质性，即输入的放大会导致输出的相应放大。如果 $f(x) = y$，那么对于任何常数 $k$，有 $f(kx) = ky$。</li></ul><p><strong>在神经网络中的应用</strong><br>在神经网络中，线性变换通常通过矩阵乘法和加法实现，例如输入与权重矩阵的乘积加上偏置：<br>$z = W \cdot x + b$</p><h3 id="412-非线性nonlinear"><a href="#4-1-2-非线性（Nonlinear）" class="headerlink" title="4.1.2 非线性（Nonlinear）"></a>4.1.2 非线性（Nonlinear）</h3><p>非线性关系是指两个变量之间的关系不能用一个简单的线性方程表示。非线性关系的数学表示形式可以非常多样，常见的形式包括多项式、指数函数、对数函数、三角函数等。<br>例如，对于变量 $x$ 和 $y$，非线性关系可以表示为：<br>$y=ax^2+bx+c$<br>其中，$a$、$b$、$c$ 是常数。这意味着如果我们绘制 $y$ 对 $x$ 的图像，它将不是一条直线，而是一个曲线。<br><strong>特点</strong></p><ul><li><strong>非叠加性</strong>：非线性系统不满足叠加原理。如果 $f(x_1) = y_1​$ 和 $f(x_2) = y_2​$，那么 $f(ax_1 + bx_2) \neq ay_1 + by_2$​。</li><li><strong>复杂性</strong>：非线性系统可以表示复杂的关系和模式，能够捕捉到数据中的复杂结构和动态。</li></ul><p><strong>为什么需要非线性</strong><br>如果神经网络只使用线性激活函数（例如，恒等函数 f(z)=z），那么无论网络有多少层，其最终输出仍然是输入的线性变换。也就是说，整个网络等效于一个单层的线性模型，无法捕捉数据中的复杂关系。因此，引入非线性激活函数使得网络具有更强的表达能力，能够学习和表示复杂的非线性关系，从而解决更复杂的问题。</p><h2 id="42-常见的非线性激活函数"><a href="#4-2-常见的非线性激活函数" class="headerlink" title="4.2 常见的非线性激活函数"></a>4.2 常见的非线性激活函数</h2><h4 id="421-sigmoid-函数"><a href="#4-2-1-Sigmoid-函数" class="headerlink" title="4.2.1 Sigmoid 函数"></a>4.2.1 Sigmoid 函数</h4><p>$σ(z)=\frac{1}{1+e^{−z}} ​$</p><p><strong>特点</strong>：</p><ul><li>输出值在0到1之间，适用于概率预测。</li><li>在极值区间梯度较小，可能导致梯度消失问题。</li><li>计算复杂度较高。</li></ul><p><strong>应用</strong>：</p><ul><li>常用于二分类问题的输出层。</li></ul><h4 id="422-tanh双曲正切函数"><a href="#4-2-2-Tanh（双曲正切）函数" class="headerlink" title="4.2.2 Tanh（双曲正切）函数"></a>4.2.2 Tanh（双曲正切）函数</h4><p>$tanh(z)=\frac{e^z-e^{-z}}{e^z+e^{-z}}$<br>​<br><strong>特点</strong>：</p><ul><li>输出值在-1到1之间。</li><li>相对于Sigmoid函数，Tanh函数的输出均值为0，使得数据更中心化。</li><li>也存在梯度消失问题，但在0附近的梯度较大，梯度消失问题稍好于Sigmoid。</li></ul><p><strong>应用</strong>：</p><ul><li>常用于隐藏层。<h3 id="423-relurectified-linear-unit函数"><a href="#4-2-3-ReLU（Rectified-Linear-Unit）函数" class="headerlink" title="4.2.3 ReLU（Rectified Linear Unit）函数"></a>4.2.3 ReLU（Rectified Linear Unit）函数</h3>$ReLU(z)=max(0,z)$</li></ul><p><strong>特点</strong>：</p><ul><li>计算简单，收敛速度快。</li><li>在正区间保持线性关系，在负区间输出为0。</li><li>解决了Sigmoid和Tanh的梯度消失问题。</li><li>可能导致部分神经元“死亡”，即在训练过程中某些神经元的输出始终为0，不再更新。</li></ul><p><strong>应用</strong>：</p><ul><li>广泛用于隐藏层。<h4 id="424-leaky-relu-函数"><a href="#4-2-4-Leaky-ReLU-函数" class="headerlink" title="4.2.4 Leaky ReLU 函数"></a>4.2.4 Leaky ReLU 函数</h4>$Leaky  ReLU(z)=max(αz,z)$</li></ul><p><strong>特点</strong>：</p><ul><li>解决了ReLU的“死亡神经元”问题。</li><li>在负区间给定一个很小的斜率（通常为0.01）。</li></ul><p><strong>应用</strong>：</p><ul><li>替代ReLU，在隐藏层中使用<h4 id="425-softmax-函数"><a href="#4-2-5-Softmax-函数" class="headerlink" title="4.2.5 Softmax 函数"></a>4.2.5 Softmax 函数</h4>$Softmax(z_i​)=\frac{e^z_i}{∑_j​​e^z_j} ​$</li></ul><p><strong>特点</strong>：</p><ul><li>将输出值转换为概率分布，总和为1。</li><li>适用于多分类问题。</li></ul><p><strong>应用</strong>：</p><ul><li>常用于多分类问题的输出层。<h4 id="426-swish-函数"><a href="#4-2-6-Swish-函数" class="headerlink" title="4.2.6 Swish 函数"></a>4.2.6 Swish 函数</h4>$Swish(z)=z⋅σ(z)=\frac{z}{1+e^{−z}} ​​$</li></ul><p><strong>特点</strong>：</p><ul><li>平滑的非线性函数，性能优于ReLU和Sigmoid。</li><li>由Google提出，结合了ReLU和Sigmoid的特点。</li></ul><p><strong>应用</strong>：</p><ul><li>新型激活函数，在一些深度学习模型中表现出色。</li></ul><h2 id="43-激活函数的选择"><a href="#4-3-激活函数的选择" class="headerlink" title="4.3 激活函数的选择"></a>4.3 激活函数的选择</h2><p>激活函数的选择对于神经网络的训练和性能有重要影响。以下是一些常见的选择准则：</p><ol><li><strong>隐藏层</strong>：通常使用ReLU或其变种（如Leaky ReLU、Swish），因为它们计算简单且能有效缓解梯度消失问题。</li><li><strong>输出层</strong>：<ul><li><strong>回归问题</strong>：使用线性激活函数。</li><li><strong>二分类问题</strong>：使用Sigmoid函数。</li><li><strong>多分类问题</strong>：使用Softmax函数</li></ul></li></ol><h2 id="5训练过程"><a href="#5-训练过程" class="headerlink" title="5.训练过程"></a>5.训练过程</h2><p>假设我们有一个简单的神经网络，包含一个输入层、一个隐藏层和一个输出层：</p><ol><li>输入层**：2个节点，表示输入特征 $x_1$ 和 $x_2​$。</li><li><strong>隐藏层</strong>：2个节点，表示隐藏状态 $h_1$ 和 $h_2$​，偏置向量分别为$b_1$、$b_2$,使用ReLU激活函数。</li><li><strong>输出层</strong>：1个节点，表示输出 $y$，偏置向量分别为$b_3$,使用线性激活函数。</li></ol><p><strong>权重矩阵</strong></p><ol><li><p><strong>输入层到隐藏层的权重</strong>：假设权重为 $W^{(1)} = \begin{bmatrix} W_{11} &amp; W_{12} \ W_{21} &amp; W_{22} \end{bmatrix}$,其中 $W_{11}​$、$W_{12}$​ 连接 $x_1$​ 到 $h_1$​ 和 $h_2$​，$W_{21}​$、$W_{22}$​ 连接 $x_2$​ 到 $h_1$​ 和 $h_2​$。</p></li><li><p><strong>隐藏层到输出层的权重</strong>：假设权重为 $W^{(2)} = \begin{bmatrix} W_{31} &amp; W_{32} \end{bmatrix}$</p><ul><li>$W_{31}$​ 和 $W_{32}$分别连接$h_1$ 和$h_2​$到 $y$。其中 $W_{31}$、$W_{32}$分别连接 $h_1$和 $h_2$到 $y$</li></ul></li></ol><p>如果指定具体数据，可以设置为</p><ul><li>输入数据为$\mathbf{X} = [0.5, 0.6]$</li><li><p>隐藏层权重矩阵 $\mathbf{W}^{(1)} = \begin{bmatrix} 0.1 &amp; 0.2 \ 0.3 &amp; 0.4 \end{bmatrix}$</p></li><li><p>隐藏层偏置向量 $\mathbf{b}^{(1)} = \begin{bmatrix} 0.1 \ 0.2 \end{bmatrix}$</p></li><li><p>输出层权重矩阵 $\mathbf{W}^{(2)} = \begin{bmatrix} 0.5 &amp; 0.6 \end{bmatrix}$</p></li><li>输出层偏置向量$\mathbf{b}^{(2)} = \begin{bmatrix} 0.3 \end{bmatrix}$</li></ul><p>在训练过程中，通过调整权重和偏置，使得模型的预测结果尽可能准确。以下的主要步骤.</p><h3 id="51-前向传播forward-propagation"><a href="#5-1-前向传播（Forward-Propagation）" class="headerlink" title="5.1 前向传播（Forward Propagation）"></a>5.1 前向传播（Forward Propagation）</h3><p>前向传播是数据从输入层经过隐藏层传递到输出层的过程。在这个过程中，每一层的节点接收前一层的输出，进行加权求和，并通过激活函数生成输出。<br>具体步骤如下：</p><ul><li><strong>加权求和</strong>：每个节点接收前一层所有节点的输出，计算加权和。 $z_i = \sum_{j} w_{ij} x_j + b_i$​ 其中，$z_i$ 是第 $i$ 个节点的加权和，$w_{ij}$ 是从第 $j$ 个输入到第 $i$ 个节点的权重，$x_j$是第 $j$ 个输入，$b_i$​ 是偏置。</li><li><strong>激活函数</strong>：对加权和应用激活函数，生成节点的输出。 $a_i = f(z_i)$常用的激活函数包括Sigmoid、Tanh和ReLU。<h4 id="511-输入层"><a href="#5-1-1-输入层" class="headerlink" title="5.1.1 输入层"></a>5.1.1 输入层</h4>输入层接收外部数据，将其传递给第一个隐藏层。假设输入数据为 $\mathbf{X} = [x_1, x_2]$<h4 id="512-隐藏层"><a href="#5-1-2-隐藏层" class="headerlink" title="5.1.2 隐藏层"></a>5.1.2 隐藏层</h4></li></ul><ol><li><p>计算隐藏层的输入加权和：<br>$z_1^{(1)} = w_{11}x_1 + w_{12}x_2 + b_1$</p><p>$z_2^{(1)} = w_{21}x_1 + w_{22}x_2 + b_2$</p><p>代入具体数据：$z^{(1)} = \mathbf{W}^{(1)} \mathbf{X} + \mathbf{b}^{(1)} = \begin{bmatrix} 0.1 &amp; 0.2 \ 0.3 &amp; 0.4 \end{bmatrix} \begin{bmatrix} 0.5 \ 0.6 \end{bmatrix} + \begin{bmatrix} 0.1 \ 0.2 \end{bmatrix} = \begin{bmatrix} 0.1 \cdot 0.5 + 0.2 \cdot 0.6 + 0.1 \ 0.3 \cdot 0.5 + 0.4 \cdot 0.6 + 0.2 \end{bmatrix} = \begin{bmatrix} 0.27 \ 0.62 \end{bmatrix}$</p></li><li><p>应用激活函数，计算隐藏层的输出：<br>$h_1 = \text{ReLU}(z_1^{(1)})$</p><p>$h_2 = \text{ReLU}(z_2^{(1)})$</p></li></ol><pre><code>$h^&#123;(1)&#125; = \text&#123;ReLU&#125;(z^&#123;(1)&#125;) = \begin&#123;bmatrix&#125; \max(0, 0.27) \\ \max(0, 0.62) \end&#123;bmatrix&#125; = \begin&#123;bmatrix&#125; 0.27 \\ 0.62 \end&#123;bmatrix&#125;$</code></pre><h4 id="513-输出层"><a href="#5-1-3-输出层" class="headerlink" title="5.1.3 输出层"></a>5.1.3 输出层</h4><ol><li>计算输出层的输入加权和：<br>$z^{(2)} = w_{31}h_1 + w_{32}h_2 + b_3$<br>$z^{(2)} = \mathbf{W}^{(2)} a^{(1)} + \mathbf{b}^{(2)} = \begin{bmatrix} 0.5 &amp; 0.6 \end{bmatrix} \begin{bmatrix} 0.27 \ 0.62 \end{bmatrix} + \begin{bmatrix} 0.3 \end{bmatrix} = 0.5 \cdot 0.27 + 0.6 \cdot 0.62 + 0.3 = 0.735$</li><li>应用激活函数，计算最终输出：<br>$y = z^{(2)}$<br>假设输出层使用线性激活函数（即不做非线性变换）<br>$y = z^{(2)} = 0.735$</li></ol><h3 id="52-计算损失loss-calculation"><a href="#5-2-计算损失（Loss-Calculation）" class="headerlink" title="5.2 计算损失（Loss Calculation）"></a>5.2 计算损失（Loss Calculation）</h3><p>使用损失函数计算预测输出与真实标签之间的差异。损失函数是一个衡量模型预测误差的指标，常见的损失函数包括均方误差（MSE）和交叉熵损失。</p><ul><li><p><strong>均方误差（MSE, Mean Squared Error）</strong>：用于回归问题。 $\text{MSE} = \frac{1}{N} \sum_{i=1}^N (y_i - \hat{y}_i)^2$</p></li><li><p><strong>交叉熵损失（Cross-Entropy Loss）</strong>：用于分类问题。 $\text{Cross-Entropy} = -\sum_{i=1}^N y_i \log(\hat{y}_i)$</p></li></ul><h3 id="53-反向传播backpropagation"><a href="#5-3-反向传播（Backpropagation）" class="headerlink" title="5.3 反向传播（Backpropagation）"></a>5.3 反向传播（Backpropagation）</h3><p>反向传播算法通过计算损失函数对每个模型参数（权重和偏置）的偏导数/梯度，来指导参数更新，使得损失函数逐步减小，从而提高模型的准确性。</p><ul><li><strong>计算梯度</strong>：首先计算输出层节点的损失梯度，即损失函数对输出层每个节点输出的偏导数。然后通过链式法则，依次计算每个隐藏层节点的梯度。梯度由后一层节点的梯度和当前层节点的输出值共同决定。</li><li><strong>传播误差</strong>：误差从输出层逐层传播回输入层，计算每个参数的梯度。</li></ul><p>∂ 是偏导数符号</p><h4 id="531-偏导数和梯度"><a href="#5-3-1-偏导数和梯度" class="headerlink" title="5.3.1 偏导数和梯度"></a>5.3.1 偏导数和梯度</h4><p>偏导数表示在固定其他变量的情况下，一个变量的变化率。假设 $f(x, y)$ 是一个关于 $x$ 和 $y$的函数，则 $f$ 对 $x$ 的偏导数记作 $\frac{\partial f}{\partial x}$。</p><p>在神经网络中，偏导数用于计算梯度，帮助反向传播算法更新权重。梯度是损失函数关于每个参数的导数，表示损失函数变化率。对于一个权重 $w$，梯度 $\frac{\partial L}{\partial w}$ 表示权重变化对损失函数 $L$ 的影响。<br>具体而言，梯度表示损失函数相对于每个参数的偏导数：</p><p>$\frac{\partial L}{\partial W} = \text{梯度}$</p><p>通过计算每个参数的偏导数，反向传播算法能逐步调整网络权重，使得损失函数 $L$ 最小化，提高模型的预测能力。</p><h4 id="532-偏导数推导过程"><a href="#5-3-2-偏导数推导过程" class="headerlink" title="5.3.2 偏导数推导过程"></a>5.3.2 偏导数推导过程</h4><p>如果 $f(x, y) = x^2 + y^2$，则对 $x$ 的偏导数为：</p><p>$\frac{\partial f}{\partial x} = \frac{\partial (x^2 + y^2)}{\partial x} = 2x$</p><p>根据求导法则，分开对每一项求导：<br>$\frac{\partial f}{\partial x} = \frac{\partial (x^2 + y^2)}{\partial x} =\frac{\partial}{\partial x} (x^2) + \frac{\partial}{\partial x} (y^2)$</p><p>对于 $x^2$，使用幂函数求导法则 $\frac{\partial}{\partial x} (x^n) = nx^{n-1}$：<br>$\frac{\partial}{\partial x} (x^2) = 2x^{2-1}= 2x$<br>对于 $y^2$，因为$y$ 被视为常数，对 $x$ 求导结果为 0：<br>$\frac{\partial}{\partial x} (y^2) = 0$</p><p>同理，对 $y$ 的偏导数为：</p><p>$\frac{\partial f}{\partial y} = \frac{\partial (x^2 + y^2)}{\partial y} = 2y$</p><p>现在根据以上理解逐层反向计算每个参数的梯度</p><h4 id="533-计算输出层的梯度"><a href="#5-3-3-计算输出层的梯度" class="headerlink" title="5.3.3 计算输出层的梯度"></a>5.3.3 计算输出层的梯度</h4><p>假设我们使用均方误差（MSE）作为损失函数：<br>$L = \frac{1}{2} (y - t)^2$</p><p>其中，$t$ 是目标值。</p><p>首先，计算损失相对于输出 $y$ 的梯度：</p><p>$\frac{\partial L}{\partial y} = y - t$</p><p>然后，计算损失相对于隐藏层到输出层权重 $W_{31}$​ 和 $W_{32}$的梯度：</p><p>$\frac{\partial L}{\partial W_{31}} = \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial W_{31}}=\frac{\partial L}{\partial y} \cdot \frac{\partial (w_{31}h_1 + w_{32}h_2 + b_3)}{\partial W_{31}} = (y - t) \cdot h_1$</p><p>由于 $W_{31}$和 $h_1$​ 相乘，而 $h_1$​  不依赖于 $W_{31}$，其余项在偏导数计算中都是常数，因此可以忽略。所以</p><p>在这个表达式中，$W_{31}$和 $h_1$​ 相乘，其余项与 $W_{31}$无关，因此在对 $W_{31}​$ 求导时可以忽略。<br>$\frac{\partial L}{\partial W_{31}} = \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial W_{31}}=\frac{\partial L}{\partial y} \cdot \frac{\partial (w_{31}h_1)}{\partial W_{31}}$</p><p>根据幂函数求导法则 $\frac{\partial}{\partial x} (x^n) = nx^{n-1}$<br>根据线性求导法则，常数项可以直接提取出来  $\frac{\partial}{\partial x} (a\cdot x) = a$</p><p>$\frac{\partial L}{\partial W_{31}} = \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial W_{31}}=\frac{\partial L}{\partial y} \cdot \frac{\partial (w_{31}h_1)}{\partial W_{31}} = \frac{\partial L}{\partial y} \cdot \frac{\partial (w_{31}h_1)}{\partial W_{31}}= (y-t) \cdot h_1$</p><p>同理可得：<br>$\frac{\partial L}{\partial W_{32}} = \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial W_{32}} = (y - t) \cdot h_2$</p><p>计算损失相对于偏置 $b_3​$ 的梯度：</p><p>$\frac{\partial L}{\partial b_3} = \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial b_3} = (y - t) \cdot 1 = y - t$</p><h4 id="534-计算隐藏层的梯度"><a href="#5-3-4-计算隐藏层的梯度" class="headerlink" title="5.3.4 计算隐藏层的梯度"></a>5.3.4 计算隐藏层的梯度</h4><p>对于隐藏层的梯度，需要计算损失相对于隐藏状态 $h_1$​ 和 $h_2$​ 的梯度：</p><p>$\frac{\partial L}{\partial h_1} = \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial h_1} = (y - t) \cdot W_{31}$</p><p>$\frac{\partial L}{\partial h_2} = \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial h_2} = (y - t) \cdot W_{32}$</p><p>其中，$y = w_{31}h_1 + w_{32}h_2 + b_3$</p><p>计算推导过程同上，可以得到以上结果</p><p>由于隐藏层使用的是ReLU激活函数，其导数为：</p><p>$\frac{\partial \text{ReLU}(z)}{\partial z} = \begin{cases} 1 &amp; \text{if } z &gt; 0 \ 0 &amp; \text{if } z \leq 0 \end{cases}$</p><p>其中 $h_1 = \text{ReLU}(z_1^{(1)})$</p><p>因此应用链式法则后：</p><p>$\frac{\partial L}{\partial z_1} = \frac{\partial L}{\partial h_1} \cdot \frac{\partial h_1}{\partial z_1} = (y - t) \cdot W_{31} \cdot \begin{cases} 1 &amp; \text{if } z_1 &gt; 0 \ 0 &amp; \text{if } z_1 \leq 0 \end{cases}$</p><p>$\frac{\partial L}{\partial z_2} = \frac{\partial L}{\partial h_2} \cdot \frac{\partial h_2}{\partial z_2} = (y - t) \cdot W_{32} \cdot \begin{cases} 1 &amp; \text{if } z_2 &gt; 0 \ 0 &amp; \text{if } z_2 \leq 0 \end{cases}$</p><h4 id="535-计算输入层的梯度"><a href="#5-3-5-计算输入层的梯度" class="headerlink" title="5.3.5 计算输入层的梯度"></a>5.3.5 计算输入层的梯度</h4><p>最后，计算损失相对于输入层权重 $W_{11}, W_{12}, W_{21}, W_{22}$​ 的梯度：</p><p>$\frac{\partial L}{\partial W_{11}} = \frac{\partial L}{\partial z_1} \cdot \frac{\partial z_1}{\partial W_{11}} = \frac{\partial L}{\partial z_1} \cdot x_1$</p><p>$\frac{\partial L}{\partial W_{12}} = \frac{\partial L}{\partial z_2} \cdot \frac{\partial z_2}{\partial W_{12}} = \frac{\partial L}{\partial z_2} \cdot x_1$</p><p>$\frac{\partial L}{\partial W_{21}} = \frac{\partial L}{\partial z_1} \cdot \frac{\partial z_1}{\partial W_{21}} = \frac{\partial L}{\partial z_1} \cdot x_2$</p><p>$\frac{\partial L}{\partial W_{22}} = \frac{\partial L}{\partial z_2} \cdot \frac{\partial z_2}{\partial W_{22}} = \frac{\partial L}{\partial z_2} \cdot x_2$​</p><h3 id="54-更新权重weight-update"><a href="#5-4-更新权重（Weight-Update）" class="headerlink" title="5.4 更新权重（Weight Update）"></a>5.4 更新权重（Weight Update）</h3><p>使用梯度下降算法根据计算得到的梯度调整权重。梯度下降的基本公式为：<br>$W_{new​}=W_{old}​−η⋅\frac{\partial L}{\partial W}$</p><p>其中，$\eta$ 是学习率（Learning Rate），$\frac{\partial L}{\partial W}$​ 是损失函数对权重的梯度。</p><p>常见的梯度下降变种</p><ul><li><strong>批量梯度下降（Batch Gradient Descent）</strong>：在整个训练数据集上计算梯度，然后更新权重。适用于小数据集，但计算量大，效率较低。</li><li><strong>随机梯度下降（Stochastic Gradient Descent, SGD）</strong>：在每个训练样本上计算梯度，然后更新权重。计算效率高，但梯度噪声大，收敛不稳定。</li><li><strong>小批量梯度下降（Mini-Batch Gradient Descent）</strong>：在小批量训练样本上计算梯度，然后更新权重。结合了批量和随机梯度下降的优点，常用在实际训练中。</li></ul><h2 id="6-超参数hyperparameters-vs-模型参数parameters"><a href="#6-超参数（Hyperparameters）-vs-模型参数（Parameters）" class="headerlink" title="6. 超参数（Hyperparameters） vs  模型参数（Parameters）"></a>6. 超参数（Hyperparameters） vs  模型参数（Parameters）</h2><h3 id="超参数hyperparameters"><a href="#超参数（Hyperparameters）：" class="headerlink" title="超参数（Hyperparameters）："></a><strong>超参数（Hyperparameters）</strong>：</h3><ul><li>定义：超参数是指在模型训练之前需要手动设置的参数，不通过训练数据学习得到，而是通过试验、经验或自动调优方法设定。</li><li>作用：控制模型的训练过程、模型复杂度、正则化程度等。</li><li>示例：学习率（learning rate）、批大小（batch size）、隐藏层的数量和大小、正则化系数（如L2正则化中的λ）、训练轮数（epochs）等。</li><li>调整方法：手动调试（Manual Tuning）、网格搜索（Grid Search）、随机搜索（Random Search）、贝叶斯优化（Bayesian Optimization）等。</li><li>调整频率：通常在训练之前设定，在训练过程中不变。可能需要多次试验和调优过程才能确定最佳超参数。</li></ul><h3 id="模型参数model-parameters"><a href="#模型参数（Model-Parameters）：" class="headerlink" title="模型参数（Model Parameters）："></a><strong>模型参数（Model Parameters）</strong>：</h3><ul><li>定义：模型参数是指在模型训练过程中通过数据学习得到的参数，这些参数定义了模型的最终形态和行为。</li><li>作用：直接影响模型的预测输出，反映了模型从数据中学到的知识。</li><li>示例：神经网络中的权重和偏置、线性回归中的回归系数、支持向量机中的支持向量等。</li><li>调整方法：通过训练数据和优化算法（如梯度下降）自动调整。</li><li>调整频率：在每个训练迭代中都要更新，直到模型收敛或达到预设的训练轮数。</li></ul><h3 id="神经网络中的超参数和模型参数"><a href="#神经网络中的超参数和模型参数" class="headerlink" title="神经网络中的超参数和模型参数"></a>神经网络中的超参数和模型参数</h3><p><strong>超参数</strong>：</p><ul><li>学习率（Learning Rate）：决定每次权重更新的步长。</li><li>批大小（Batch Size）：决定每次权重更新时使用的训练样本数量。</li><li>隐藏层数和每层神经元数量：定义神经网络的结构和复杂度。</li><li>正则化系数：控制正则化项在损失函数中的权重，防止过拟合。</li><li>训练轮数（Epochs）：模型在整个训练数据集上完整训练的次数。</li></ul><p><strong>模型参数</strong>：</p><ul><li>权重（Weights）：连接神经元的权重，表示输入特征的重要性。</li><li>偏置（Biases）：每个神经元的偏置，用于调整激活函数的输出。</li></ul><h2 id="7-序列数据-vs-非序列数据"><a href="#7-序列数据-vs-非序列数据" class="headerlink" title="7. 序列数据 vs 非序列数据"></a>7. 序列数据 vs 非序列数据</h2><h3 id="1-序列数据sequential-data"><a href="#1-序列数据（Sequential-Data）" class="headerlink" title="1. 序列数据（Sequential Data）"></a>1. 序列数据（Sequential Data）</h3><p>序列数据（Sequential Data）是指按照时间或其他顺序排列的数据，其中每个数据点的意义和价值都依赖于它在序列中的位置和前后数据点的关系。序列数据广泛存在于许多实际应用中，如时间序列、自然语言处理、语音识别等。</p><h4 id="序列数据的特点"><a href="#序列数据的特点" class="headerlink" title="序列数据的特点"></a>序列数据的特点</h4><ol><li><strong>时间依赖性</strong>：序列数据中的每个数据点与其前后数据点存在依赖关系。这种依赖性可以是短期的（仅依赖于最近的数据点）或长期的（依赖于较早的数据点）。</li><li><strong>顺序关系</strong>：序列数据的顺序是至关重要的，数据点的顺序关系决定了其实际意义。例如，在语音信号中，音频帧的顺序决定了最终语音的内容。</li><li><strong>动态性</strong>：序列数据往往是动态变化的，数据点的值随时间或其他顺序变化而变化。</li></ol><p>递归神经网络（RNN）和其变体如LSTM和GRU擅长处理序列数据</p><h3 id="2-非序列数据"><a href="#2-非序列数据" class="headerlink" title="2. 非序列数据"></a>2. 非序列数据</h3><p>非序列化数据是指那些数据点之间没有时间或顺序依赖关系的数据。与序列化数据（如时间序列、文本、语音信号等）不同，非序列化数据中的每个数据点都是独立的，不依赖于前后的数据点。非序列化数据在各种领域中广泛存在，包括图像数据、表格数据（结构化数据）、图数据等。<br>不同类型的非序列化数据可以通过不同的神经网络进行处理，如卷积神经网络（CNN）处理图像数据，前馈神经网络（FNN）处理表格数据，图神经网络（GNN）处理图数据。在实际应用中，选择合适的神经网络模型能够有效地处理各种非序列化数据，解决实际问题。</p><h4 id="非序列化数据的实际应用"><a href="#非序列化数据的实际应用" class="headerlink" title="非序列化数据的实际应用"></a>非序列化数据的实际应用</h4><h5 id="1-图像数据的应用"><a href="#1-图像数据的应用" class="headerlink" title="1. 图像数据的应用"></a>1. 图像数据的应用</h5><p>图像数据是高维非序列数据，具有空间结构特性。卷积神经网络（CNN）是处理图像数据的主要神经网络类型。</p><p><strong>医疗影像分析</strong>：通过CNN处理医疗影像（如MRI、CT图像），进行疾病诊断和分类。</p><p><strong>自动驾驶</strong>：使用CNN分析汽车摄像头捕捉的道路图像，识别行人、交通标志和其他车辆。<br><strong>图像分类</strong>：使用CNN对输入图像进行分类。例如，ImageNet数据集上的物体识别任务。</p><ul><li>具体应用：卷积层提取图像的局部特征，池化层减少特征维度，全连接层进行分类。</li><li>典型模型：AlexNet、VGG、ResNet等。<br><strong>图像分割</strong>：将图像划分为具有不同语义意义的区域。例如，自动驾驶中的道路标记识别。</li><li>具体应用：利用全卷积神经网络（FCN）或U-Net对图像进行像素级分类。</li><li>典型模型：U-Net、SegNet等。</li></ul><h5 id="2-表格数据的应用"><a href="#2-表格数据的应用" class="headerlink" title="2. 表格数据的应用"></a>2. 表格数据的应用</h5><p>表格数据通常存储在数据库或电子表格中，包含多种特征和目标变量。前馈神经网络（FNN）适用于处理表格数据。<br><strong>回归分析</strong>：预测连续值，如房价预测。</p><ul><li>具体应用：输入层接收多种特征，隐藏层提取特征之间的复杂关系，输出层给出预测值。</li><li>典型模型：多层感知器（MLP）。<br>-<strong>分类任务</strong>：对数据进行分类，如信用卡欺诈检测。</li><li>具体应用：输入层接收各特征值，隐藏层提取特征间关系，输出层进行分类。</li><li>典型模型：多层感知器（MLP）。</li></ul><p><strong>客户分类</strong>：使用FNN对客户进行分类，如根据客户购买行为预测客户流失风险。</p><h5 id="3-图数据的应用"><a href="#3-图数据的应用" class="headerlink" title="3. 图数据的应用"></a>3. 图数据的应用</h5><p>图数据由节点和边构成，具有复杂的连接结构。图神经网络（Graph Neural Networks, GNNs）专门用于处理图数据。</p><p><strong>节点分类</strong>：在图中为每个节点分配标签，如社交网络中的用户分类。</p><ul><li>具体应用：图卷积神经网络（GCN）通过聚合邻居节点的信息更新每个节点的表示，然后进行分类。</li><li>典型模型：GCN、GraphSAGE。<br><strong>图分类</strong>：对整个图进行分类，如分子结构的化学性质预测。</li><li>具体应用：将图嵌入到固定长度的向量表示中，然后使用前馈神经网络进行分类。</li><li>典型模型：DGCNN、GraphSAGE。</li></ul><p><strong>社交网络分析</strong>：通过GNN分析社交网络中的用户关系，进行用户分类和推荐系统。</p><p><strong>化学分子建模</strong>：使用GNN分析化学分子结构，预测分子的物理和化学性质。</p><h2 id="8-向量"><a href="#8-向量" class="headerlink" title="8. 向量"></a>8. 向量</h2><p>在神经网络中，向量是一个重要的数学工具，用于表示和操作多个数值。向量在神经网络的各个部分都有广泛的应用，包括输入数据、权重、偏置、激活值等。为了更好地理解向量在神经网络中的角色，我们可以从以下几个方面进行详细阐述：</p><h4 id="向量的定义"><a href="#向量的定义" class="headerlink" title="向量的定义"></a>向量的定义</h4><p>一个向量是一个具有方向和大小的数量集合，通常用一维数组来表示。在神经网络中，向量可以用来表示输入特征、隐藏层的激活值、输出值以及模型的权重和偏置。</p><h4 id="向量在神经网络中的具体应用"><a href="#向量在神经网络中的具体应用" class="headerlink" title="向量在神经网络中的具体应用"></a>向量在神经网络中的具体应用</h4><h5 id="1-输入向量"><a href="#1-输入向量" class="headerlink" title="1. 输入向量"></a>1. 输入向量</h5><p>输入向量表示神经网络接收到的原始数据。在一个简单的前馈神经网络中，输入向量通常是一个包含多个特征的数据点。例如，对于一个图像分类任务，每个输入向量可能代表一张图像的像素值。</p><p><strong>示例</strong>： 对于一个具有三个特征的输入数据点$(x_1, x_2, x_3)$，输入向量可以表示为：$\mathbf{x} = \begin{bmatrix} x_1 \ x_2 \ x_3 \end{bmatrix}$</p><h5 id="2-权重向量"><a href="#2-权重向量" class="headerlink" title="2. 权重向量"></a>2. 权重向量</h5><p>权重向量表示神经元之间的连接强度。在神经网络中，每个神经元的输出都是前一层神经元输出的加权和。权重向量决定了输入特征对输出的影响程度。</p><p><strong>示例</strong>： 对于一个具有三个输入特征的神经元，其权重向量可以表示为： $\mathbf{w} = \begin{bmatrix} w_1 \ w_2 \ w_3 \end{bmatrix}$</p><h5 id="3-偏置向量"><a href="#3-偏置向量" class="headerlink" title="3. 偏置向量"></a>3. 偏置向量</h5><p>偏置向量是一个额外的参数，用于调整神经元的输出，使其能够更好地拟合数据。偏置向量与权重向量一起，影响每个神经元的输出。</p><p><strong>示例</strong>： 对于一个具有三个输入特征的神经元，其偏置向量可以表示为： $\mathbf{b} = b$</p><h5 id="4-激活值向量"><a href="#4-激活值向量" class="headerlink" title="4. 激活值向量"></a>4. 激活值向量</h5><p>激活值向量表示神经网络中每一层的输出。在前向传播过程中，输入向量与权重向量相乘并加上偏置向量，经过激活函数后得到的值即为激活值。</p><p><strong>示例</strong>： 对于一个具有三个神经元的隐藏层，其激活值向量可以表示为： $\mathbf{a} = \begin{bmatrix} a_1 \ a_2 \ a_3 \end{bmatrix}$</p><h4 id="向量操作"><a href="#向量操作" class="headerlink" title="向量操作"></a>向量操作</h4><p>在神经网络中，常见的向量操作包括向量加法、向量乘法（点积）、标量乘法和向量的激活函数应用。</p><h5 id="1-向量加法"><a href="#1-向量加法" class="headerlink" title="1. 向量加法"></a>1. 向量加法</h5><p>向量加法是将两个向量的对应元素相加。假设有两个向量 $\mathbf{a}$ 和 $\mathbf{b}$，它们的向量加法表示为： $\mathbf{c} = \mathbf{a} + \mathbf{b}$<br>$\mathbf{c} = \begin{bmatrix} a_1 + b_1 \ a_2 + b_2 \ a_3 + b_3 \end{bmatrix}$</p><h5 id="2-向量乘法点积"><a href="#2-向量乘法（点积）" class="headerlink" title="2. 向量乘法（点积）"></a>2. 向量乘法（点积）</h5><p>向量点积是将两个向量的对应元素相乘并求和。假设有两个向量 a\mathbf{a}a 和 $\mathbf{b}$，它们的点积表示为：<br>$c = \mathbf{a} \cdot \mathbf{b}$<br>$c = a_1 \cdot b_1 + a_2 \cdot b_2 + a_3 \cdot b_3$</p><h5 id="3-标量乘法"><a href="#3-标量乘法" class="headerlink" title="3. 标量乘法"></a>3. 标量乘法</h5><p>标量乘法是将向量的每个元素乘以一个标量。假设有一个向量 $\mathbf{a}$ 和一个标量 $k$，它们的标量乘法表示为： $\mathbf{b} = k \cdot \mathbf{a}$</p><p>$\mathbf{b} = \begin{bmatrix} k \cdot a_1 \ k \cdot a_2 \ k \cdot a_3 \end{bmatrix}$</p><h4 id="示例前向传播中的向量运算"><a href="#示例：前向传播中的向量运算" class="headerlink" title="示例：前向传播中的向量运算"></a>示例：前向传播中的向量运算</h4><p>以一个简单的两层神经网络为例，说明向量在前向传播中的应用。</p><p><strong>输入层</strong>：输入向量 $\mathbf{x}$<br>$\mathbf{x} = \begin{bmatrix} x_1 \ x_2 \end{bmatrix}$</p><p><strong>隐藏层</strong>：权重向量 $\mathbf{W}$ 和偏置向量 $\mathbf{b}$<br>$\mathbf{W} = \begin{bmatrix} w_{11} &amp; w_{12} \ w_{21} &amp; w_{22} \end{bmatrix}$</p><p>$\mathbf{b} = \begin{bmatrix} b_1 \ b_2 \end{bmatrix}$</p><p><strong>计算隐藏层激活值</strong>：<br>$\mathbf{z} = \mathbf{W} \cdot \mathbf{x} + \mathbf{b}$</p><p>$\mathbf{z} = \begin{bmatrix} w_{11}x_1 + w_{12}x_2 + b_1 \ w_{21}x_1 + w_{22}x_2 + b_2 \end{bmatrix}$</p><p><strong>应用激活函数（如ReLU）</strong>：<br>$\mathbf{a} = \text{ReLU}(\mathbf{z})$<br>$\mathbf{a} = \begin{bmatrix} \text{ReLU}(z_1) \ \text{ReLU}(z_2) \end{bmatrix}$</p><p><strong>输出层</strong>：权重向量 $\mathbf{W’}$ 和偏置 $\mathbf{b’}$<br>$\mathbf{W’} = \begin{bmatrix} w_{31} &amp; w_{32} \end{bmatrix}$<br>$\mathbf{b’} = b’$</p><p><strong>计算输出值</strong>：<br>$y = \mathbf{W’} \cdot \mathbf{a} + \mathbf{b’}$<br>$y = w_{31}a_1 + w_{32}a_2 + b’$</p><h3 id="9误差"><a href="#9-误差" class="headerlink" title="9.误差"></a>9.误差</h3><p>训练误差、测试误差和验证误差是三个不同的概念，它们分别衡量模型在不同数据集上的表现。这些误差帮助我们评估模型的拟合程度和泛化能力</p><h4 id="91-区别和联系"><a href="#9-1-区别和联系" class="headerlink" title="9.1 区别和联系"></a>9.1 区别和联系</h4><ul><li><strong>训练误差</strong>：衡量模型在训练数据上的表现，主要用于训练过程中调整模型参数。</li><li><strong>验证误差</strong>：衡量模型在验证数据上的表现，主要用于超参数调优和模型选择。验证数据是从训练数据中分离出来的一部分，不参与模型训练。</li><li><strong>测试误差</strong>：衡量模型在测试数据上的表现，主要用于评估模型的最终泛化能力。测试数据在训练和验证过程中都不使用，只有在模型训练完成后才用于评估。</li></ul><h4 id="92-训练误差training-error"><a href="#9-2-训练误差（Training-Error）" class="headerlink" title="9.2 训练误差（Training Error）"></a>9.2 训练误差（Training Error）</h4><p>训练误差是指模型在训练数据上的误差。它反映了模型对训练数据的拟合程度。<br><strong>计算方法</strong></p><p>训练误差通常通过在训练数据上计算损失函数（例如均方误差、交叉熵损失等）来得到。例如，如果使用均方误差（MSE）作为损失函数，训练误差可以表示为：</p><p>$\text{MSE}_{\text{train}} = \frac{1}{N_{\text{train}}} \sum_{i=1}^{N_{\text{train}}} (y_i - \hat{y}_i)^2$</p><p>其中，NtrainN_{\text{train}}Ntrain​ 是训练数据的样本数量，yiy_iyi​ 是第 iii 个样本的真实值，y^i\hat{y}_i y^​i​ 是模型对第 iii 个样本的预测值。</p><p><strong>目标</strong><br>最小化训练误差，以便模型能够良好地拟合训练数据。</p><p><strong>意义</strong><br>低训练误差表明模型能够很好地拟合训练数据。但这并不一定意味着模型在新数据上的表现也会良好。</p><h4 id="93-预测误差测试误差"><a href="#9-3-预测误差-测试误差" class="headerlink" title="9.3 预测误差/测试误差"></a>9.3 预测误差/测试误差</h4><p>预测误差/测试误差 是指模型在未见过的数据（通常是测试数据或验证数据）上的误差。它反映了模型的泛化能力，即模型在新数据上的表现。</p><ul><li><strong>计算方法</strong>：在模型训练完成后，使用测试数据或验证数据计算损失函数的值，计算方法与训练误差类似</li><li><strong>目标</strong>：评估模型的泛化能力，期望模型在测试数据上的误差尽可能低。</li><li><strong>意义</strong>：低预测误差表明模型具有良好的泛化能力，能够在新数据上表现良好。</li></ul><h4 id="94-误差的作用"><a href="#9-4-误差的作用" class="headerlink" title="9.4 误差的作用"></a>9.4 误差的作用</h4><p>训练误差和预测误差的关系可以帮助我们诊断模型的状态，判断模型是否过拟合或欠拟合。</p><ul><li><strong>欠拟合（Underfitting）</strong>：模型在训练数据和测试数据上的误差都很高，说明模型复杂度不足，无法捕捉数据中的规律。</li><li><strong>合适拟合（Good Fit）</strong>：模型在训练数据上的误差较低，并且在测试数据上的误差也较低，说明模型具有良好的泛化能力。</li><li><strong>过拟合（Overfitting）</strong>：模型在训练数据上的误差很低，但在测试数据上的误差很高，说明模型过于复杂，捕捉到了训练数据中的噪声和细节，泛化能力较差。</li></ul><h3 id="10过度拟合"><a href="#10-过度拟合" class="headerlink" title="10.过度拟合"></a>10.过度拟合</h3><p>过度拟合（Overfitting）是机器学习中的一个常见问题，指的是模型在训练数据上表现良好，但在未见过的测试数据或实际应用中表现不佳。这通常是因为模型过于复杂，捕捉到了训练数据中的噪声和偶然性模式，而不是数据的潜在规律。</p><h4 id="过度拟合的具体表现"><a href="#过度拟合的具体表现" class="headerlink" title="过度拟合的具体表现"></a>过度拟合的具体表现</h4><ol><li><strong>训练误差低，测试误差高</strong>：模型在训练数据上的误差很低，但在测试数据或新数据上的误差很高。</li><li><strong>高方差</strong>：模型对训练数据中的细节和噪声过于敏感，导致对不同数据集的表现差异很大。</li><li><strong>复杂模型</strong>：过于复杂的模型（例如，具有太多参数的深度神经网络）容易过度拟合。</li></ol><h4 id="过度拟合的原因"><a href="#过度拟合的原因" class="headerlink" title="过度拟合的原因"></a>过度拟合的原因</h4><ol><li><strong>模型复杂度高</strong>：模型的参数过多，能够拟合训练数据中的每一个细节和噪声。</li><li><strong>训练数据不足</strong>：训练数据量过少，模型无法学习到数据的真实分布和规律。</li><li><strong>噪声数据</strong>：训练数据中包含大量噪声，模型将这些噪声误认为是数据的潜在模式。</li><li><strong>缺乏正则化</strong>：没有使用正则化技术来约束模型的复杂度。</li></ol><h4 id="如何检测过度拟合"><a href="#如何检测过度拟合" class="headerlink" title="如何检测过度拟合"></a>如何检测过度拟合</h4><ol><li><strong>训练误差与验证误差</strong>：在训练过程中，观察训练误差和验证误差的变化。如果训练误差持续下降，而验证误差在某个点之后开始上升，这通常是过度拟合的信号。</li><li><strong>交叉验证</strong>：使用交叉验证技术评估模型在多个数据子集上的表现，避免模型对单一训练集的过度依赖。</li><li><strong>学习曲线</strong>：绘制学习曲线（训练误差和验证误差随训练样本数量变化的曲线），分析模型的学习行为。</li></ol><h4 id="解决过度拟合的方法"><a href="#解决过度拟合的方法" class="headerlink" title="解决过度拟合的方法"></a>解决过度拟合的方法</h4><ol><li><strong>增加训练数据</strong>：通过增加训练数据量，模型可以更好地学习数据的真实分布，减少对噪声的拟合。</li><li><strong>简化模型</strong>：减少模型的参数数量或选择更简单的模型，避免过度拟合。</li><li><strong>正则化</strong>：使用正则化技术（如L1和L2正则化）来约束模型参数，使其更平滑，减少对训练数据的过度拟合。<ul><li><strong>L1正则化</strong>：通过对模型参数的绝对值求和，使部分参数变为零，起到特征选择的作用。</li><li><strong>L2正则化</strong>：通过对模型参数的平方和进行约束，使参数值尽可能小，从而使模型更平滑。</li></ul></li><li><strong>Dropout</strong>：在训练过程中随机丢弃一部分神经元，防止模型对某些路径的过度依赖。</li><li><strong>数据增强</strong>：通过对训练数据进行旋转、缩放、裁剪等变换，生成更多的训练样本，增加数据的多样性。</li><li><strong>早停法（Early Stopping）</strong>：在训练过程中监控验证误差，当验证误差不再下降时，提前停止训练，防止模型过度拟合。</li></ol><h3 id="11-泛化能力"><a href="#11-泛化能力" class="headerlink" title="11. 泛化能力"></a>11. 泛化能力</h3><p>泛化能力（Generalization）是指机器学习模型在训练数据以外的数据（通常是未见过的测试数据或真实应用中的数据）上表现良好的能力。它反映了模型对数据的普遍规律的学习程度，而不是对训练数据的记忆程度。</p><p>一个具有良好泛化能力的模型能够有效地从训练数据中学习到潜在的规律，并将这些规律应用于新数据上，从而在实际应用中保持高效和准确的表现。</p><p>理解泛化能力需要考虑以下几个方面：</p><ol><li>训练误差和测试误差<br>如果模型在训练数据上的误差很低，但在测试数据上的误差很高，这通常表明模型过度拟合（Overfitting）。相反，如果模型在训练数据和测试数据上的误差都较低，这表明模型具有良好的泛化能力。</li><li>模型复杂度<ul><li><strong>简单模型</strong>：模型复杂度低，参数较少，容易欠拟合（Underfitting），即无法充分捕捉数据中的规律。</li><li><strong>复杂模型</strong>：模型复杂度高，参数较多，容易过度拟合，即捕捉了训练数据中的噪声和偶然模式。<br>一个具有良好泛化能力的模型应在简单和复杂之间取得平衡，既能捕捉数据的潜在规律，又不过度拟合噪声。</li></ul></li></ol><h3 id="12正则化"><a href="#12-正则化" class="headerlink" title="12.正则化"></a>12.正则化</h3><p>正则化（Regularization）是一种在机器学习和统计学中用于防止模型过拟合（overfitting）的技术,提高模型泛化能力的关键技术。</p><h4 id="正则化的类型"><a href="#正则化的类型" class="headerlink" title="正则化的类型"></a>正则化的类型</h4><ol><li><strong>L1 正则化（Lasso 正则化）</strong>：<ul><li><strong>定义</strong>：在损失函数中添加所有模型参数绝对值的和。</li><li><strong>数学表达</strong>： $\text{Loss} = \text{Original Loss} + \lambda \sum |w_i|$</li><li><strong>特点</strong>：可以导致一些参数完全为零，起到特征选择的作用。</li></ul></li><li><strong>L2 正则化（Ridge 正则化）</strong>：<ul><li><strong>定义</strong>：在损失函数中添加所有模型参数平方和。</li><li><strong>数学表达</strong>： $\text{Loss} = \text{Original Loss} + \lambda \sum w_i^2$</li><li><strong>特点</strong>：可以防止参数变得过大，但不会使参数完全为零。</li></ul></li><li><strong>弹性网络（Elastic Net）正则化</strong>：<ul><li><strong>定义</strong>：结合 L1 和 L2 正则化。</li><li><strong>数学表达</strong>：$\text{Loss} = \text{Original Loss} + \lambda_1 \sum |w_i| + \lambda_2 \sum w_i^2$</li><li><strong>特点</strong>：结合了 L1 和 L2 的优点，既可以选择特征又可以防止参数过大。</li></ul></li><li><strong>Dropout 正则化</strong>：<ul><li><strong>定义</strong>：在每次训练时随机丢弃一部分神经元，使得模型在训练过程中不会过于依赖某些特定的神经元。</li><li><strong>特点</strong>：通过在训练过程中引入随机性，增强模型的鲁棒性。</li></ul></li></ol><h4 id="正则化的原理"><a href="#正则化的原理" class="headerlink" title="正则化的原理"></a>正则化的原理</h4><ul><li><strong>复杂度惩罚</strong>：通过向损失函数中添加一个表示模型复杂度的项，模型在训练时不仅要最小化原始损失函数，还要考虑模型的复杂度。</li><li><strong>参数约束</strong>：限制模型参数的大小或数量，防止模型在训练数据上过度拟合。</li><li><strong>增强泛化能力</strong>：通过控制模型的复杂度，提升模型在未见数据上的表现。</li></ul><h4 id="正则化在模型中的应用"><a href="#正则化在模型中的应用" class="headerlink" title="正则化在模型中的应用"></a>正则化在模型中的应用</h4><p>正则化技术在许多机器学习模型中应用广泛，包括线性回归、逻辑回归、支持向量机（SVM）、神经网络等。在实际应用中，正则化参数（如 λ\lambdaλ）通常需要通过交叉验证等方法进行调优，以获得最佳的模型性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-什么是神经网络-neural-networks&quot;&gt;&lt;a href=&quot;#0-什么是神经网络-Neural-Networks&quot; class=&quot;headerlink&quot; title=&quot;0. 什么是神经网络 (Neural Networks)&quot;&gt;&lt;/a&gt;0. 什么是神经</summary>
      
    
    
    
    
    <category term="AI" scheme="http://example.com/tags/AI/"/>
    
    <category term="神经网络" scheme="http://example.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Ilya sutskever‘s 30  papers" scheme="http://example.com/tags/Ilya-sutskever%E2%80%98s-30-papers/"/>
    
  </entry>
  
  <entry>
    <title>Ilya sutskever&#39;s approx 30 research papers about AI</title>
    <link href="http://example.com/17f5a37e/"/>
    <id>http://example.com/17f5a37e/</id>
    <published>2024-06-07T09:13:13.000Z</published>
    <updated>2024-06-16T14:27:01.519Z</updated>
    
    <content type="html"><![CDATA[<p>之前无意中刷到这个<a href="https://x.com/keshavchan/status/1787861946173186062?utm_source=www.mattprd.com&amp;utm_medium=referral&amp;utm_campaign=openai-cofounder-the-27-papers-to-read-to-know-90-about-ai">twitter</a>,  有点好奇这30篇paper 到底讲了啥，学完到底能知道什么，所以决定读一读。</p><img src="/17f5a37e/1.png" class><h1 id="如何读"><a href="#如何读" class="headerlink" title="如何读"></a>如何读</h1><p>作为一个算法和AI小白,  真的学会在今天90%关于AI 的内容有点超出能力范畴， 所以我的目标是读懂这些paper的文本内容，建立一个整体的大框架即可。</p><p>依然对于一个算法和AI小白来说，直接阅读paper,、会遇到大量读不懂的概念， 需要查询相关资料，我觉得如果你也是小白同时也对这些paper 感兴趣的话，我查询的资料和阅读过程对你也会有帮助，所以我会把这些内容都记录下来，供你参考。</p><h1 id="阅读记录"><a href="#阅读记录" class="headerlink" title="阅读记录"></a>阅读记录</h1><p><a href="https://sunyan.xyz/f27811be/">神经网络（Neural Networks）</a></p><p><a href="https://sunyan.xyz/6ac941eb/">递归神经网络（Recurrent Neural Networks, RNNs）</a></p><p><a href="https://sunyan.xyz/2472be8a/">The Unreasonable Effectiveness of Recurrent Neural Networks</a></p><p><a href="https://sunyan.xyz/4579c6a3/">Understanding LSTM Networks</a></p><p><a href="https://sunyan.xyz/7057a5e3/">RECURRENT NEURAL NETWORK REGULARIZATION</a>)</p><h1 id="30-research-papers"><a href="#30-research-papers" class="headerlink" title="30 research papers"></a>30 research papers</h1><p><a href="https://arc.net/folder/D0472A20-9C20-4D3F-B145-D2865C0A9FEE">https://arc.net/folder/D0472A20-9C20-4D3F-B145-D2865C0A9FEE</a></p><ol><li>The Annotated Transformer<br>简介：Transformer 模型注释版，详细解析了 Transformer 模型的内部结构和工作原理。推荐理由：理解现代 NLP 模型的基础。</li><li>The First Law of Complexodynamics<br>简介：探讨了复杂动力学的第一定律，解释了复杂系统的演变规律。推荐理由：提供了关于复杂系统的一些理论基础。</li><li>The Unreasonable Effectiveness of Recurrent Neural Networks<br>简介：讨论了 RNN 在处理序列数据时的有效性。推荐理由：帮助理解 RNN 的应用和优势。</li><li>Understanding LSTM Networks<br>简介：详细介绍了 LSTM 网络的结构和功能。推荐理由：LSTM 是 RNN 的重要变种，广泛应用于序列数据处理。</li><li>Recurrent Neural Network Regulation<br>简介：探讨了 RNN 的正则化方法。推荐理由：正则化是提高模型泛化能力的重要手段。</li><li>Keeping Neural Networks Simple by Minimizing the Description Length of the Weights<br>简介：通过最小化权重描述长度来简化神经网络。推荐理由：提供了一种简化模型的方法，提升模型的解释性。</li><li>Pointer Networks<br>简介：介绍了指针网络及其在处理离散序列问题上的应用。推荐理由：拓展了对序列模型的认识。</li><li>ImageNet Classification with Deep Convolutional Neural Networks<br>简介：深度卷积神经网络在 ImageNet 分类上的应用。推荐理由：经典论文，推动了深度学习在计算机视觉领域的革命。</li><li><p>Order Matters: Sequence to Sequence for Sets<br>简介：讨论了顺序在序列到序列模型中的重要性。推荐理由：提供了对序列模型的深刻理解。</p></li><li><p>GPipe: Easy Scaling with Micro-Batch Pipeline Parallelism<br>简介：介绍了通过微批次流水线并行实现模型扩展的方法。推荐理由：解决大规模模型训练的瓶颈问题。</p></li><li>Deep Residual Learning for Image Recognition<br>简介：深度残差学习在图像识别中的应用。推荐理由：残差网络是深度学习的一大突破。</li><li>Multi-Scale Context Aggregation by Dilated Convolutions<br>简介：通过膨胀卷积实现多尺度上下文聚合。推荐理由：在处理图像和信号时的有效方法。</li><li>Neural Message Passing for Quantum Chemistry<br>简介：神经消息传递在量子化学中的应用。推荐理由：展示了神经网络在科学计算中的潜力。</li><li>Attention Is All You Need<br>简介：Transformer 模型的奠基论文，提出了注意力机制。推荐理由：现代 NLP 模型的基石。</li><li>Neural Machine Translation By Jointly Learning To Align And Translate<br>简介：通过联合学习对齐和翻译的神经机器翻译方法。推荐理由：NMT 的重要发展。</li><li>Identity Mappings in Deep Residual Networks<br>简介：残差网络中的恒等映射。推荐理由：帮助理解深度网络的训练。</li><li>A simple neural network module for relational reasoning<br>简介：用于关系推理的简单神经网络模块。推荐理由：增强模型的推理能力。</li><li>Variational Lossy Autoencoder<br>简介：变分有损自编码器的介绍。推荐理由：提供了一种新颖的生成模型。</li><li>Relational recurrent neural networks<br>简介：关系递归神经网络。推荐理由：结合关系推理和序列建模的优势。</li><li>Quantifying the Rise and Fall of Complexity in Closed Systems: The Coffee Automaton<br>简介：定量分析封闭系统中复杂性的兴衰。推荐理由：理论性强，有助于理解复杂系统。</li><li>Neural Turing Machines<br>简介：神经图灵机的概念和应用。推荐理由：连接神经网络和计算理论的重要工作。</li><li>Deep Speech 2: End-to-End Speech Recognition in English and Mandarin<br>简介：端到端语音识别系统 Deep Speech 2 的介绍。推荐理由：语音识别领域的重要进展。</li><li>Scaling Laws for Neural Language Models<br>简介：神经语言模型的规模法则。推荐理由：帮助理解模型扩展的规律。</li><li>A Tutorial Introduction to the Minimum Description Length Principle<br>简介：最小描述长度原理的教程。推荐理由：理论基础，适用于多种模型选择问题。</li><li>Machine Super Intelligence<br>简介：机器超级智能的讨论。推荐理由：未来 AI 发展的重要参考。</li><li>Kolmogorov Complexity and Algorithmic Randomness<br>简介：Kolmogorov 复杂性和算法随机性的介绍。推荐理由：计算复杂性理论的经典。</li><li>CS231n Convolutional Neural Networks for Visual Recognition<br>简介：CS231n 课程网站，包含卷积神经网络的详细教程。推荐理由：全面的学习资源，适合入门和进阶学习。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前无意中刷到这个&lt;a href=&quot;https://x.com/keshavchan/status/1787861946173186062?utm_source=www.mattprd.com&amp;amp;utm_medium=referral&amp;amp;utm_campaign</summary>
      
    
    
    
    
    <category term="AI" scheme="http://example.com/tags/AI/"/>
    
    <category term="神经网络" scheme="http://example.com/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
    <category term="Ilya sutskever‘s 30  papers" scheme="http://example.com/tags/Ilya-sutskever%E2%80%98s-30-papers/"/>
    
  </entry>
  
  <entry>
    <title>饮料分级助手-糖脂ABCD分级计算器</title>
    <link href="http://example.com/e15dc0/"/>
    <id>http://example.com/e15dc0/</id>
    <published>2024-06-02T11:09:33.000Z</published>
    <updated>2024-08-15T12:57:45.331Z</updated>
    
    <content type="html"><![CDATA[<p>最近总是刷到新加坡饮料分级的信息，感觉确实是一种可以帮助大家在日常生活中选择更健康饮料的方式，但是目前国内除了上海有4个试点品牌外，均没有饮料分级信息。</p><p>所以我做了一个简单的微信小程序 糖脂ABCD分级计算器，来计算饮料的分级，目前分级计算计算新加坡的nutri-grade 标准，希望它可以帮助你更好得了解日常喝的饮料。你可以在以下场景使用它</p><ol><li>超市、便利店购买的瓶装饮料</li><li>目前提供配方的奶茶品牌，如喜茶</li><li>未提供配方的奶茶品牌，你可以根据一些饮料测评，获取含糖量进行计算。</li></ol><p>下图是我计算了一个偶尔会喝的少糖版烤黑糖啵啵牛乳，直接是最红的D级别。<br><img src="/e15dc0/WechatIMG432.jpg" class></p><p>欢迎在微信中搜索小程序 糖脂ABCD分级计算器使用，希望这个小工具对你有用。如果有建议的话也可以反馈给我。<br><img src="/e15dc0/WechatIMG431.jpg" class><br><img src="/e15dc0/3.jpg" class></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近总是刷到新加坡饮料分级的信息，感觉确实是一种可以帮助大家在日常生活中选择更健康饮料的方式，但是目前国内除了上海有4个试点品牌外，均没有饮料分级信息。&lt;/p&gt;
&lt;p&gt;所以我做了一个简单的微信小程序 糖脂ABCD分级计算器，来计算饮料的分级，目前分级计算计算新加坡的nutr</summary>
      
    
    
    
    
    <category term="personal projects" scheme="http://example.com/tags/personal-projects/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB事务-持久性的实现,binglog &amp; redo log</title>
    <link href="http://example.com/6cb5dc64/"/>
    <id>http://example.com/6cb5dc64/</id>
    <published>2024-05-02T14:47:18.000Z</published>
    <updated>2024-05-10T15:24:50.204Z</updated>
    
    <content type="html"><![CDATA[<p>在MySQL InnoDB 这个语境下， crash safe、数据不丢失 都指的是事务的持久性特性，即事务一旦提交，应当保证所有被成功提交的数据修改都能够正确地被持久化，不丢失数据, 即使宕机也能够恢复数据</p><p>在InnoDB 中，持久性 基于binlog 和redo log 实现， 且binlog 与redo log 的写入通过2PC 协调.</p><h1 id="0-xa-事务binlog-和redo-log-的两阶段提交"><a href="#0-XA-事务：binlog-和redo-log-的两阶段提交" class="headerlink" title="0 XA 事务：binlog 和redo log 的两阶段提交"></a>0 XA 事务：binlog 和redo log 的两阶段提交</h1><img src="/6cb5dc64/1.png" class><p>在MySQL中，InnoDB存储引擎 的 redo log 和MySQL服务器层binlog 之间的一致性是通过内部的XA机制（即分布式事务）来实现的，任何一个数据出现问题都会进行会滚。</p><p><strong>XA事务</strong>是一种分布式事务。通过两阶段提交协议和XA接口标准，事务管理器和资源管理器能够可靠地协同工作，实现跨系统的事务处理，确保多个独立资源的一致性。</p><p>在binlog 和redo log 的两阶段提交， binlog 充当协调者的角色。</p><p><a href="http://localhost:4000/5b064db6/">关于XA 事务具体可在这篇文章中查看</a></p><p>binlog 和 redo log 各自写入的过程还有很多细节，接下来进行讲解</p><h1 id="1-binlog"><a href="#1-binlog" class="headerlink" title="1 binlog"></a>1 binlog</h1><p>binlog是 MySQL 服务器层使用的日志文件，记录了所有修改数据库内容的SQL语句（如 INSERT, UPDATE, DELETE）,也被称为逻辑日志。</p><p>binlog 主要用于主备复制同步、崩溃恢复等功能。</p><h2 id="11-binlog-的三种日志格式"><a href="#1-1-binlog-的三种日志格式" class="headerlink" title="1.1 binlog 的三种日志格式"></a>1.1 binlog 的三种日志格式</h2><div class="table-container"><table><thead><tr><th><strong>格式</strong></th><th><strong>定义</strong></th><th><strong>优点</strong></th><th><strong>缺点</strong></th></tr></thead><tbody><tr><td><strong>Statement-Based Logging (SBL)</strong></td><td>记录执行的 SQL 语句本身，而不是每行数据的变更。</td><td>1. <strong>空间效率高</strong>：通常占用更少的空间，因为记录的是 SQL 语句。 <br>2. <strong>易于审计</strong>：直接记录 SQL 语句，易于阅读和理解。</td><td>1. <strong>非确定性行为</strong>：可能在主从复制中导致数据不一致，特别是涉及到非确定性函数（如 NOW()、RAND()）的 SQL 语句。<br>2. <strong>复制错误</strong>：某些特定情况下可能引起从服务器的复制错误。</td></tr><tr><td><strong>Row-Based Logging (RBL)</strong></td><td>记录数据变更前后的每行数据的具体变化，而不是执行的 SQL 语句。</td><td>1. <strong>数据一致性</strong>：在复制过程中提供高度的数据一致性。<br>2. <strong>安全性更高</strong>：不记录 SQL 语句，降低了 SQL 注入的风险。</td><td>1. <strong>空间占用大</strong>：因为记录了每一行的变化，可能导致 binlog 文件迅速增大。<br>2. <strong>可读性差</strong>：不记录 SQL 语句，对于人类审计不友好。</td></tr><tr><td><strong>Mixed-Based Logging (MBL)</strong></td><td>结合了 SBL 和 RBL 的特点，根据操作的类型自动选择使用基于语句的格式或基于行的格式记录。</td><td>1. <strong>灵活性高</strong>：根据 SQL 语句的特性选择最合适的日志格式。<br>2. <strong>平衡性能和一致性</strong>：在确保数据一致性的同时考虑日志大小和性能。</td><td>1. <strong>配置复杂</strong>：需要适当配置以确保效率和准确性。<br>2. <strong>预测性差</strong>：自动切换日志格式可能使得日志的结果难以预测。</td></tr></tbody></table></div><h2 id="12-binlog写入过程"><a href="#1-2-binlog写入过程" class="headerlink" title="1.2 binlog写入过程"></a>1.2 binlog写入过程</h2><p>binlog 的写入逻辑比较简单：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p><h3 id="121-binlog-cache"><a href="#1-2-1-binlog-cache" class="headerlink" title="1.2.1 binlog  cache"></a>1.2.1 binlog  cache</h3><p>对于每个客户端会话，MySQL 服务器为其分配一个 binlog cache。这个缓存是用来临时存储一个事务中产生的所有 binlog 事件。 但是binlog cache 刷新到磁盘时 多个线程是共写同一份 binlog 文件。</p><p>当一个新事务开始时，根据binlog 日志格式记录 每个修改SQL  语句到binlog cache 中</p><h3 id="122-page-cache-与-磁盘刷新持久化"><a href="#1-2-2-page-cache-与-磁盘刷新持久化" class="headerlink" title="1.2.2  page cache 与 磁盘刷新持久化"></a>1.2.2  page cache 与 磁盘刷新持久化</h3><p>当事务到达提交阶段时，首先将 binlog  cache 中的内容 写入到binlog 文件中，然后提交事务到 InnoDB，即 commit redo log 。</p><p>注意，这里的写入并不是直接写到到磁盘，而是先写入到文件系统的page cache, 然后通过<code>sync_binlog</code> 参数来决定 何时把数据写入到 磁盘。<br><img src="/6cb5dc64/2.png" class></p><p>磁盘刷新频率通过 <code>sync_binlog</code> 配置参数，</p><ol><li>sync_binlog=0 的时候，表示每次提交事务都不主动刷新磁盘，由文件系统自己控制刷盘频率</li><li>sync_binlog=1 的时候，表示每次提交事务都会将 binlog cache 中的内容刷新到磁盘</li><li>sync_binlog=N(N&gt;1) 的时候，表示累积 N 个提交事务后才将多个binlog cache中的内容刷新到磁盘。</li></ol><p>可以看到如果sync_binlog不设置为1 ，有有助于提高刷盘效率， 但是有丢失binlog 的风险。</p><h3 id="123-binlog-cache-不够用怎么办"><a href="#1-2-3-binlog-cache-不够用怎么办" class="headerlink" title="1.2.3  binlog cache 不够用怎么办"></a>1.2.3  binlog cache 不够用怎么办</h3><p>如果binlog cache  写满了怎么办？需要把数据暂存到磁盘</p><p>每个事务的 binlog 事件首先被写入到 binlog cache 中，这个缓存的大小由 <code>binlog_cache_size</code> 系统变量控制。</p><p>如果一个事务非常大，涉及大量的数据修改，导致binlog cache不足以存储当前事务的所有事件时，MySQL采用的处理机制是将缓存中的数据写入到磁盘上的一个临时文件中。这一过程可以分为以下几个步骤：</p><ol><li><strong>检测缓存溢出</strong>：当试图向binlog cache中写入数据，而缓存空间不足以容纳更多数据时，将触发溢出处理机制。</li><li><strong>数据写入临时文件</strong>：MySQL将当前binlog cache中的数据写入到一个临时文件中。这个临时文件通常位于MySQL的数据目录下，具有唯一标识，确保数据的隔离和安全。</li><li><strong>清空binlog cache</strong>：将数据写入临时文件后，binlog cache会被清空，为接下来的日志数据腾出空间。</li><li><strong>继续事务日志的记录</strong>：事务继续执行，新的日志事件会再次被记录到现在已经被清空的binlog cache中。</li><li><strong>事务提交</strong>：事务如果最终被提交，MySQL会将临时文件中的日志数据以及现在binlog cache中的数据一并写入到全局的binlog文件中。如果事务回滚，则临时文件和binlog cache中的数据都将被丢弃。</li></ol><h2 id="13-xid"><a href="#1-3-xid" class="headerlink" title="1.3  xid"></a>1.3  xid</h2><p>XID（Transaction Identifier） 可以理解成时MySQL server 层的事务唯一标识。</p><ul><li>MySQL服务器内部维护一个全局事务ID计数器，每个新事务都会分配一个唯一的ID。该计数器在内存中递增，保证每个事务ID在实例中是唯一的。</li><li>当一个新事务开始时，MySQL服务器层会从全局计数器中获取一个新的事务ID，将其赋予该事务，并存储在该事务的上下文中。</li></ul><h1 id="2-redo-log"><a href="#2-redo-log" class="headerlink" title="2  redo log"></a>2  redo log</h1><p>redo log是 InnoDB 存储引擎特有的日志文件，用于记录对数据库做出的更改前的数据页状态,也被称作物理日志，确保在数据库系统发生崩溃后能够恢复这些更改。<br><strong>记录内容</strong>：Redo log 记录的是数据页修改的物理操作，而非具体的 SQL 语句。</p><ul><li><strong>循环使用</strong>：Redo log 是固定大小的，通常配置为一组文件，工作在循环写入的方式。</li><li><strong>崩溃恢复</strong>：系统重启后，InnoDB 通过回放 redo log 来恢复未完成的事务，确保数据的完整性和一致性。</li><li><strong>提高性能</strong>：Redo log 允许 InnoDB 在事务提交时不必将所有数据页写回磁盘，只需确保 redo log 已被写入磁盘。</li><li>记录的是数据页的物理修改。 不论数据页是否在buffer pool 中， redo log 都要记录修改， 因为不记不能保证crash safe.</li><li>保存自增值</li></ul><h2 id="21-为什么要记录redo-log"><a href="#2-1-为什么要记录redo-log" class="headerlink" title="2.1 为什么要记录redo log"></a>2.1 为什么要记录redo log</h2><h3 id="211-buffer-pool"><a href="#2-1-1-buffer-pool" class="headerlink" title="2.1.1 buffer pool"></a>2.1.1 buffer pool</h3><p>MySQL 为了实现高性能，是不可能每次都从磁盘读数据或者把对数据的修改持久化到磁盘上的,所以 InnoDB 申请了一块连续的内存，用于存储从磁盘上读取的pages, 这个内存就是buffer pool。</p><p>buffer pool 有一块内存叫做，change buffer 用于暂存对数据的修改</p><img src="/6cb5dc64/3.png" class><p>那么在修改数据时，就会遇到两种情况</p><ol><li>数据所在的page 在buffer pool 中， 就会直接更新page</li><li>数据所在的page 不在buffer pool 中， 如果不需要加载对应page, 就会先把对数据的修改先记在change buffer 中</li></ol><p>不论是buffer pool, 还是 buffer pool 中的change buffer, 都是内存，一旦发生宕机，那就数据的修改的修改就会丢失，此时就违背了事务的持久性。</p><p>为了能把修改过的数据持久化又不影响性能，InnoDB 给出的方案是优先把修改操作记下来并持久化， 事务提交后，万一宕机丢失了buffer pool 中已修改但是未持久化的内容，就可以根据持久化的修改操作重新得到修改后数据。</p><p>这里记录下来的修改操作就是redo log,  而这种先记录修改操作，再记录修改后的技术叫做WAL。</p><h3 id="212-wal"><a href="#2-1-2-WAL" class="headerlink" title="2.1.2 WAL"></a>2.1.2 WAL</h3><p>WAL（Write-Ahead Logging）是一种在数据库系统中广泛采用的日志管理技术，用于保证数据库的事务持久性和恢复能力。</p><p>它的关键点就是先写日志，再写真正的数据。</p><p>redo log 直接应用了 WAL 技术，确保在任何数据被写入数据库页之前，相应的日志信息（如数据页的修改）先被写入到 redo log 中。</p><p>总的来说WAL 技术的优势有以下3项，</p><ol><li><strong>恢复能力</strong>：WAL 提供了强大的数据恢复能力。在发生系统故障后，可以利用日志文件中的记录来重做或撤销事务，恢复到最后一致的状态。</li><li><strong>性能优化</strong>：通过将对磁盘数据的随机写转换为<code>顺序写</code> ， 同时利用 <code>组提交</code> ，WAL 可以显著提高数据库的写性能。</li><li><strong>事务原子性和持久性</strong>：WAL 通过确保所有日志记录在实际数据写入前被提交到磁盘，从而支持数据库事务的原子性和持久性。</li></ol><h2 id="22-redo-log-记录的内容"><a href="#2-2-redo-log-记录的内容" class="headerlink" title="2.2 redo log 记录的内容"></a>2.2 redo log 记录的内容</h2><p>之所以说redo log 是物理日志， 是因为其记录了对特定数据page 数据的修改。<br>该例子来自极客专栏《MySQL 实战45讲》</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t(ID int primary key, c int);</span><br><span class="line">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure><img src="/6cb5dc64/4.png" class><p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p><ol><li>Page 1 在内存中，直接更新内存；</li><li>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</li><li>将上述两个动作记入 redo log 中（图中 3 和 4）。</li></ol><p>Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。</p><h2 id="23-redo-log-写入过程"><a href="#2-3-redo-log-写入过程" class="headerlink" title="2.3 redo log 写入过程"></a>2.3 redo log 写入过程</h2><p><a href="https://time.geekbang.org/column/article/76161"># 23 | MySQL是怎么保证数据不丢的？ redo log 的写入机制-redo log buffer </a></p><p>redo log 的写入机制和 binlog 类型， 需要经历</p><ol><li>MySQL 系统内存cache ， redo lo buffer</li><li>文件系统page cache</li><li>刷新持久化到磁盘<img src="/6cb5dc64/5.png" class></li></ol><h3 id="231-redo-log-buffer"><a href="#2-3-1-redo-log-buffer" class="headerlink" title="2.3.1 redo log buffer"></a>2.3.1 redo log buffer</h3><p>add(id1,k1) to page1, new change buffer item add(id2,k2) to page2 都是先写入redo log buffer 中</p><p>相比较 每个线程都拥有自己一块独立的 binlog cache ， 而 redo log buffer 是全局共用的。</p><h3 id="232-redo-log持久化到磁盘"><a href="#2-3-2-redo-log持久化到磁盘" class="headerlink" title="2.3.2 redo log持久化到磁盘"></a>2.3.2 redo log持久化到磁盘</h3><p>事务提交，执行commit redo log 后，会触发redo log buffer 中内容写入到redo log 中。</p><p>为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：</p><ol><li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li><li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li><li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li></ol><p>所以想要确保MySQL异常重启之后redo log 数据不丢失，innodb_flush_log_at_trx_commit 这个参数 建议设置成1.</p><p>前面在binlog部分说到， 在事务提交前，事务binlog 是不会被写入到真正的binlog 文件中的。 redo log 不一样，在事务提交前，redo log 有可能备持久化磁盘。有以下3种情况</p><ol><li>后台线程,每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。，</li><li>redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。</li><li>并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑， 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上未提交事务 在 redo log buffer 里的日志一起持久化到磁盘。<h3 id="233-2pc的细化过程"><a href="#2-3-3-2PC的细化过程" class="headerlink" title="2.3.3 2PC的细化过程"></a>2.3.3 2PC的细化过程</h3></li></ol><h2 id="24-日志文件组"><a href="#2-4-日志文件组" class="headerlink" title="2.4  日志文件组"></a>2.4  日志文件组</h2><p>InnoDB 的 redo log 是以日志文件组的形式组织的。一个日志文件组通常包含两个或更多的日志文件，这些文件在物理上是连续的，并且循环使用。当一个日志文件写满后，InnoDB 会自动切换到下一个日志文件继续写入。当最后一个文件写满后，它会回到第一个文件并开始覆盖旧的日志记录，这就是所谓的“环形写入”。</p><h2 id="25-lsn"><a href="#2-5-LSN" class="headerlink" title="2.5 LSN"></a>2.5 LSN</h2><p>LSN（Log Sequence Number）,日志序列号,是一个不断增长的全局变量， 用来记录当前redo log 文件中 已经写入的日志量， 单位是字节。</p><img src="/6cb5dc64/6.png" class><p>图片中的write pos LSN 指当前已经产生的的日志量，随着更多的事务数据被写入，write pos LSN 会不断增加</p><p>checkpoint LSN 是redo log 中的一个位置，表示所有之前的日志记录都已经被应用（或说是“刷新”）到了磁盘的数据页上，因此，从这个位置以前的日志数据可以安全地被覆写， 不会出现数据丢失的情况。 redo log 会有多个检查点</p><p>write pos LSN 和 checkpoint LSN之间空着的部分，可以用来记录新的操作。</p><p>如果 write pos LSN  赶上了最一个checkpoint  LSN 位置，这意味着 redo log 的空间不足，可能会导致数据库操作停顿，因为系统需要等待足够的日志空间来记录新的事务数据。</p><h2 id="26-组提交"><a href="#2-6-组提交" class="headerlink" title="2.6  组提交"></a>2.6  组提交</h2><p>前面提过，redo log 提升性能，一个是把对磁盘的随机写转换成了顺序写，一个是组提交机制。</p><p>组提交机制（Group Commit）是一种通过合并多个事务的日志提交操作来提高I/O效率的策略。这一机制基于LSN（Log Sequence Number，日志序列号）来追踪和管理日志提交。</p><p>以下图为例解释<br><img src="/6cb5dc64/8.png" class></p><ol><li><strong>事务<code>trx1</code>开始</strong>：<ul><li><code>trx1</code>进入事务队列并被选为组的领导者，日志记录的LSN开始增加。</li></ul></li><li><strong>事务<code>trx2</code>和<code>trx3</code>加入</strong><ul><li>在<code>trx1</code>进入队列之后，<code>trx2</code>和<code>trx3</code>紧随其后进入提交队列。</li></ul></li><li><strong>LSN更新到160</strong>：<ul><li>随着<code>trx2</code>和<code>trx3</code>的日志写入缓冲区，整个组的最后一个日志序列号<code>LSN</code>变为160。</li></ul></li><li><strong>领导者<code>trx1</code>执行写盘</strong>：<ul><li><code>trx1</code>作为组的领导者，携带<code>LSN=160</code>去执行一次性日志写盘（fsync）操作。</li></ul></li><li><strong>写盘完成</strong>：<ul><li><code>trx1</code>的fsync操作完成后，所有<code>LSN &lt;= 160</code>的日志记录都被持久化到磁盘。</li></ul></li><li><strong>事务返回提交成功</strong>：<ul><li><code>trx1</code>、<code>trx2</code>和<code>trx3</code>都标记为提交成功并从提交队列中移除。</li></ul></li></ol><h1 id="3-事务执行过程中的binlog-和redolog-和undo-log"><a href="#3-事务执行过程中的binlog-和redolog-和undo-log" class="headerlink" title="3 事务执行过程中的binlog 和redolog 和undo log"></a>3 事务执行过程中的binlog 和redolog 和undo log</h1><p>下面将结合MySQL 的逻辑架构 和具体SQL , 来具体地看一下binlog 和redo log 的写入</p><img src="/6cb5dc64/9.png" class><p>SQL<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p><p>结果MySQL 的逻辑架构， 该update sql的执行过程如下</p><ol><li>执行器先找InnoDB取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在buffer pool 中，就直接返回给执行器；否则，需要先从磁盘读入buffer pool，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>InnoDB引擎记录该行数据的undo log, 然后新数据更新到内存中，如果数据本来就在内存中，则直接修改数据页，如果不再内存中，则将修改记录在change buffer  中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。</li><li>然后告知执行器执行完成了，随时可以提交事务。执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。根据 innodb_flush_log_at_trx_commit 决定redo log 是否持久化到磁盘</li><li>buffer pool 中对数据页的更新 ,等待脏页刷线操作持久化到磁盘</li></ol><p>14.prepare阶段,将事务的xid写入，将binlog_cache里的进行flush以及sync操作(大事务的话这步非常耗时)<br>15.commit阶段，由于之前该事务产生的redo log已经sync到磁盘了。所以这步只是在redo log里标记commit</p><h1 id="4-崩溃恢复的逻辑"><a href="#4-崩溃恢复的逻辑" class="headerlink" title="4 崩溃恢复的逻辑"></a>4 崩溃恢复的逻辑</h1><p>崩溃恢复过程中，InnoDB 会从最近的 checkpoint LSN开始，应用 redo log 中的更改，直到达到崩溃时的 write pos LSN，以此来恢复数据库到最后一次提交的状态。</p><p>看一下崩溃恢复时的判断规则</p><ol><li>如果 redo log 里面的事务是完整的，则直接提交；</li><li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：<ol><li>如果完整，则提交事务；</li><li>否则，回滚事务。==此处事务回滚基于undo log ==</li></ol></li><li>如果redo log 没有完整的prepare, 则事务基于undo log 回滚</li></ol><p>⚠️说明一下，innodb_flush_log_at_trx_commit  实际上控制了redo prepare 和commit 两个阶段的刷盘策略，比如innodb_flush_log_at_trx_commit  =1 时在 <code>prepare</code> 阶段和 <code>commit</code> 阶段，<code>redo log</code> 都会持久化写入磁盘。所以才会出现第二种磁盘有且只有完整prepare 的情况。</p><p>接下来根据一些具体的问题来详细说明崩溃恢复时的细节</p><h2 id="41-如何判断-redo-log-是完整的"><a href="#4-1-如何判断-redo-log-是完整的" class="headerlink" title="4.1  如何判断 redo log 是完整的"></a>4.1  如何判断 redo log 是完整的</h2><p>redo log commit 阶段会有commit 标识</p><h2 id="42-如果判断binlog-完整性"><a href="#4-2-如果判断binlog-完整性" class="headerlink" title="4.2. 如果判断binlog 完整性"></a>4.2. 如果判断binlog 完整性</h2><p>一个事务的 binlog 是有完整格式的：<br>statement 格式的 binlog，最后会有 COMMIT；<br>row 格式的 binlog，最后会有一个 XID event。</p><h2 id="43-redo-log-和-binlog-是怎么关联起来的"><a href="#4-3-redo-log-和-binlog-是怎么关联起来的" class="headerlink" title="4.3. redo log 和 binlog 是怎么关联起来的"></a>4.3. redo log 和 binlog 是怎么关联起来的</h2><p>在崩溃恢复时，通过读取Redo Log中的Xid，能够将其与Binlog中的Xid进行匹配。</p><p>XID（Transaction Identifier） 可以理解成时MySQL server 层的事务唯一标识。<br>redo log  中会记录XID</p><p>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</p><h2 id="44-为什么要用2pc-协调binlog和redo-log"><a href="#4-4-为什么要用2PC-协调binlog和redo-log" class="headerlink" title="4.4. 为什么要用2PC 协调binlog和redo log"></a>4.4. 为什么要用2PC 协调binlog和redo log</h2><p>类似的问题还有，为什么处于 prepare 阶段的 redo log 加上完整 binlog 就可以提交事务。</p><p>这两个问题本质上都是数据一致性的问题。</p><p>binlog 是server 层日志， 是MySQL 一开始就有的功能，被用在了很多地方，比如备份、主备同步复制。redo log 是InnoDB 层日志，是InnoDB 为了实现事务功能新增的。使用2PC可以维护两份之间的逻辑一致。</p><p>那么，为什么要维护两份日志间的逻辑一致呢。</p><p>binlog 是server 层日志， 是MySQL 一开始就有的功能，被用在了很多地方，比如备份、主备同步复制。redo log 是InnoDB 层日志，是InnoDB 为了实现事务功能新增的。如果两份日志逻辑或者说数据不一致， 那么用日志恢复出来的数据库状态就有可能和它本来应该的状态不一致。</p><p>具体举例来讲，如果不用2PC，两种日志要么是先写 redo log 再写 binlog，或者先写binlog 再写redo log 。<br>仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><ol><li><p>先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p></li><li><p>先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p></li></ol><p>同理，为什么处于 prepare 阶段的 redo log 加上完整 binlog 就可以提交事务。因为如果binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。如果redo log 事务不提交的话，就会发生数据不一致的情况</p><h2 id="45-不要binlog-可以吗"><a href="#4-5-不要binlog-可以吗" class="headerlink" title="4.5. 不要binlog 可以吗"></a>4.5. 不要binlog 可以吗</h2><p>仅从事务持久化/崩溃恢复这个功能来讲， 只要redo log  是可以完成的。<br>但是binlog 作为 MySQL 一开始就有的功能，被用在了很多地方，有redo log 无法替代的功能 。</p><ol><li>归档。redo log 是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log 也就起不到归档的作用。</li><li>主从复制同步</li><li>MySQL 高可用</li><li>在一些业务场景中， 也会使用binlog做数据同步，比如使用canal 同步binlog数据 到ES<h2 id="46-数据一定不会丢失吗-双1-设置"><a href="#4-6-数据一定不会丢失吗-双1-设置" class="headerlink" title="4.6 数据一定不会丢失吗-双1 设置"></a>4.6 数据一定不会丢失吗-双1 设置</h2></li></ol><p>在介绍binlog和redo log 写入过程的时候，有两个参数<br>sync_binlog  控制binlog 持久化到磁盘的频率</p><ol><li>sync_binlog=0 的时候，表示每次提交事务都不主动刷新磁盘，由文件系统自己控制刷盘频率</li><li>sync_binlog=1 的时候，表示每次提交事务都会将 binlog cache 中的内容刷新到磁盘</li><li>sync_binlog=N(N&gt;1) 的时候，表示累积 N 个提交事务后才将多个binlog cache中的内容刷新到磁盘。</li></ol><p>innodb_flush_log_at_trx_commit  控制redo log 持久化到磁盘的频率</p><ol><li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li><li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li><li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li></ol><p>可以看到吗，只有在双1设置的时候，sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1， 才能确保一定不会丢数据</p><p>通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p><p>如果不设置成双1， 有助于提高性能。</p><h1 id="5-binlog-vs-redo-log"><a href="#5-binlog-vs-redo-log" class="headerlink" title="5. binlog vs redo log"></a>5. binlog vs redo log</h1><h4 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h4><ul><li><strong>层级差异</strong>：Binlog 工作在 MySQL 服务器层，所有引擎都可以使用；而 redo log 是 InnoDB 存储引擎层特有的。</li><li><strong>记录形式</strong>：Binlog 可以记录 SQL 语句或行变更，redo log 记录的是数据页的物理变化，即“在某个数据页上做了什么修改”</li><li><strong>目的和用途</strong>：Binlog 主要用于数据复制和崩溃恢复，而 redo log 主要用于事务的持久性和崩溃恢复。</li><li><strong>大小管理</strong>：Redo log 的大小是固定的，循环使用循环写；binlog 是追加写，可以不断增长，需要定期进行清理。</li><li><strong>日志写入</strong>：每个线程都拥有自己一块独立的 binlog cache ， 而 redo log buffer 是全局共用的</li></ul><h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ul><li><strong>事务安全</strong>：两者都是为了保证事务的持久性和原子性。</li><li><strong>恢复支持</strong>：在系统或硬件故障后，两者都能被用来恢复数据。</li><li><strong>写前日志</strong>：都采用了写前日志（write-ahead logging, WAL）的技术，即在实际修改数据库内容前先记录日志。</li><li>从生产到写入磁盘均有内存page - 到page cache - 磁盘，刷新到磁盘的时机均有参数控制</li></ul><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="https://sunyan.xyz/5b064db6/">Intro to 事务</a><br><a href="https://sunyan.xyz/9cd551f5/">Intro to InnoDB 事务</a><br><a href="https://sunyan.xyz/b36b0ce9/">InnoDB事务-原子性的实现,undo log</a><br><a href="https://sunyan.xyz/9faedfe0/">InnoDB事务-隔离性的实现,MVCC &amp; 锁</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在MySQL InnoDB 这个语境下， crash safe、数据不丢失 都指的是事务的持久性特性，即事务一旦提交，应当保证所有被成功提交的数据修改都能够正确地被持久化，不丢失数据, 即使宕机也能够恢复数据&lt;/p&gt;
&lt;p&gt;在InnoDB 中，持久性 基于binlog 和r</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB事务-隔离性的实现, MVCC &amp; 锁</title>
    <link href="http://example.com/9faedfe0/"/>
    <id>http://example.com/9faedfe0/</id>
    <published>2024-05-02T14:42:57.000Z</published>
    <updated>2024-05-10T15:24:50.199Z</updated>
    
    <content type="html"><![CDATA[<p>隔离性，还有一个说法就是 数据可见性。</p><p>隔离性、数据可见性是一个在并发事务下才需要考虑的问题，并发事务可以分3种情况考虑</p><ol><li>读-读， 读操作不会对数据产生影响，所以不需要关注</li><li>读-写 or 写-读， 可能会出现脏读、不可重复读、幻读</li><li>写-写，可能会脏写的情况</li></ol><p>并发事务下的数据的一致性写问题</p><ul><li>脏写：一个事务修改了另一个未提交事务修改过的数据。</li></ul><p>并发事务下的数据的一致性读问题</p><ul><li><strong>脏读</strong>：事务读取了未提交的数据，可能造成数据不一致。</li><li><strong>不可重复读</strong>：事务在内部的多次读取中看到了同一数据的不同版本，主要由于其他事务的更新操作。</li><li><strong>幻读</strong>：事务在两次查询同一个范围时看到了不一样的行，通常是因为其他事务添加或删除了行。</li></ul><p>MySQL  的 4种 事务隔离级别</p><div class="table-container"><table><thead><tr><th>隔离级别</th><th>解决的问题</th><th>未解决的问题</th><th>原理描述</th></tr></thead><tbody><tr><td><strong>读未提交</strong></td><td>无</td><td>脏读、不可重复读、幻读</td><td>允许事务读取其他事务未提交的修改，可能导致脏读。</td></tr><tr><td><strong>读已提交</strong></td><td>脏读</td><td>不可重复读、幻读</td><td>只能看到已经被其他事务提交的数据，避免了脏读，但不能防止在同一事务中看到不一致的数据。</td></tr><tr><td><strong>可重复读</strong></td><td>脏读、不可重复读</td><td>MySQL 在该隔离级别下加上gap 锁可部分解决幻读问题</td><td>在事务开始后所有SELECT操作都看到一致的快照，避免了不可重复读，但无法防止其他事务插入新行（幻读）。</td></tr><tr><td><strong>串行化</strong></td><td>脏读、不可重复读、幻读</td><td>无</td><td>“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。通过强制事务串行执行，防止了脏读、不可重复读和幻读，提供了最高级别的隔离。</td></tr></tbody></table></div><p>由于脏写导致的数据一致性问题非常严重，任何一种隔离级别下都不允许发生，对数据的修改操作必须通过锁串行执行</p><p>InnoDB 在解决 并发事务时，分成两种情况对应不同的解决方案</p><ol><li>快照读-MVCC</li><li>当前读- 锁</li></ol><h1 id="1-快照读的隔离性-mvcc"><a href="#1-快照读的隔离性-MVCC" class="headerlink" title="1 快照读的隔离性-MVCC"></a>1 快照读的隔离性-MVCC</h1><ul><li><strong>一致性视图</strong>：在快照读中，事务会创建一个一致性视图（Consistent Read View），确保当前事务读取到的都是事务开始时的数据状态。它依赖于MVCC的实现。</li><li><strong>无需锁定</strong>：快照读是一种无锁的读取，即读取数据时不需要对行记录进行锁定，因此它不会阻塞事务的读写，同时也不会被其他事务的读写操作阻塞。</li><li><strong>隔离级别影响</strong>：快照读的行为受事务隔离级别的影响，不同的隔离级别会影响读取到的版本。<ul><li>在读未提交隔离级别下，所有事务都读取最新事务；</li><li>在串行化隔离级别下，使用锁控制数据的访问。</li><li>在读已提交和可重复读隔离级别下，使用MVCC 来控制数据的可见性。</li></ul></li></ul><p>InnoDB存储引擎的MVCC（多版本并发控制）机制是基于ReadView和Undo Log共同实现的，关键是通过<code>TRX_ID</code>和<code>ROLL_PTR</code>两个行记录隐藏列来跟踪和管理每一行的修改版本。</p><h2 id="11-版本链-undo-log"><a href="#1-1-版本链-undo-log" class="headerlink" title="1.1 版本链 -undo log"></a>1.1 版本链 -undo log</h2><p>在基于undo log 实现原子性 一文中，可以看到</p><ol><li>行记录中有roll_pointer,</li><li>update 操作中TRX_UNDO_UPD_EXIST_REC 和 TRX_UNDO_DEL_MARK_REC 类型的undo log 中，也有roll_pointer,<br>通过这些roll_pointer, 可以形成一条行记录的版本链。</li></ol><p>insert 操作中，对应的undo log没有roll_pointer 属性，因为insert 操作就是一个行记录的初始版本，没有比它更早的操作了。</p><p>以下是一个通过roll_pointer 组成的版本链，每个undo log 进行了内容省略以展示链接的重点内容</p><img src="/9faedfe0/1.png" class><h2 id="12-readview"><a href="#1-2-readview" class="headerlink" title="1.2 readview"></a>1.2 readview</h2><p>有了版本链，那么该如何判断哪个版本的数据对当前事务可见呢，这里需要引入readview 概念。</p><p>Read View 主要包含以下几个关键的部分：</p><ol><li><strong>m_ids</strong>：当前系统中活跃的事务ID列表。这些事务在生成 Read View 时已经开始但尚未提交。</li><li><strong>min_trx_id</strong>：生成 Read View 时，活跃事务ID中的最小值。这是因为任何 ID 小于此值的事务在 Read View 生成前已经提交。</li><li><strong>max_trx_id</strong>：生成 Read View 时，已知的下一个事务ID。任何大于或等于此 ID 的事务在生成 Read View 后开始的。</li><li><strong>creator_trx_id</strong>：生成这个 Read View 的事务的事务ID。 一个事务只有进行修改操作时，才会被分配trx_id, 否则一个事务的trx_id 默认都是0， 所以 creator_trx_id 也有可能时0</li></ol><p><strong>运作方式</strong>：</p><ul><li>当事务执行查询操作时，它会根据自己的 Read View 来判断数据行的可见性。具体来说，每行数据都有自己的系统版本号（trx_id，即事务ID）。Read View 通过以下逻辑来确定行的可见性：<ol><li>如果行及记录的trx_id  和creator_trx_id 相等，说明当前事务在访问自己修改的数据，数据可见。</li><li>如果行的版本号小于 min_trx_id，说明行是在 Read View 生成之前被创建或最后修改的，因此对当前事务可见。</li><li>如果行的版本号大于或等于 max_trx_id，说明行是在 Read View 生成之后被创建或修改的，因此对当前事务不可见。</li><li>如果行的版本号在 min_trx_id 和 max_trx_id 之间，还需要检查这个版本号是否属于 m_ids 列表中的某个事务：<ul><li>如果属于，说明该行可能由尚未提交的事务修改，对当前事务不可见。</li><li>如果不属于，说明该行由已提交的事务修改，对当前事务可见。</li></ul></li></ol></li></ul><p>如果某个版本的数据对当前事务不可见，那就顺着版本链找洗一个版本的数据，并按照上面的步骤进行判断。如果一个数据直到最后一个版本都不可见，那就说明该条数据对当前事务完全不可见</p><h3 id="121-readview-和-读已提交read-committed"><a href="#1-2-1-readview-和-读已提交（Read-Committed）" class="headerlink" title="1.2.1  readview 和 读已提交（Read Committed）"></a>1.2.1  readview 和 读已提交（Read Committed）</h3><ul><li><strong>生成时机</strong>：在 RC 隔离级别下，Read View 不是在事务开始时生成，而是在一个事务内每次执行 SQL 查询时都会生成新的readview, 所以该事务内是可以看到其他事务已提交的对数据的修改，这在数据一致性上就表现为<code>不可重复读</code></li><li><strong>行为</strong>：每次查询都创建一个新的 Read View，包含当前时刻所有未完成的事务ID。这确保了查询只能看到那些在执行查询前已经提交的事务所做的更改。</li></ul><h3 id="122-readview-和-可重复读repeatable-read"><a href="#1-2-2-readview-和-可重复读（Repeatable-Read）" class="headerlink" title="1.2.2 readview 和 可重复读（Repeatable Read）"></a>1.2.2 readview 和 可重复读（Repeatable Read）</h3><p>InnoDB 的 默认隔离级别。</p><ul><li><strong>生成时机</strong>：在 RR 隔离级别下，Read View 是在事务的第一次查询操作开始时创建的，且在整个事务期间保持不变。这意味着整个事务中所有的查询都将看到相同的数据快照。</li><li><strong>行为</strong>：一旦生成，这个 Read View 将包含事务开始时刻的所有活跃事务ID。无论这些事务后来如何提交或回滚，当前事务的后续查询都不会感知到这些变化。</li></ul><h3 id="123-两者的对比"><a href="#1-2-3-两者的对比" class="headerlink" title="1.2.3 两者的对比"></a>1.2.3 两者的对比</h3><ul><li><strong>数据可见性</strong>：在读已提交中，事务可能看到其他事务提交的更新（即事务中的查询可能返回不同的结果），而在可重复读中，事务保证了始终对数据的一致视图。</li><li><strong>Read View 的生成频率</strong>：读已提交每次查询都重新生成 Read View，而可重复读只在事务开始时生成一次。</li><li><strong>系统开销</strong>：由于读已提交每次查询都需要生成 Read View，可能会有更高的系统开销，尤其是在查询频繁的场景中。相比之下，可重复读的开销主要集中在事务开始阶段。</li></ul><h1 id="2-当前读的隔离型-锁"><a href="#2-当前读的隔离型-锁" class="headerlink" title="2 当前读的隔离型-锁"></a>2 当前读的隔离型-锁</h1><p>当前读指的是读取数据时总是获取数据的最新版本，并通过加锁（行级别的排他锁，S锁或X锁）以确保一致性，防止其他事务修改或删除这些数据。</p><p>当前读通常用于需要修改数据的查询，如</p><ol><li>select…lock in share mode (共享读锁)</li><li>select…for update</li><li>UPDATE</li><li>DELETE</li></ol><p>关于行锁和间隙锁的具体加锁规则，和隔离级别和索引有关，大家可以参考何登成的加锁分析文章<br><a href="https://github.com/hedengcheng/tech/blob/master/database/MySQL/MySQL%20%E5%8A%A0%E9%94%81%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90.pdf">MySQL 加锁分析</a></p><h1 id="3-幻读bad-case"><a href="#3-幻读bad-case" class="headerlink" title="3. 幻读bad case"></a>3. 幻读bad case</h1><p>在前面介绍隔离级别时，提到 在可重复读隔离级别下 加上 间隙锁， 可以一定程度上解决幻觉。<br>但是如果一个事务中 快照读和当前读混用，就会出现幻读bad case.</p><p><a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E5%B9%BB%E8%AF%BB%E8%A2%AB%E5%AE%8C%E5%85%A8%E8%A7%A3%E5%86%B3%E4%BA%86%E5%90%97">幻读被完全解决了吗？</a> 这篇文章中例举两个幻读 bad case,讲的比较清晰，可以参考</p><h1 id="4-当前读vs快照读"><a href="#4-当前读vs快照读" class="headerlink" title="4. 当前读vs快照读"></a>4. 当前读vs快照读</h1><ul><li><strong>快照读（Snapshot Read）</strong>：<ul><li>读取数据时使用的是某一时间点的快照，不会加锁。</li><li>使用MVCC机制，根据事务的隔离级别和版本号返回合适的行版本。</li><li>通常用于<code>SELECT</code>查询。</li></ul></li><li><strong>当前读（Current Read）</strong>：<ul><li>始终读取最新版本的行。</li><li>可能会加锁，防止其他事务修改或删除读取的数据。</li><li>通常用于修改数据的查询操作，如<code>SELECT ... FOR UPDATE</code>、<code>SELECT ... LOCK IN SHARE MODE</code>、<code>UPDATE</code>和<code>DELETE</code>。</li></ul></li></ul><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="https://sunyan.xyz/5b064db6/">Intro to 事务</a><br><a href="https://sunyan.xyz/9cd551f5/">Intro to InnoDB 事务</a><br><a href="https://sunyan.xyz/b36b0ce9/">InnoDB事务-原子性的实现,undo log</a><br><a href="https://sunyan.xyz/6cb5dc64/">InnoDB事务-持久性的实现, binglog &amp; redo log&amp;undo log</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;隔离性，还有一个说法就是 数据可见性。&lt;/p&gt;
&lt;p&gt;隔离性、数据可见性是一个在并发事务下才需要考虑的问题，并发事务可以分3种情况考虑&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读-读， 读操作不会对数据产生影响，所以不需要关注&lt;/li&gt;
&lt;li&gt;读-写 or 写-读， 可能会出现脏读、不</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB事务-原子性的实现,undo log</title>
    <link href="http://example.com/b36b0ce9/"/>
    <id>http://example.com/b36b0ce9/</id>
    <published>2024-05-02T14:22:30.000Z</published>
    <updated>2024-10-26T02:01:11.777Z</updated>
    
    <content type="html"><![CDATA[<p>原子性指的是事务要么完全成功执行，要么完全失败回滚，不允许部分执行。</p><p>这本质上是在要求具有<code>rollback 回滚能力</code>。</p><p>InnoDB中的事务可能会由用户主动触发Rollback；也可能因为遇到死锁异常Rollback；或者发生Crash，重启后对未提交的事务回滚。</p><p>InnoDB 的 rollback回滚能力 是基于 undo log 实现的。undo log 记录了修改操作前的旧版本数据，以便在回滚时恢复数据。</p><h1 id="1-一条-undo-log-的结构"><a href="#1-一条-undo-log-的结构" class="headerlink" title="1  一条 undo log  的结构"></a>1  一条 undo log  的结构</h1><h2 id="11-undo-log-的分类"><a href="#1-1-undo-log-的分类" class="headerlink" title="1.1  undo log 的分类"></a>1.1  undo log 的分类</h2><p>只有在事务中对数据进行修改（如 INSERT、DELETE、UPDATE）的时候， 才需要记录undo log，快照读 select  不需要记录。</p><p>不同的修改操作产生的 <code>undo log</code> 记录的内容和结构会有所不同，因为每种操作对数据的影响不同, 所以undo log 也会有不同的类型。</p><p>InnoDB 的 undo log 主要分为两大类：</p><ol><li><strong>TRX_UNDO_INSERT</strong>：此类主要包括 <code>TRX_UNDO_INSERT_REC</code> 类型的日志，专门用于记录插入操作的撤销信息。</li><li><strong>TRX_UNDO_UPDATE</strong>：此类包括 <code>TRX_UNDO_UPD_EXIST_REC</code> 和 <code>TRX_UNDO_DEL_MARK_REC</code>，用于记录更新存在的记录和标记删除操作的撤销信息。</li></ol><ul><li><strong>共同点</strong>：所有类型的操作都需要且只需要记录<code>足够的信息</code>来逆转所执行的操作。这些记录都存储在 InnoDB 的 undo 表空间或者系统表空间中</li><li><strong>差异</strong>：不同操作类型的 undo 日志记录的具体内容根据操作的性质而异。INSERT 主要关注标记新增行的删除，DELETE 需要记录完整的行数据以便恢复，而 UPDATE 记录修改前的字段值。</li></ul><p>⚠️：对于 undo log 的记录并不是基于每条修改 SQL 语句，而是基于 修改SQL 语句影响的每一条记录。这意味着每条被修改的记录都会有对应的 undo log 。如果一个 SQL 语句影响修改了多行数据，那么将会有多条 undo log 生成。</p><h2 id="12-insert-操作的-undo-log"><a href="#1-2-INSERT-操作的-Undo-log" class="headerlink" title="1.2  INSERT 操作的 Undo log"></a>1.2  INSERT 操作的 Undo log</h2><p>对于 INSERT 操作，undo 日志通常记录较少的信息，主要是把这条记录的主键信息记上。<br><img src="/b36b0ce9/1.png" class></p><h3 id="121-end-of-record-和-start-of-record"><a href="#1-2-1-end-of-record-和-start-of-record" class="headerlink" title="1.2.1 end of record  和 start of record"></a>1.2.1 end of record  和 start of record</h3><p>在InnoDB的undo日志结构中，<code>end of record</code>和<code>start of record</code> 两个字段共同起到链接undo日志记录的作用，使这些记录形成一个双向链表，并提供顺序遍历和反向遍历的功能</p><p><strong>end of record</strong></p><ul><li><strong>定义：</strong><ul><li><code>end of record</code>字段指示当前undo日志记录的结束位置，并提供下一条undo日志记录的起始地址。</li><li>当最后一条undo日志记录没有后继时，则下一条undo日志记录的起始地址为NULL</li></ul></li><li><strong>目的：</strong><ul><li>指向链表中的下一条记录，方便<code>顺序遍历</code>日志记录，可以用于回放或者重做日志，特别是在恢复阶段</li></ul></li></ul><p><strong>start of record</strong></p><ul><li><strong>定义：</strong><ul><li><code>start of record</code>字段指示当前undo日志记录的起始位置，并提供上一条undo日志记录的结束地址。</li><li>如果当前undo日志记录是链表中的第一条，则上一条undo日志记录的结束地址为<code>NULL</code>。</li></ul></li><li><strong>目的：</strong><ul><li>指向链表中的上一条记录，方便<code>反向遍历</code>日志记录，用于事务回滚</li></ul></li></ul><img src="/b36b0ce9/2.png" class><h3 id="122-undo-type"><a href="#1-2-2-undo-type" class="headerlink" title="1.2.2 undo type"></a>1.2.2 undo type</h3><p>该字段指定undo日志记录的类型, 用于区分不同类型的undo操作，如<code>TRX_UNDO_INSERT_REC</code> 、 <code>TRX_UNDO_UPD_EXIST_REC</code> 和 <code>TRX_UNDO_DEL_MARK_REC</code></p><h3 id="123-undo-no"><a href="#1-2-3-undo-no" class="headerlink" title="1.2.3 undo no"></a>1.2.3 undo no</h3><p>日志编号， 在一个事务内从0开始递增，每生成一条日志，undo no 就加1</p><h3 id="124-table-id"><a href="#1-2-4-table-id" class="headerlink" title="1.2.4 table id"></a>1.2.4 table id</h3><p>原始记录所在表的标识符，使undo日志能够与原始记录所在的表关联。</p><h3 id="125"><a href="#1-2-5" class="headerlink" title="1.2.5 "></a>1.2.5 <len, value></len,></h3><p>此部分以<code>&lt;长度，值&gt;</code>的形式保存每个主键列的信息，以便在回滚插入操作时恢复主键值：</p><ol><li>len：表示对应列的存储空间大小。</li><li>value：存储主键的实际值。</li></ol><h2 id="13-delete-操作的-undo-log-标记删除"><a href="#1-3-DELETE-操作的-Undo-log-标记删除" class="headerlink" title="1.3  DELETE 操作的 Undo log-标记删除"></a>1.3  DELETE 操作的 Undo log-标记删除</h2><img src="/b36b0ce9/3.png" class><ol><li>trx_id<br>记录上一个旧版本数据的trx_id,  该值从行记录的隐藏列trx_id 中获取<ul><li><strong>目的：</strong> 在回滚过程中，这个字段可以帮助恢复被删除的记录的原始事务信息，确保在恢复期间不会出现不一致的问题。</li></ul></li><li>roll_pointer<br>记录上一个旧版本数据的roll_pointer,  该值从行记录的隐藏列roll_pointer 中获取<ul><li><strong>描述：</strong> 指向被删除记录的原始回滚指针 (<code>roll_pointer</code>)。</li></ul></li></ol><p>在InnoDB中，每条行记录都有一个位（bit）标记来指示该记录的状态，包括是否已被删除。这是通过记录头（Record Header）中的<code>info bits</code>字段实现的。</p><h3 id="131-标记删除"><a href="#1-3-1-标记删除" class="headerlink" title="1.3.1 标记删除"></a>1.3.1 标记删除</h3><p>TRX_UNDO_DEL_MARK_REC 日志 指的是对记录的逻辑删除，逻辑删除指的是只被标记为删除状态，并不会立即将其物理删除，因为还要支持事务回滚，以及MVCC。</p><p>被标记删除的数据如果真的需要删除，会在适当的时候由后台线程实际清理</p><h3 id="132-行记录的删除标记"><a href="#1-3-2-行记录的删除标记" class="headerlink" title="1.3.2  行记录的删除标记"></a>1.3.2  行记录的删除标记</h3><p>每条行记录的头部都有一个<code>info bits</code>字段，用来存储记录的状态信息，包括是否已被删除。</p><p>在<code>info bits</code>字段的第5个bit位上，标记记录是否已被删除， 当此bit位为<code>1</code>时，表示该记录已被标记删除；为<code>0</code>时，表示该记录是正常的。</p><h2 id="14-update-操作的-undo-log"><a href="#1-4-UPDATE-操作的-Undo-log" class="headerlink" title="1.4 UPDATE 操作的 Undo log"></a>1.4 UPDATE 操作的 Undo log</h2><p>update 的操作 分为两种</p><ol><li><p>不更新主键的update,  这种操作 一条记录 只会TRX_UNDO_UPD_EXIST_REC 一条undo log</p></li><li><p>更新主键的update ，这种update在实际执行时， 会先删除旧记录，再insert 一条新纪录， 所以会记录两条undo log, 一条TRX_UNDO_DEL_MARK_REC， 一条TRX_UNDO_INSERT_REC</p></li></ol><img src="/b36b0ce9/4.png" class><p>具体字段信息和前面两种类似，不再详述。</p><h1 id="2一个事务中的多条undo-log如何组织在一起"><a href="#2一个事务中的多条undo-log如何组织在一起" class="headerlink" title="2一个事务中的多条undo  log如何组织在一起"></a>2一个事务中的多条undo  log如何组织在一起</h1><h2 id="21-undo-page-分类型存储undo-log"><a href="#2-1-undo-page-分类型存储undo-log" class="headerlink" title="2.1 undo page -分类型存储undo log"></a>2.1 undo page -分类型存储undo log</h2><p>InnoDB 对数据的管理是以 <code>page</code> 为单位进行的，undo log 也遵循这一原则，即存储在专门的 undo pages 中。</p><p>每个 undo page 中的日志记录是专用的，不同类型的undo log  不能混着存储， 即一个 page 中不能同时记录 <code>TRX_UNDO_INSERT</code> 类型和 <code>TRX_UNDO_UPDATE</code> 类型的日志。</p><p>这样设计的理由是为了避免在回滚时需要在同一页面上搜索不同类型的日志记录，从而提高了回滚操作的效率。</p><p>可是 一个事务内可以同时存在insert undo log和update undo log, 如果事务需要回滚则所有操作都需要回滚，那为什么还要分开存储呢？</p><ol><li><p><strong>优化事务回滚的逻辑</strong></p><ul><li><strong>操作依赖性减少</strong>：插入操作的回滚仅涉及到删除之前插入的行，而更新或删除操作的回滚需要恢复原始数据。将这些操作的日志分开，可以在回滚时减少对不同类型日志处理逻辑的依赖，使得回滚过程更加模块化和有序。</li><li><strong>执行效率</strong>：分开存储使得处理各自的回滚逻辑时可以更加高效，因为每种类型的回滚处理只需关注其对应类型的日志页。这减少了在单一日志页中搜索和处理不同类型日志的复杂性和时间。</li></ul></li><li><p><strong>并行处理</strong><br>尽管一个事务中可能存在多种类型的 undo 日志，但在并发环境中，不同的回滚任务可能由不同的系统进程或线程处理。例如，某些情况下系统可能并行地处理 <code>insert undo log</code> 和 <code>update undo log</code>。分开存储可以减少锁的竞争和管理的复杂性，提高并发处理的效率。</p></li><li><strong>空间和性能管理</strong><ul><li><strong>简化空间回收</strong>：在事务提交后，<code>insert undo log</code> 可以立即被丢弃和回收，因为插入操作生成的记录一旦提交即视为有效。而 <code>update undo log</code> 可能需要被保留以支持其他事务的一致性读（由于 MVCC）。分开存储使得空间管理更为高效，因为可以针对性地处理和回收日志空间。</li><li><strong>优化读取性能</strong>：在事务处理过程中，尤其是在一些只涉及到特定类型操作的查询或回滚操作中，分开存储可以优化日志的读取性能，因为系统可以直接定位到相关类型的日志页。</li></ul></li><li><strong>日志维护的简化</strong><ul><li>分开存储有助于简化日志维护和日志生命周期管理。系统可以更容易地追踪和管理不同类型日志的生成、使用和清理周期。</li></ul></li></ol><h2 id="22-undo-page-链表"><a href="#2-2-undo-page-链表" class="headerlink" title="2.2 undo page 链表"></a>2.2 undo page 链表</h2><p>在一个事务中，可能会产生多条 undo log。</p><p>如果一个 undo page 填满了，事务会向系统申请新的undo page,并将其通过链表（通常是使用类似于前驱（previous）和后继（next）指针的机制）连接起来。</p><p>前面提到过，一个 undo page 不能混合存储不能类型的链接， 所以对于一个事务它可以有insert undo page 和update undo page 两个链表。</p><p>每个事务都会分配单独的页面链表。</p><img src="/b36b0ce9/5.png" class><p>下面简单介绍下链表中第一个 undo page</p><ol><li><p>file header 如前面介绍，会有一个字段来标识该page 是undo page, 用来存储undo log。</p></li><li><p>undo page header 会记录该页面存储的undo log 类型， insert or update</p></li><li><p>undo log segment header , 会记录该链表所属的segment</p></li><li><p>undo log header ,理论上，每个事务都会分配自己的页面链表， 但如果一个事务产生的undo log很少，那么这个页面链表就有可能被重用。所以实际上一个页面链表中实际可能存储多个事务的undo log,  undo log header  中记录了不同事务间日志的分隔信息。</p></li></ol><h2 id="23-回滚段"><a href="#2-3-回滚段" class="headerlink" title="2.3 回滚段"></a>2.3 回滚段</h2><p>InnoDB默认创建128个回滚段（Rollback Segments），用于管理undo日志。</p><ul><li><strong>元数据存储：</strong> 每个回滚段的元数据存储在系统表空间第5号页面中。</li><li><strong>Slot结构</strong>：每个回滚段包含1024个<code>slot</code>，每个<code>slot</code>可以映射到一个Undo页。</li><li><strong>事务与回滚段的关联：</strong> 事务会在需要的时候分配一个回滚段。</li><li><strong>轮询策略：</strong> InnoDB使用轮询方式将回滚段分配给新事务，以实现负载均衡。</li></ul><h2 id="24-undo页链表的形成与维护"><a href="#2-4-Undo页链表的形成与维护" class="headerlink" title="2.4  Undo页链表的形成与维护"></a>2.4  Undo页链表的形成与维护</h2><ol><li><strong>事务开始：</strong><ul><li>新的事务开始时，会分配一个插入段和一个更新段。</li><li>在分配的回滚段头页中，初始化undo页链表的头指针和尾指针。</li></ul></li><li><strong>查找可用的Slot：</strong><ul><li>事务在开始写入undo日志时，会首先查找一个可用的<code>slot</code>，并初始化一个新的undo页链表。</li></ul></li><li><strong>分配新的Undo页：</strong><ul><li>分配新的undo页，将其添加到undo页链表的末尾。</li><li>如果这是链表的第一个undo页，回滚段头页的<code>first</code>指针和<code>last</code>指针会同时指向该页。</li></ul></li><li><strong>维护Undo页链表：</strong><ul><li>当undo页链表中的最后一个undo页已满时，分配一个新的undo页并链接到链表的末尾。</li><li>回滚段头页的<code>last</code>指针会指向新分配的undo页。</li><li>新undo页的<code>prev</code>指针指向链表的前一个undo页，形成链表结构。</li></ul></li></ol><h1 id="3-行记录如何与undo-log-关联-roll_pointer"><a href="#3-行记录如何与undo-log-关联-roll-pointer" class="headerlink" title="3 行记录如何与undo log 关联 -roll_pointer"></a>3 行记录如何与undo log 关联 -roll_pointer</h1><img src="/b36b0ce9/6.png" class><p><code>roll_pointer</code> 是存储在每个行记录中的一个指针，指向该行记录相关的最近一次undo log 记录。</p><p>注意这个undo 记录指的是具体的 undo log，而不是整个页面链表。</p><img src="/b36b0ce9/7.png" class><ul><li>当行记录被修改（包括更新、删除或作为多步操作的一部分的插入）时，InnoDB 首先会在 undo 日志中写入一条记录，这条记录包含了行修改前的数据，和行记录中的的roll_pointer,</li><li>InnoDB 更新行记录中的 <code>roll_pointer</code>，使其指向新写入的 undo 日志记录。如果这个行再次被修改，新的 undo 日志将被写入，<code>roll_pointer</code> 会更新为指向这条新的记录。新的undo 日志中会记录之前的roll_pointer</li></ul><h1 id="4-一条记录的版本链如何形成"><a href="#4-一条记录的版本链如何形成" class="headerlink" title="4. 一条记录的版本链如何形成"></a>4. 一条记录的版本链如何形成</h1><p>InnoDB 通过 roll_ptr 把每一行的历史版本串联在一起</p><ol><li>行记录中有roll_pointer,</li><li>update 操作中TRX_UNDO_UPD_EXIST_REC 和 TRX_UNDO_DEL_MARK_REC 类型的undo log 中，也有roll_pointer,<br>通过这些roll_pointer, 可以形成一条行记录的版本链。</li></ol><p>insert 操作中，对应的undo log没有roll_pointer 属性，因为insert 操作就是一个行记录的初始版本，没有比它更早的操作了。</p><p>以下是一个通过roll_pointer 组成的版本链，每个undo log 进行了内容省略以展示链接的重点内容</p><img src="/b36b0ce9/8.png" class><h1 id="5-undo-log-的持久化"><a href="#5-undo-log-的持久化" class="headerlink" title="5. undo log 的持久化"></a>5. undo log 的持久化</h1><p>undo日志刷盘时机的参数，但通过控制Redo日志、脏页刷新和Purge线程的参数，可以间接影响undo日志的刷盘策略。</p><p><strong>WAL技术</strong><br>在数据实际修改前，先将undo日志持久化到磁盘。</p><p><strong>刷盘时机：</strong></p><ul><li><strong>事务提交：</strong> 当事务提交时，相关的undo日志会被写入磁盘。</li><li><strong>脏页刷盘：</strong> 在InnoDB将脏页（dirty page）写入磁盘之前，首先会确保所有相关的undo日志已经被持久化。</li><li><strong>Redo日志同步：</strong> 当一个Redo日志被同步到磁盘时，所有相关的undo日志也必须被同步。</li></ul><h1 id="6-基于undo-log-的回滚操作"><a href="#6-基于undo-log-的回滚操作" class="headerlink" title="6 基于undo log 的回滚操作"></a>6 基于undo log 的回滚操作</h1><p>InnoDB中的事务</p><ol><li>可能会由用户主动触发Rollback；</li><li>也可能因为遇到死锁异常Rollback；</li><li>或者发生Crash，重启后对未提交的事务回滚。</li></ol><h2 id="61-用户应用程序主动回滚"><a href="#6-1-用户-应用程序主动回滚" class="headerlink" title="6.1. 用户/应用程序主动回滚"></a>6.1. 用户/应用程序主动回滚</h2><ul><li>反向遍历（start of record）当前事务的undo日志链表，按逆序恢复每个更改。</li><li><strong>插入操作：</strong> 在数据页中删除已插入的记录。</li><li><strong>删除操作：</strong> 恢复已删除的记录。</li><li><strong>更新操作：</strong> 恢复更新前的记录。</li><li>每个操作恢复完成后，从undo日志链表中移除相应的undo日志记录。</li></ul><h2 id="62-死锁异常回滚"><a href="#6-2-死锁异常回滚" class="headerlink" title="6.2. 死锁异常回滚"></a>6.2. 死锁异常回滚</h2><p>InnoDB通过死锁检测算法发现两个或多个事务之间的锁等待，形成死锁，,选择最小代价，即持有锁资源最少的事务务进行回滚。</p><p>与主动回滚类似，遍历当前事务的undo日志链表，按逆序恢复每个更改。</p><h2 id="63-崩溃恢复"><a href="#6-3-崩溃恢复" class="headerlink" title="6.3  崩溃恢复"></a>6.3  崩溃恢复</h2><p>MySQL服务器或操作系统崩溃后，InnoDB通过Undo日志与Redo日志结合，确保崩溃时数据页的状态恢复到一致的状态， undo日志用来 回滚未提交的事务。</p><h1 id="7-undo-log-的清理"><a href="#7-undo-log-的清理" class="headerlink" title="7 undo log 的清理"></a>7 undo log 的清理</h1><p>事务提交后，相关的Undo日志记录仍需保留一段时间以支持多版本并发控制（MVCC）</p><h2 id="71-purge-线程"><a href="#7-1-Purge-线程" class="headerlink" title="7.1 Purge 线程"></a>7.1 Purge 线程</h2><p>InnoDB 通过一个后台线程称为 Purge，来清理不再需要的 undo log。</p><ul><li><strong>触发条件</strong>：Purge 进程会定期检查那些已提交事务的 undo log。它会确定这些 undo log 是否还被其他活跃事务作为 MVCC 的一部分所需。</li><li><strong>删除操作</strong>：如果一个 undo log 记录不再被任何事务所需要，Purge 进程会将其从 undo 表空间中删除，释放相关资源。</li></ul><p>undo log 的清理机制是区分操作类型的。</p><h2 id="72-insert-undo-log"><a href="#7-2-Insert-Undo-Log" class="headerlink" title="7.2 Insert Undo Log"></a>7.2 Insert Undo Log</h2><p>Insert undo log 主要记录插入操作的信息。因为插入操作仅仅添加新的记录，不涉及已存在数据的修改，所以这种类型的 undo log 主要用于在事务失败时撤销插入操作。</p><ul><li><strong>清理时机</strong>：当一个事务进行插入操作并成功提交后，相应的 insert undo log 立即变得无用，因为插入的数据已经被确认并不需要再被撤销。此时，这些 undo log 可以被安全地清理掉，因为它们不再被任何事务所需。</li><li><strong>清理过程</strong>：Purge 线程会检测到这些 insert undo log 与已提交的事务关联，并将它们标记为可清理。然后，这些 log 会从 undo 表空间中删除，相关的磁盘空间得以回收。</li></ul><h2 id="73-update-undo-log"><a href="#7-3-Update-Undo-Log" class="headerlink" title="7.3 Update Undo Log"></a>7.3 Update Undo Log</h2><p>Update undo log 记录了对现有数据的修改（包括更新和删除操作）。这些记录对于事务回滚和多版本并发控制（MVCC）至关重要。</p><ul><li><strong>清理时机</strong>：与 insert undo log 不同，即使相关事务已经提交，update undo log 也不能立即被清理。这是因为在 InnoDB 中实现 MVCC 时，其他并发事务可能需要访问这些 log 中的旧数据版本来维持一致性读。</li><li><strong>清理过程</strong>：Purge 线程会周期性地检查 update undo log。只有当这些 log 记录不再被任何其他活跃事务所需时（即没有更早的读视图需要这些数据），它们才会被标记为可清理。然后，Purge 操作会逐步从 undo 表空间中删除这些记录。</li></ul><h2 id="74-长事务对undo-log-清理的影响"><a href="#7-4-长事务对undo-log-清理的影响" class="headerlink" title="7.4 长事务对undo log 清理的影响"></a>7.4 长事务对undo log 清理的影响</h2><p>长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。</p><h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a href="https://sunyan.xyz/5b064db6/">Intro to 事务</a><br><a href="https://sunyan.xyz/9cd551f5/">Intro to InnoDB 事务</a><br><a href="https://sunyan.xyz/9faedfe0/">InnoDB事务-隔离性的实现,MVCC &amp; 锁</a><br><a href="https://sunyan.xyz/6cb5dc64/">InnoDB事务-持久性的实现,binglog &amp; redo log&amp;undo log</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;原子性指的是事务要么完全成功执行，要么完全失败回滚，不允许部分执行。&lt;/p&gt;
&lt;p&gt;这本质上是在要求具有&lt;code&gt;rollback 回滚能力&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;InnoDB中的事务可能会由用户主动触发Rollback；也可能因为遇到死锁异常Rollback；或</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Intro to InnoDB事务</title>
    <link href="http://example.com/9cd551f5/"/>
    <id>http://example.com/9cd551f5/</id>
    <published>2024-05-02T14:15:42.000Z</published>
    <updated>2024-05-10T15:17:42.616Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://sunyan.xyz/5b064db6/">Intro to 事务中</a>介绍过， 一致性是事务的核心特征，或者说最终目的，<code>原子性、隔离性和持久性都是实现一致性的手段</code>。</p><p>所以在介绍InnoDB 事务时，主要介绍AID 特性的实现<br><a href="https://sunyan.xyz/b36b0ce9/">InnoDB事务-原子性的实现， undo log</a><br><a href="https://sunyan.xyz/9faedfe0/">InnoDB事务-隔离性的实现, MVCC &amp; 锁</a><br><a href="https://sunyan.xyz/6cb5dc64/">InnoDB事务-持久性的实现， binglog &amp; redo log&amp;undo log</a></p><p>在具体看InnoDB 事务实现AID 特性之前，可以先看以下这些前置知识</p><h1 id="1-innodb-数据管理"><a href="#1-InnoDB-数据管理" class="headerlink" title="1. InnoDB 数据管理"></a>1. InnoDB 数据管理</h1><h2 id="11-page"><a href="#1-1-Page" class="headerlink" title="1.1 Page"></a>1.1 Page</h2><p>page 是 InnoDB 存储数据的基本单位，也是数据在磁盘和内存之间交换的最小单位。每个页通常的大小为 16KB<br>针对不同的数据有不同的Page类型进行存储，如index page 索引页， undo page  等</p><ol><li>File Header 中 有fil_page_type 来标识该页的类型</li><li>File Trailer 用来校验页面数据是否完成 <img src="/9cd551f5/1.png" class></li></ol><h2 id="12-区extent"><a href="#1-2-区（extent）" class="headerlink" title="1.2 区（extent）"></a>1.2 区（extent）</h2><p>为了更好地管理page, InnoDB引入了区的概念， 连续的64个page  是一个区，大小默认是1MB。 可以认为extent 是一个物理上概念</p><p>一个区（Extent）是由连续的页组成的数据块，每个区包含 64 个连续的页，因此每个区的大小为 1MB （16KB * 64）。使用区的目的是为了优化磁盘空间的分配和管理，通过批量处理连续的页,减少随机IO来提高数据存取效率。</p><h2 id="13-段-segment"><a href="#1-3-段-（segment-）" class="headerlink" title="1.3 段 （segment ）"></a>1.3 段 （segment ）</h2><p>InnoDB 中的段（Segment）作为一个逻辑结构，起着将数据库的高层逻辑结构（如表和索引）与低层物理存储结构（如页和区）连接起来的桥梁作用。</p><p>以下是几个详细的例子，通过这些例子可以更好地理解段是如何在数据库管理系统中发挥作用的。</p><h3 id="131-数据表段"><a href="#1-3-1-数据表段" class="headerlink" title="1.3.1 数据表段"></a>1.3.1 数据表段</h3><p>假设您在数据库中创建了一个新表，这个表将需要存储数据行。InnoDB 会为这个表创建一个数据段：</p><ul><li><strong>逻辑层面</strong>：在逻辑层面，这个数据段代表了表中所有数据行的集合。</li><li><strong>物理层面</strong>：物理上，这个数据段开始时可能只包含几个区，每个区由 64 个连续的页组成。随着表中数据的增加，段可以动态地分配更多的区来存储更多的数据页。</li><li><strong>操作</strong>：当你执行 INSERT 操作向表中添加数据时，InnoDB 将在这个数据段中找到适当的页来存储新的行。如果必要的页不存在或页已满，段管理逻辑将请求分配新的区，并继续数据插入。</li></ul><h3 id="132-索引段"><a href="#1-3-2-索引段" class="headerlink" title="1.3.2 索引段"></a>1.3.2 索引段</h3><p>当你为表创建一个索引时，无论是主键索引还是辅助索引，InnoDB 都会为每个索引创建一个单独的索引段：</p><ul><li><strong>逻辑层面</strong>：索引段逻辑上表示索引的结构，这包括维护键值和指向表中对应行的指针。</li><li><strong>物理层面</strong>：物理上，索引段存储索引树（B-tree）的结构，其中每个节点（或页）包含索引键和指向行的指针。随着索引的增长，可能需要更多的页和区来扩展索引树。</li><li><strong>操作</strong>：进行查询优化时，如执行基于索引的查找，InnoDB 通过索引段快速访问相关页，有效地定位到数据行。</li></ul><h3 id="133-undo-日志段"><a href="#1-3-3-Undo-日志段" class="headerlink" title="1.3.3 Undo 日志段"></a>1.3.3 Undo 日志段</h3><p>Undo 日志也是使用段来管理的，每当数据被修改时，修改前的数据将存储在 undo 日志段中：</p><ul><li><strong>逻辑层面</strong>：逻辑上，undo 日志段保存了数据修改前的状态，支持事务的回滚操作。</li><li><strong>物理层面</strong>：物理上，undo 日志段由一系列的页组成，这些页按需分配，并在事务回滚时提供必要的历史数据。</li><li><strong>操作</strong>：如果事务失败或执行 ROLLBACK 命令，InnoDB 通过访问 undo 日志段中的记录来恢复数据到其原始状态。</li></ul><h2 id="14-表空间tablespace"><a href="#1-4-表空间（Tablespace）" class="headerlink" title="1.4 表空间（Tablespace）"></a>1.4 表空间（Tablespace）</h2><p>表空间是 InnoDB 数据存储的最高层级，它可以包含多个段。表空间是磁盘上的物理文件，可以看作是一个容器，内部组织着数据库的数据和索引。InnoDB 默认有一个主表空间，即 <code>ibdata</code> 文件，它包含了系统数据、数据字典、undo 日志等。此外，InnoDB 还支持每个表使用单独的文件作为独立表空间（file-per-table），这有助于数据库的扩展和管理。</p><h1 id="2行记录格式"><a href="#2-行记录格式" class="headerlink" title="2.行记录格式"></a>2.行记录格式</h1><p>数据表中的行存放在 数据page  中， 以compact 行格式为例， 每一条数据记录的存储格式如下，<br>    <img src="/9cd551f5/2.png" class></p><p>其中真实数据部分，除了数据表中定义的列之外，InnoDB 会默认为每条记录添加隐藏列</p><div class="table-container"><table><thead><tr><th>列名</th><th>是否必须</th><th>占据空间</th><th>描述</th></tr></thead><tbody><tr><td>row_id</td><td>否</td><td>6 字节</td><td>行ID，唯一标识一条记录</td></tr><tr><td>trx_id</td><td>是</td><td>6 字节</td><td>事务ID</td></tr><tr><td>roll_pointer</td><td>是</td><td>7 字节</td><td>回滚指针</td></tr></tbody></table></div><img src="/9cd551f5/3.png" class><p><code>roll_pointer</code> 是存储在每个行记录中的一个指针，指向该行记录相关的最近一次undo log 记录。<br><code>trx_id</code> 是 InnoDB 存储引擎内部用来唯一标识每个事务的标识符，它记录了最近修改该记录的事务。</p><h1 id="3-innodb-事务trx_id"><a href="#3-InnoDB-事务trx-id" class="headerlink" title="3. InnoDB 事务trx_id"></a>3. InnoDB 事务trx_id</h1><p><code>trx_id</code> 是 InnoDB 存储引擎内部用来唯一标识每个事务的标识符。这个事务ID是一个递增的数字，由 InnoDB 内部自动生成和管理。</p><p>trx_id 存储在行记录的隐藏列中。</p><p>MySQLserver 层也有一个事务唯一标识叫XID。</p><p>InnoDB 内部维护了一个 max_trx_id 全局变量，每次需要申请一个新的 trx_id 时，就获得 max_trx_id 的当前值，然后并将 max_trx_id 加 1。</p><p>功能和作用</p><ol><li><strong>事务的唯一标识</strong>：<code>trx_id</code> 为 InnoDB 提供了一种方式来唯一地识别和跟踪每个活动的或已完成的事务。</li><li><strong>多版本并发控制（MVCC）</strong>：在 InnoDB 的 MVCC 实现中，<code>trx_id</code> 被用来标记每条记录的版本，以此来支持事务的隔离级别。不同事务看到的数据视图依赖于记录的 <code>trx_id</code> 与事务的 <code>trx_id</code> 比较。</li><li><strong>回滚和恢复</strong>：在事务处理过程中，如果需要回滚，InnoDB 通过 <code>trx_id</code> 来确定哪些更改需要被撤销。此外，在系统崩溃后的恢复过程中，<code>trx_id</code> 也被用来重建活跃事务的状态。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在&lt;a href=&quot;https://sunyan.xyz/5b064db6/&quot;&gt;Intro to 事务中&lt;/a&gt;介绍过， 一致性是事务的核心特征，或者说最终目的，&lt;code&gt;原子性、隔离性和持久性都是实现一致性的手段&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以在介绍InnoDB 事</summary>
      
    
    
    
    
    <category term="MySQL" scheme="http://example.com/tags/MySQL/"/>
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Intro to 事务</title>
    <link href="http://example.com/5b064db6/"/>
    <id>http://example.com/5b064db6/</id>
    <published>2024-05-01T13:57:16.000Z</published>
    <updated>2024-05-08T14:05:03.875Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-什么是事务"><a href="#1-什么是事务" class="headerlink" title="1. 什么是事务"></a>1. 什么是事务</h1><p>事务（Transaction）的概念起源于数据库领域，最早由美国计算机科学家 E. F. Codd 在其关于关系数据库（Relational Database）的论文中提出。</p><p>他提出了 ACID（原子性、一致性、隔离性和持久性）属性，这些属性成为事务的核心特征。</p><p>在今天的软件开发中，事务的概念已不仅仅应用于数据库领域，还拓展到了业务开发的各个领域，包括但不限于数据库、缓存、消息队列等。</p><h2 id="11-acid-特性"><a href="#1-1-ACID-特性" class="headerlink" title="1.1 ACID 特性"></a>1.1 ACID 特性</h2><ul><li>原子性(Atomicity):  保证事务中的所有操作要么全部完成，要么全部不发生，有助于处理系统错误或故障时的数据恢复，确保事务执行的完整性。</li><li>一致性(Consistency)：系统从一个正确态转移到另一个正确态，由应用通过 AID 来保证，可以说是事务的核心特性</li><li>隔离性(Isolation): 处理并发事务带来的各种问题，确保每个事务看到的是一致的数据视图，防止交叉事务的干扰。</li><li>持久性(Durability): 确保事务一旦提交，其结果就就会被持久化，这保证了数据的稳定性和可靠性。</li></ul><p>定义本身不再赘述，这里重点强调一点：一致性是事务的核心特征，或者说最终目的。<code>原子性、隔离性和持久性都是实现一致性的手段</code>，因此这 4 个特性并不是并列关系。</p><h1 id="2-事务的分类"><a href="#2-事务的分类" class="headerlink" title="2. 事务的分类"></a>2. 事务的分类</h1><p>下面将把事务按照服务和数据源数量进行分类，这种分类有助于理解事务管理的复杂性以及在不同场景下的设计和实现。</p><h2 id="21-本地事务-单服务单数据源事务"><a href="#2-1-本地事务-单服务单数据源事务" class="headerlink" title="2.1  本地事务-单服务单数据源事务"></a>2.1  本地事务-单服务单数据源事务</h2><p>在实际业务开发中，单个服务操作单个数据源的事务被归类为本地事务。这种事务类型是最简单的，因为它直接依赖于数据库本身的事务能力来完成，应用无需进行额外操作</p><p><strong>示例：</strong><br>库存服务：当用户下单时，库存服务负责检查和更新商品库存。这个服务可能只与一个库存数据库交互，进行减库存的操作。如果库存足够，事务提交，否则回滚。这个操作只涉及库存数据库，因此是一个典型的本地事务。</p><h2 id="2-2-分布式事务"><a href="#2-2-分布式事务" class="headerlink" title="2. 2 分布式事务"></a>2. 2 分布式事务</h2><p>分布式事务可以从跨多个数据源的事务和跨多个服务的事务两个角度理解。它既可以是多个数据库实例之间的分布式事务，也可以是跨不同中间件的业务层面分布式事务。</p><h3 id="221-单服务多数据源"><a href="#2-2-1-单服务多数据源" class="headerlink" title="2.2.1 单服务多数据源"></a>2.2.1 单服务多数据源</h3><p>这种情况通常发生在单个应用或服务需要同时操作多个数据库或存储系统。</p><p>例如，一个电子商务应用可能需要在处理订单的同时，在一个数据库中更新库存信息，在另一个数据库中更新用户账户信息。这要求事务管理机制能够跨越这些数据库，确保所有数据库操作要么全部成功，要么全部失败，以保证数据的一致性</p><p>在这种场景下，可以使用如XA协议这样的分布式事务协议，通过2PC等机制来协调和管理跨多个数据源的事务。</p><h3 id="222-多服务多数据源"><a href="#2-2-2-多服务多数据源" class="headerlink" title="2.2.2 多服务多数据源"></a>2.2.2 多服务多数据源</h3><p>随着微服务架构的发展，单个业务操作往往需要多个微服务协作完成，而这些服务可能各自使用独立的数据库。例如，在电商下单过程中，订单服务、库存服务、账务服务、物流服务和优惠服务需要协同处理同一业务请求，并进行交互和数据更新。</p><p>在这种场景下，分布式事务的管理比单个服务场景更为复杂，因为它不仅涉及数据一致性，还涉及网络调用的可靠性和服务间的协调。这类分布式事务通常可以通过可靠消息队列、TCC 和 SAGA 等模式来实现。</p><h2 id="23-共享事务-多服务单数据源"><a href="#2-3-共享事务-多服务单数据源" class="headerlink" title="2.3 共享事务-多服务单数据源"></a>2.3 共享事务-多服务单数据源</h2><p>在微服务架构下，通常不允许多服务共享同一数据源。理想的微服务架构是每个微服务都有其专属数据库（即服务与数据源一一对应），这种设计被称为数据库隔离。</p><p>因此，本文及本系列不会涉及该类型事务。</p><h1 id="3-两种分布式事务的区别"><a href="#3-两种分布式事务的区别" class="headerlink" title="3. 两种分布式事务的区别"></a>3. 两种分布式事务的区别</h1><p>在事务分类中，<code>单服务多数据源</code> 和 <code>多服务多数据源</code> 都被归类为分布式事务，那么这两种分布式事务有什么区别呢？</p><p>首先，单服务多数据源事务是多个数据库实例之间的分布式事务， 也被称为全局事务。当它被称为分布式事务时，这里的“分布式”是相对于数据源而言的，并不涉及服务。</p><p>而多服务多数据源事务是跨不同中间件的业务层面分布式事务。</p><p>这两种分布式事务的一个重要区别在于一致性的实现方式不同：</p><ul><li>单服务多数据源事务通常可以追求 <strong>强一致性</strong>。</li><li>多服务多数据源事务由于其复杂性和分布式特性，通常只能追求 <strong>最终一致性</strong>。</li></ul><p>下面将详细解释这两种情况及其原因。</p><h2 id="31-单服务多数据源-与-强一致性"><a href="#3-1-单服务多数据源-与-强一致性" class="headerlink" title="3.1 单服务多数据源 与 强一致性"></a>3.1 单服务多数据源 与 强一致性</h2><p>在单服务多数据源的场景中，尽管涉及多个数据源，但所有操作都由一个单一服务控制。这种配置允许使用两阶段提交（2PC）等传统的分布式事务协议来确保强一致性，即在任何时刻，所有数据源都能反映出相同的事务状态。</p><p><strong>为什么可以实现强一致性：</strong></p><ul><li><strong>集中式协调</strong>：单个服务可以作为事务的中央协调者，管理所有数据源的事务提交或回滚。</li><li><strong>锁定资源</strong>：事务处理过程中可以在各个数据源上锁定必要的资源，直到事务完成，确保事务的原子性和一致性。</li><li><strong>同步更新</strong>：所有数据源的更新操作可以同步进行，确保在事务提交时，所有的变更都能一次性反映出来。</li></ul><h2 id="32-多服务多数据源-与-最终一致性"><a href="#3-2-多服务多数据源-与-最终一致性" class="headerlink" title="3.2 多服务多数据源 与 最终一致性"></a>3.2 多服务多数据源 与 最终一致性</h2><p>多服务多数据源事务涉及多个独立的服务，每个服务可能管理自己的数据源。在这种架构下，实现强一致性变得非常复杂和成本高昂，因此通常采用最终一致性模型。</p><p><strong>为什么通常只能实现最终一致性：</strong></p><ul><li><strong>服务自治</strong>：每个服务都是自治的，独立管理自己的数据源，它们之间的通信可能是异步的，不能立即反映其他服务的状态变更。</li><li><strong>复杂的协调机制</strong>：需要跨服务协调复杂的事务可能涉及网络延迟和服务间通信失败，使得同步更新所有数据源变得不切实际。</li><li><strong>使用补偿事务</strong>：多服务事务常采用如SAGA等模式，通过一系列的本地事务和补偿事务来处理业务流程，每个事务独立提交，仅通过补偿机制来撤销错误操作，逐步达到数据的一致性。</li></ul><h1 id="4-强一致性-vs-最终一致性"><a href="#4-强一致性-vs-最终一致性" class="headerlink" title="4.  强一致性 vs 最终一致性"></a>4.  强一致性 vs 最终一致性</h1><h2 id="41-一致性的分类"><a href="#4-1-一致性的分类" class="headerlink" title="4.1 一致性的分类"></a>4.1 一致性的分类</h2><h3 id="411-强一致性strong-consistency"><a href="#4-1-1-强一致性（Strong-Consistency）" class="headerlink" title="4.1.1 强一致性（Strong Consistency）"></a>4.1.1 强一致性（Strong Consistency）</h3><p><strong>强一致性</strong>意味着系统在更新数据后，任何随后的访问都将立即看到这一更新。在强一致性模型中，所有节点上的数据在任何时间点都是一致的。这通常要求在数据更新过程中进行严格的协调，确保所有副本在继续操作前都同步更新。</p><p><strong>优点：</strong></p><ul><li>数据一致性和用户体验最为理想。</li><li>易于理解和使用，因为它模拟了单个系统的行为。</li></ul><p><strong>缺点：</strong></p><ul><li>可能严重影响系统的可用性和性能，尤其在网络延迟较高的情况下。</li><li>在 CAP 定理中，通常需要在遇到网络分区时牺牲可用性。<h3 id="412-线性一致性linearizability"><a href="#4-1-2-线性一致性（Linearizability）" class="headerlink" title="4.1.2 线性一致性（Linearizability）"></a>4.1.2 线性一致性（Linearizability）</h3></li></ul><p>线性一致性是强一致性的一个特例，它不仅保证所有节点看到相同的数据，还要求系统表现得就像所有操作都是顺序发生的。这意味着如果操作A在操作B之前完成，那么系统中的所有节点都应该首先看到A的结果，然后是B的结果。<br><strong>优点</strong>：</p><ul><li>提供了强一致性的最高标准，适用于需要严格数据顺序的应用。</li><li>简化了系统的编程模型。<br><strong>缺点</strong>：</li><li>对系统性能和可用性的影响比一般的强一致性还要大。</li></ul><h3 id="413-弱一致性weak-consistency"><a href="#4-1-3-弱一致性（Weak-Consistency）" class="headerlink" title="4.1.3 弱一致性（Weak Consistency）"></a>4.1.3 弱一致性（Weak Consistency）</h3><p>弱一致性不保证在数据更新后立即反映这一变化。在更新操作和其影响被所有用户观察到之间，存在一个不确定的时间窗口。这种模型通常用于对实时一致性要求不高的系统。<br><strong>优点</strong>：</p><ul><li>提高了系统的可用性和性能。</li><li>在处理高并发操作时更加有效。<br><strong>缺点</strong>：</li><li>用户可能会读到旧数据。</li><li>应用逻辑可能需要处理数据不一致的问题。<h3 id="414-最终一致性eventual-consistency"><a href="#4-1-4-最终一致性（Eventual-Consistency）" class="headerlink" title="4.1.4  最终一致性（Eventual Consistency）"></a>4.1.4  最终一致性（Eventual Consistency）</h3></li></ul><p>最终一致性保证，在没有新的更新的情况下，所有的数据副本最终将会是一致的。系统不保证达到一致状态的具体时间。<br><strong>优点</strong>：</p><ul><li>高度可用和可扩展。</li><li>适用于分布广泛的系统，可以容忍数据在短时间内的不一致。<br><strong>缺点</strong>：</li><li>应用需要能够处理数据一段时间内的不一致。</li><li>开发者需要设计有效的数据同步和冲突解决策略。<h2 id="42-cap-与-acid的微妙平衡-分布式系统只能追求最终一致性"><a href="#4-2-CAP-与-ACID的微妙平衡-分布式系统只能追求最终一致性" class="headerlink" title="4.2  CAP 与 ACID的微妙平衡-分布式系统只能追求最终一致性"></a>4.2  CAP 与 ACID的微妙平衡-分布式系统只能追求最终一致性</h2></li></ul><p>根据 CAP 定理，一个分布式系统不可能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition Tolerance）三个属性，最多只能满足其中两个，必须牺牲一个。</p><ul><li><strong>一致性（Consistency）</strong>：在任何时刻，任何分布式节点中看到的数据都保持一致。</li><li><strong>可用性（Availability）</strong>：系统能够不间断地提供服务的能力。</li><li><strong>分区容忍性（Partition Tolerance）</strong>：在分布式环境中，当部分节点因网络原因失联（即形成“网络分区”）时，系统仍能正确提供服务的能力。</li></ul><h2 id="421-为什么说-分布式系统-必须接受-分区容忍性"><a href="#4-2-1-为什么说-分布式系统-必须接受-分区容忍性" class="headerlink" title="4.2.1 为什么说 分布式系统 必须接受 分区容忍性"></a>4.2.1 为什么说 分布式系统 必须接受 分区容忍性</h2><p>理解为什么分区容忍性在分布式环境下必然存在，需要从分布式系统的基本构成和网络通信的不可靠性两个角度探讨。</p><ol><li><p><strong>分布式系统的基本构成</strong> 分布式系统由多个相互协作的独立组件组成，这些组件可能位于物理上分散的不同位置。该架构的主要优势是提高系统的可扩展性、容错性和资源利用率。然而，这也意味着系统的各个部分必须通过网络通信。</p></li><li><p><strong>网络通信的不可靠性</strong> 网络本身存在不可靠性，可能因多种原因导致通信失败：</p><ol><li><strong>网络故障</strong>：网络设备或连接可能出现故障，如路由器故障、连接断开等。</li><li><strong>网络延迟</strong>：消息在传输过程中可能遭遇不可预测的延迟。</li><li><strong>带宽限制</strong>：网络的带宽限制可能导致数据包延迟到达或丢失。</li><li><strong>网络安全</strong>：网络攻击（如分布式拒绝服务攻击，DDoS）可能导致网络部分或完全不可用。</li></ol></li></ol><p>如果一个系统设计选择不接受网络分区，那么一旦网络分区发生，系统将无法正常工作，这在大多数业务场景中是不可接受的。</p><p>因此，在分布式系统中，分区容忍性（Partition Tolerance）是必然存在的特性。</p><p>基于分区容忍性必须满足的现状以及 CAP 理论，系统只能在一致性和可用性之间做出选择。通常，系统会选择高可用性，强一致性因此被牺牲，系统只能追求最终一致性。</p><h1 id="5-理解分布式事务中的各种协议"><a href="#5-理解分布式事务中的各种协议" class="headerlink" title="5. 理解分布式事务中的各种协议"></a>5. 理解分布式事务中的各种协议</h1><h2 id="51-dtp-模型和-xa-规范"><a href="#5-1-DTP-模型和-XA-规范" class="headerlink" title="5.1 DTP 模型和 XA 规范"></a>5.1 DTP 模型和 XA 规范</h2><h3 id="511-dtp-模型"><a href="#5-1-1-DTP-模型" class="headerlink" title="5.1.1  DTP 模型"></a>5.1.1  DTP 模型</h3><p>DTP（Distributed Transaction Processing，分布式事务处理）模型是由 X/Open（后来的 Open Group）提出的一种分布式事务处理架构模型。它定义了一套标准，使得不同厂商的分布式事务处理系统能够互操作。</p><p>在标准的 DTP 模型中，定义了以下四个主要组件：</p><ol><li><p><strong>Application Program（AP，应用程序）：</strong></p><ul><li>发起分布式事务的主体，由最终用户或开发者编写。</li><li>通过调用事务管理器的接口（例如 TX 接口）开始、提交或回滚事务。</li><li>应用程序与事务管理器和资源管理器交互。</li></ul></li><li><strong>Transaction Manager（TM，事务管理器）：</strong><ul><li>负责管理分布式事务的开始、提交和回滚等操作。</li><li>维护事务的状态，并使用两阶段提交协议（2PC）协调所有参与的资源管理器。</li><li>提供对外的 TX 接口供应用程序使用，并通过 XA 接口与资源管理器交互。</li></ul></li><li><strong>Resource Manager（RM，资源管理器）：</strong><ul><li>负责管理和控制对特定资源的访问，例如数据库管理系统（DBMS）、文件系统、消息队列等。</li><li>接收事务管理器的请求以进行资源操作，并确保数据一致性。</li><li>实现 XA 接口与事务管理器通信。</li></ul></li><li><strong>Communication Resource Manager（CRM，通信资源管理器）：</strong><ul><li>可选组件，负责管理与外部系统的通信资源。</li><li>在分布式事务中协调和同步事务状态，确保跨系统的事务一致性。</li><li>管理跨网络的事务传播，确保分布式环境中的事务处理一致性。</li></ul></li></ol><p><strong>主要接口：</strong></p><ol><li><strong>TX 接口：</strong><ul><li>应用程序 AP 与事务管理器 TM 之间的桥梁，负责事务的开始、提交和回滚等操作。</li><li>例如，在 Java EE 中，TX 接口通常对应 <code>javax.transaction.UserTransaction</code>。</li></ul></li><li><strong>XA 接口：</strong><ul><li>事务管理器 TM 与资源管理器 RM 之间的接口，协调资源管理器在两阶段提交协议中的操作。</li><li>常见的 XA 接口方法包括 <code>xa_open</code>、<code>xa_start</code>、<code>xa_end</code>、<code>xa_prepare</code>、<code>xa_commit</code>、<code>xa_rollback</code> 等。</li></ul></li><li><strong>CRM 接口：</strong><ul><li>事务管理器与通信资源管理器之间的接口，确保分布式事务在网络通信中保持一致性。</li><li>没有明确的标准接口，由各系统厂商自行实现。</li></ul></li></ol><h3 id="512-xa规范"><a href="#5-1-2-XA规范" class="headerlink" title="5.1.2 XA规范"></a>5.1.2 XA规范</h3><p>XA 规范是 X/Open 组织在 DTP（Distributed Transaction Processing）模型中定义的，用于描述事务管理器（TM）和资源管理器（RM）之间交互的接口标准。</p><ol><li><p><strong>接口标准：</strong><br>XA 规范定义了一套标准接口，包括 <code>xa_start</code>、<code>xa_end</code>、<code>xa_prepare</code>、<code>xa_commit</code>、<code>xa_rollback</code> 等。</p></li><li><p><strong>2PC 协议：</strong><br>XA 接口实现了两阶段提交协议（2PC），以确保分布式事务的一致性和完整性。</p></li></ol><h3 id="513-xa-事务"><a href="#5-1-3-XA-事务" class="headerlink" title="5.1.3 XA 事务"></a>5.1.3 XA 事务</h3><p><strong>XA事务</strong>是一种分布式事务。通过两阶段提交协议和XA接口标准，事务管理器和资源管理器能够可靠地协同工作，实现跨系统的事务处理，确保多个独立资源的一致性。</p><p><strong>实际应用</strong></p><ol><li>数据库系统：<ul><li>大多数主流数据库系统都支持XA事务，如Oracle、MySQL、DB2、SQL Server等。</li><li>通过实现XA接口，数据库可以参与分布式事务并与事务管理器协同工作。</li></ul></li><li>消息中间件：<ul><li>一些消息队列和消息中间件也支持XA事务，如IBM MQ、ActiveMQ等。</li><li>能够确保消息发送与其他资源操作的一致性。</li></ul></li><li>Java EE环境：<ul><li>在Java EE应用程序中，<code>javax.transaction.UserTransaction</code>和<code>javax.transaction.TransactionManager</code>接口提供了对XA事务的支持。<h2 id="52-两阶段提交2pc"><a href="#5-2-两阶段提交（2PC）" class="headerlink" title="5.2 两阶段提交（2PC）"></a>5.2 两阶段提交（2PC）</h2></li></ul></li></ol><p>两阶段提交是一种具体的事务协议，用于在分布式系统中协调多个事务参与者的行为，以确保事务的原子性。它包含以下两个阶段：</p><ul><li><strong>准备阶段</strong>：协调者询问所有参与者，是否准备好提交事务。</li><li><strong>提交/回滚阶段</strong>：基于各参与者的答复和超时情况，协调者决定是否全局提交或回滚，<ul><li>只有全部参与者回答了prepared 才会commit;</li><li>若有一个参与者回答和non-prepared 或者超时未回答，则rollback</li></ul></li></ul><img src="/5b064db6/1.png" class><h3 id="521-协调者宕机单点问题参与者阻塞"><a href="#5-2-1-协调者宕机：单点问题，参与者阻塞" class="headerlink" title="5.2.1 协调者宕机：单点问题，参与者阻塞"></a>5.2.1 协调者宕机：单点问题，参与者阻塞</h3><p>在2PC中，一个重要特点是参与者缺乏超时机制。因此，在第一阶段结束后，他们必须原地等待协调者的第二阶段指令。一旦协调者宕机，所有参与者都会受到影响。如果协调者长时间未恢复或未发送正常的提交或回滚指令，所有参与者都将被阻塞。</p><p>为何参与者缺乏超时处理机制呢？因为这可能引发数据一致性问题。当参与者迟迟未收到提交或回滚指令时，无论其默认为提交还是回滚，都可能导致全局数据不一致。</p><p>这也给了我们业务开发一些启示：在任何不确定情况下，都不应随意指定默认操作，最佳做法是启动警报，让人工介入处理。</p><h3 id="522-回滚性能差"><a href="#5-2-2-回滚性能差" class="headerlink" title="5.2.2  回滚性能差"></a>5.2.2  回滚性能差</h3><p>所有的操作都已经完成，回滚需要全部推翻。</p><h3 id="523-一致性问题"><a href="#5-2-3-一致性问题" class="headerlink" title="5.2.3 一致性问题"></a>5.2.3 一致性问题</h3><h4 id="5241-协调者宕机"><a href="#5-2-4-1-协调者宕机" class="headerlink" title="5.2.4.1 协调者宕机"></a>5.2.4.1 协调者宕机</h4><p>如上面单点问题中描述，协调者宕机后，由于参与者没有超时处理机制，会一直阻塞等待，直到协调者宕机恢复后， 根据持久化的数据判断该事务状态，进而发送commit 或者 rollback ， 所以在协调者宕机恢复前 协调者和参与者的数据是不一致的</p><h4 id="5232-参与者宕机"><a href="#5-2-3-2-参与者宕机" class="headerlink" title="5.2.3.2 参与者宕机"></a>5.2.3.2 参与者宕机</h4><p>如果参与者收到commit后，宕机了。此时数据也是不一致的<br>参与者宕机恢复后，可以检查自己的持久化信息，来判断事务的状态。</p><h4 id="5233-网络问题"><a href="#5-2-3-3-网络问题" class="headerlink" title="5.2.3.3 网络问题"></a>5.2.3.3 网络问题</h4><p>有的参与者收到了commit,有的参与者收不到；<br>参与者的ack 消息，协调者有的收到了，有的没收到。<br>其中参与者收不到第二阶段的消息，自然不会有ack, 表现上也是协调者收不到ack。<br>这里的解决方案就是 协调者超时处理机制-重试，在重试成功之前，数据是不一致的。</p><h3 id="524-梳理下-dtp-xa-2pc-之间的关系"><a href="#5-2-4-梳理下-DTP、XA、2PC-之间的关系" class="headerlink" title="5.2.4 梳理下 DTP、XA、2PC 之间的关系"></a>5.2.4 梳理下 DTP、XA、2PC 之间的关系</h3><p>DTP（Distributed Transaction Processing，分布式事务处理）模型是由X/Open（后来的Open Group）提出的一种分布式事务处理的体系结构模型。它定义了一套标准，使得不同厂商的分布式事务处理系统能够互操作。</p><p>XA规范是X/Open组织 在DTP（Distributed Transaction Processing）模型中定义的，用于描述事务管理器（TM）和资源管理器（RM）之间的交互的接口标准。</p><p>XA 规范基于2PC 实现。<br><img src="/5b064db6/2.png" class></p><p>但是 2PC协议是一种通用的事务提交协议，可以在任何实现中使用。除了XA规范，2PC协议还可以用于其他事务管理协议和框架，如：</p><ol><li><strong>Seata</strong>：阿里巴巴开源的分布式事务框架，提供全局事务管理服务，支持2PC但不直接使用XA接口。</li><li><strong>Atomikos</strong>：支持两阶段提交协议的独立事务管理器。</li><li><strong>Bitronix</strong>：另一个独立事务管理器，也支持2PC协议。</li><li>在某些场景下，可以直接在应用程序代码中实现简化版的2PC协议，而无需遵循XA规范。</li></ol><h2 id="53-三阶段提交3pc"><a href="#5-3-三阶段提交（3PC）" class="headerlink" title="5.3  三阶段提交（3PC）"></a>5.3  三阶段提交（3PC）</h2><p>3PC 的3个阶段，</p><ol><li>CanCommit</li><li>PreCommit</li><li>DoCommit</li></ol><p>3PC 相比2PC 的变化</p><ol><li>3PC提交把2PC的prepare 阶段细分为两个阶段，分别称为 CanCommit、PreCommit</li><li>参与者增加了超时处理机制，超时默认会提交事务</li></ol><p>3PC 的提出是为了改进2PC 存在的问题</p><h3 id="531-cancommit-优化回滚操作性能"><a href="#5-3-1-CanCommit-优化回滚操作性能" class="headerlink" title="5.3.1 CanCommit 优化回滚操作性能"></a>5.3.1 CanCommit 优化回滚操作性能</h3><p>新增的 CanCommit 是一个询问阶段，协调者让每个参与的数据库根据自身状态，评估该事务是否有可能顺利完成。这可以解决提高precommit 阶段的成功率，万一失败了，回滚操作也比较轻，因为还没开始做实质性的操作</p><p>但是这里要注意一个性能问题，在事务需要回滚的场景中，三段式的性能通常要比两段式好很多，但在事务能够正常提交的场景中，两段式和三段式提交的性能都很差，三段式因为多了一次询问，性能还要更差一些。</p><h3 id="532-解决协调者单点问题"><a href="#5-3-2-解决协调者单点问题" class="headerlink" title="5.3.2 解决协调者单点问题"></a>5.3.2 解决协调者单点问题</h3><p>通过增加参与者超时处理机制，默认会提交事务，相当于解决了协调者宕机参与者阻塞等待的单点问题</p><h3 id="533-加重数据一致性问题"><a href="#5-3-3-加重数据一致性问题" class="headerlink" title="5.3.3 加重数据一致性问题"></a>5.3.3 加重数据一致性问题</h3><p>在2PC中已经讨论过,为什么2PC参与者没有超时处理机制？<br>因为超时处理机制可能引发数据一致性问题，当 参与者迟迟收不到commit or rollback 指令时， 参与者不论是 默认提交 还是默认回滚，都有可能导致全局数据不一致。</p><p>3PC 增加了超时机制， 会默认提交事务，这会加重数据一致性的问题</p><h2 id="54-tcctry-confirmcancel"><a href="#5-4-TCC（Try-Confirm-Cancel）" class="headerlink" title="5.4 TCC（Try-Confirm/Cancel）"></a>5.4 TCC（Try-Confirm/Cancel）</h2><p>TCC是一种应用层事务协议，它分为三个阶段：Try（尝试）、Confirm（确认）、Cancel（取消）。在Try阶段，每个参与者尝试执行事务并锁定必要资源；在Confirm阶段，如果所有参与者的Try操作都成功，那么执行Confirm操作提交事务；如果任何Try失败，则执行Cancel操作回滚事务。TCC适用于业务逻辑复杂，需要长时间运行的事务。</p><p>个人认为，TCC可以被理解为是2PC的一种变体，具有两阶段的结构，但它在实施和操作上更适合处理复杂的业务逻辑和提高系统的灵活性与效率。</p><h2 id="55-可靠消息队列"><a href="#5-5-可靠消息队列" class="headerlink" title="5.5  可靠消息队列"></a>5.5  可靠消息队列</h2><p>使用可靠消息队列来解决分布式事务问题是一种被称为“最终一致性”的策略，它通过异步消息传递的方式，确保在分布式系统中多个服务之间的数据一致性。</p><p>使用可靠消息队列解决分布式事务的核心思想在于：</p><ol><li><strong>异步与最终一致性</strong>：通过异步的方式处理分布式事务，并确保最终一致性。</li><li><strong>可靠消息传递</strong>：确保消息传递的可靠性，包括重试机制、幂等处理等。</li></ol><h2 id="56-saga"><a href="#5-6-SAGA" class="headerlink" title="5.6 SAGA"></a>5.6 SAGA</h2><p>SAGA是一种将长期事务分解为一系列较小的、独立的子事务的方法。每个子事务都可以单独提交或回滚。如果某个子事务失败，SAGA通过执行补偿事务（即逆操作）来恢复之前的状态。SAGA降低了资源锁定的时间，适用于微服务架构中的事务管理。</p><p>参考文章<br>《周志明的软件架构课》<br><a href="https://www.51cto.com/article/648668.html">https://www.51cto.com/article/648668.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-什么是事务&quot;&gt;&lt;a href=&quot;#1-什么是事务&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是事务&quot;&gt;&lt;/a&gt;1. 什么是事务&lt;/h1&gt;&lt;p&gt;事务（Transaction）的概念起源于数据库领域，最早由美国计算机科学家 E. F. Cod</summary>
      
    
    
    
    
    <category term="事务" scheme="http://example.com/tags/%E4%BA%8B%E5%8A%A1/"/>
    
  </entry>
  
</feed>
