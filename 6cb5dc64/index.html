
<!DOCTYPE html><html lang="zh-CN">

<head>
  <meta charset="utf-8">
  <meta name="hexo-theme" content="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1" theme-name="Stellar" theme-version="1.28.1">
  
  <meta name="generator" content="Hexo 7.2.0">
  <meta http-equiv='x-dns-prefetch-control' content='on' />
  
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#f9fafb">
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#000">
  
  <title>InnoDB事务-持久性的实现,binglog & redo log - Sun Yan</title>

  
    <meta name="description" content="在MySQL InnoDB 这个语境下， crash safe、数据不丢失 都指的是事务的持久性特性，即事务一旦提交，应当保证所有被成功提交的数据修改都能够正确地被持久化，不丢失数据, 即使宕机也能够恢复数据 在InnoDB 中，持久性 基于binlog 和redo log 实现， 且binlog 与redo log 的写入通过2PC 协调. 0 XA 事务：binlog 和redo log 的两">
<meta property="og:type" content="article">
<meta property="og:title" content="InnoDB事务-持久性的实现,binglog &amp; redo log">
<meta property="og:url" content="http://example.com/6cb5dc64/index.html">
<meta property="og:site_name" content="Sun Yan">
<meta property="og:description" content="在MySQL InnoDB 这个语境下， crash safe、数据不丢失 都指的是事务的持久性特性，即事务一旦提交，应当保证所有被成功提交的数据修改都能够正确地被持久化，不丢失数据, 即使宕机也能够恢复数据 在InnoDB 中，持久性 基于binlog 和redo log 实现， 且binlog 与redo log 的写入通过2PC 协调. 0 XA 事务：binlog 和redo log 的两">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/6cb5dc64/1.png">
<meta property="og:image" content="http://example.com/6cb5dc64/2.png">
<meta property="og:image" content="http://example.com/6cb5dc64/3.png">
<meta property="og:image" content="http://example.com/6cb5dc64/4.png">
<meta property="og:image" content="http://example.com/6cb5dc64/5.png">
<meta property="og:image" content="http://example.com/6cb5dc64/6.png">
<meta property="og:image" content="http://example.com/6cb5dc64/8.png">
<meta property="og:image" content="http://example.com/6cb5dc64/9.png">
<meta property="article:published_time" content="2024-05-02T14:47:18.000Z">
<meta property="article:modified_time" content="2024-05-10T15:24:50.204Z">
<meta property="article:author" content="Sun Yan">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="事务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/6cb5dc64/1.png">
  
  
  
  <meta name="keywords" content="MySQL,事务">

  <!-- feed -->
  
    <link rel="alternate" href="/atom.xml" title="Sun Yan" type="application/atom+xml">
  

  <link rel="stylesheet" href="/css/main.css?v=1.28.1">

  

  

  
</head>
<body>

<div class="l_body s:aa content tech" id="start" layout="post" ><aside class="l_left"><div class="leftbar-container">


<header class="header"><div class="logo-wrap"><a class="avatar" href="/"><div class="bg" style="opacity:0;background-image:url(https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/rainbow64@3x.webp);"></div><img no-lazy class="avatar" src="/images/avatar.jpg" onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="title" href="/"><div class="main" ff="title">Sun Yan</div><div class="sub cap">Backend Developer</div></a></div></header>

<div class="nav-area">
<div class="search-wrapper" id="search-wrapper"><form class="search-form"><a class="search-button" onclick="document.getElementById(&quot;search-input&quot;).focus();"><svg t="1705074644177" viewBox="0 0 1025 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1560" width="200" height="200"><path d="M1008.839137 935.96571L792.364903 719.491476a56.783488 56.783488 0 0 0-80.152866 0 358.53545 358.53545 0 1 1 100.857314-335.166073 362.840335 362.840335 0 0 1-3.689902 170.145468 51.248635 51.248635 0 1 0 99.217358 26.444296 462.057693 462.057693 0 1 0-158.255785 242.303546l185.930047 185.725053a51.248635 51.248635 0 0 0 72.568068 0 51.248635 51.248635 0 0 0 0-72.978056z" p-id="1561"></path><path d="M616.479587 615.969233a50.428657 50.428657 0 0 0-61.498362-5.534852 174.655348 174.655348 0 0 1-177.525271 3.484907 49.403684 49.403684 0 0 0-58.833433 6.76482l-3.074918 2.869923a49.403684 49.403684 0 0 0 8.609771 78.10292 277.767601 277.767601 0 0 0 286.992355-5.739847 49.403684 49.403684 0 0 0 8.404776-76.667958z" p-id="1562"></path></svg></a><input type="text" class="search-input" id="search-input" placeholder="站内搜索"></form><div id="search-result"></div><div class="search-no-result">没有找到内容！</div></div>


<nav class="menu dis-select"></nav>
</div>
<div class="widgets">


<widget class="widget-wrapper post-list"><div class="widget-header dis-select"><span class="name">最近更新</span></div><div class="widget-body fs14"><a class="item title" href="/79674443/"><span class="title">从HTTP到HTTPs, 如何实现加密传输</span></a><a class="item title" href="/4579c6a3/"><span class="title">Understanding LSTM Networks</span></a><a class="item title" href="/4bd46d7d/"><span class="title">SpringBoot 自动配置实现原理</span></a><a class="item title" href="/b4967540/"><span class="title">Spring 集成 Mybatis</span></a><a class="item title" href="/b4b9d0ea/"><span class="title">理解 Spring FacrotyBean</span></a><a class="item title" href="/114991e5/"><span class="title">Spring 启动过程 拓展点</span></a><a class="item title" href="/62d611ce/"><span class="title">不懂前端？用cursor 1小时也能写出一个可用的浏览器插件</span></a><a class="item title" href="/e15dc0/"><span class="title">饮料分级助手-糖脂ABCD分级计算器</span></a><a class="item title" href="/209fa7d3/"><span class="title">GPTs开发-Best English Name，帮你找到最合适、最满意的英文名</span></a><a class="item title" href="/99d433fa/"><span class="title">TrustMessage-基于2PC+MySQL+泛化调用实现的可靠消息中心</span></a></div></widget>
</div>
<footer class="footer dis-select"><div class="social-wrap"><a class="social" href="https://github.com/sysunyan1699" target="_blank" rel="external nofollow noopener noreferrer"><img no-lazy src="/images/github.png" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="social" href="https://www.linkedin.com/in/yansun1699/" target="_blank" rel="external nofollow noopener noreferrer"><img no-lazy src="/images/LinkedIn.png" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a><a class="social" href="/sysunyan1699@gmail.com" rel="noopener noreferrer"><img no-lazy src="/images/gmail.png" / onerror="javascript:this.classList.add('error');this.src='https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/image/2659360.svg';"></a></div></footer>
</div></aside><div class="l_main" id="main">





<div class="article banner top">
  <div class="content">
    <div class="top bread-nav footnote"><div class="left"><div class="flex-row" id="breadcrumb"><a class="cap breadcrumb" href="/">主页</a>
<span class="sep"></span><a class="cap breadcrumb" href="/">文章</a></div>
<div class="flex-row" id="post-meta"><span class="text created">发布于：<time datetime="2024-05-02T14:47:18.000Z">2024-05-02</time></span><span class="sep updated"></span><span class="text updated">更新于：<time datetime="2024-05-10T15:24:50.204Z">2024-05-10</time></span></div></div></div>
    
    <div class="bottom only-title">
      
      <div class="text-area">
        <h1 class="text title"><span>InnoDB事务-持久性的实现,binglog & redo log</span></h1>
        
      </div>
    </div>
    
  </div>
  </div><article class="md-text content"><p>在MySQL InnoDB 这个语境下， crash safe、数据不丢失 都指的是事务的持久性特性，即事务一旦提交，应当保证所有被成功提交的数据修改都能够正确地被持久化，不丢失数据, 即使宕机也能够恢复数据</p>
<p>在InnoDB 中，持久性 基于binlog 和redo log 实现， 且binlog 与redo log 的写入通过2PC 协调.</p>
<h1 id="0-xa-事务binlog-和redo-log-的两阶段提交"><a href="#0-XA-事务：binlog-和redo-log-的两阶段提交" class="headerlink" title="0 XA 事务：binlog 和redo log 的两阶段提交"></a>0 XA 事务：binlog 和redo log 的两阶段提交</h1><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/6cb5dc64/1.png" class>
<p>在MySQL中，InnoDB存储引擎 的 redo log 和MySQL服务器层binlog 之间的一致性是通过内部的XA机制（即分布式事务）来实现的，任何一个数据出现问题都会进行会滚。</p>
<p><strong>XA事务</strong>是一种分布式事务。通过两阶段提交协议和XA接口标准，事务管理器和资源管理器能够可靠地协同工作，实现跨系统的事务处理，确保多个独立资源的一致性。</p>
<p>在binlog 和redo log 的两阶段提交， binlog 充当协调者的角色。</p>
<p><a target="_blank" rel="noopener" href="http://localhost:4000/5b064db6/">关于XA 事务具体可在这篇文章中查看</a></p>
<p>binlog 和 redo log 各自写入的过程还有很多细节，接下来进行讲解</p>
<h1 id="1-binlog"><a href="#1-binlog" class="headerlink" title="1 binlog"></a>1 binlog</h1><p>binlog是 MySQL 服务器层使用的日志文件，记录了所有修改数据库内容的SQL语句（如 INSERT, UPDATE, DELETE）,也被称为逻辑日志。</p>
<p>binlog 主要用于主备复制同步、崩溃恢复等功能。</p>
<h2 id="11-binlog-的三种日志格式"><a href="#1-1-binlog-的三种日志格式" class="headerlink" title="1.1 binlog 的三种日志格式"></a>1.1 binlog 的三种日志格式</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>格式</strong></th>
<th><strong>定义</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Statement-Based Logging (SBL)</strong></td>
<td>记录执行的 SQL 语句本身，而不是每行数据的变更。</td>
<td>1. <strong>空间效率高</strong>：通常占用更少的空间，因为记录的是 SQL 语句。 <br>2. <strong>易于审计</strong>：直接记录 SQL 语句，易于阅读和理解。</td>
<td>1. <strong>非确定性行为</strong>：可能在主从复制中导致数据不一致，特别是涉及到非确定性函数（如 NOW()、RAND()）的 SQL 语句。<br>2. <strong>复制错误</strong>：某些特定情况下可能引起从服务器的复制错误。</td>
</tr>
<tr>
<td><strong>Row-Based Logging (RBL)</strong></td>
<td>记录数据变更前后的每行数据的具体变化，而不是执行的 SQL 语句。</td>
<td>1. <strong>数据一致性</strong>：在复制过程中提供高度的数据一致性。<br>2. <strong>安全性更高</strong>：不记录 SQL 语句，降低了 SQL 注入的风险。</td>
<td>1. <strong>空间占用大</strong>：因为记录了每一行的变化，可能导致 binlog 文件迅速增大。<br>2. <strong>可读性差</strong>：不记录 SQL 语句，对于人类审计不友好。</td>
</tr>
<tr>
<td><strong>Mixed-Based Logging (MBL)</strong></td>
<td>结合了 SBL 和 RBL 的特点，根据操作的类型自动选择使用基于语句的格式或基于行的格式记录。</td>
<td>1. <strong>灵活性高</strong>：根据 SQL 语句的特性选择最合适的日志格式。<br>2. <strong>平衡性能和一致性</strong>：在确保数据一致性的同时考虑日志大小和性能。</td>
<td>1. <strong>配置复杂</strong>：需要适当配置以确保效率和准确性。<br>2. <strong>预测性差</strong>：自动切换日志格式可能使得日志的结果难以预测。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="12-binlog写入过程"><a href="#1-2-binlog写入过程" class="headerlink" title="1.2 binlog写入过程"></a>1.2 binlog写入过程</h2><p>binlog 的写入逻辑比较简单：事务执行过程中，先把日志写到 binlog cache，事务提交的时候，再把 binlog cache 写到 binlog 文件中。</p>
<h3 id="121-binlog-cache"><a href="#1-2-1-binlog-cache" class="headerlink" title="1.2.1 binlog  cache"></a>1.2.1 binlog  cache</h3><p>对于每个客户端会话，MySQL 服务器为其分配一个 binlog cache。这个缓存是用来临时存储一个事务中产生的所有 binlog 事件。 但是binlog cache 刷新到磁盘时 多个线程是共写同一份 binlog 文件。</p>
<p>当一个新事务开始时，根据binlog 日志格式记录 每个修改SQL  语句到binlog cache 中</p>
<h3 id="122-page-cache-与-磁盘刷新持久化"><a href="#1-2-2-page-cache-与-磁盘刷新持久化" class="headerlink" title="1.2.2  page cache 与 磁盘刷新持久化"></a>1.2.2  page cache 与 磁盘刷新持久化</h3><p>当事务到达提交阶段时，首先将 binlog  cache 中的内容 写入到binlog 文件中，然后提交事务到 InnoDB，即 commit redo log 。</p>
<p>注意，这里的写入并不是直接写到到磁盘，而是先写入到文件系统的page cache, 然后通过<code>sync_binlog</code> 参数来决定 何时把数据写入到 磁盘。<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/6cb5dc64/2.png" class></p>
<p>磁盘刷新频率通过 <code>sync_binlog</code> 配置参数，</p>
<ol>
<li>sync_binlog=0 的时候，表示每次提交事务都不主动刷新磁盘，由文件系统自己控制刷盘频率</li>
<li>sync_binlog=1 的时候，表示每次提交事务都会将 binlog cache 中的内容刷新到磁盘</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示累积 N 个提交事务后才将多个binlog cache中的内容刷新到磁盘。</li>
</ol>
<p>可以看到如果sync_binlog不设置为1 ，有有助于提高刷盘效率， 但是有丢失binlog 的风险。</p>
<h3 id="123-binlog-cache-不够用怎么办"><a href="#1-2-3-binlog-cache-不够用怎么办" class="headerlink" title="1.2.3  binlog cache 不够用怎么办"></a>1.2.3  binlog cache 不够用怎么办</h3><p>如果binlog cache  写满了怎么办？需要把数据暂存到磁盘</p>
<p>每个事务的 binlog 事件首先被写入到 binlog cache 中，这个缓存的大小由 <code>binlog_cache_size</code> 系统变量控制。</p>
<p>如果一个事务非常大，涉及大量的数据修改，导致binlog cache不足以存储当前事务的所有事件时，MySQL采用的处理机制是将缓存中的数据写入到磁盘上的一个临时文件中。这一过程可以分为以下几个步骤：</p>
<ol>
<li><strong>检测缓存溢出</strong>：当试图向binlog cache中写入数据，而缓存空间不足以容纳更多数据时，将触发溢出处理机制。</li>
<li><strong>数据写入临时文件</strong>：MySQL将当前binlog cache中的数据写入到一个临时文件中。这个临时文件通常位于MySQL的数据目录下，具有唯一标识，确保数据的隔离和安全。</li>
<li><strong>清空binlog cache</strong>：将数据写入临时文件后，binlog cache会被清空，为接下来的日志数据腾出空间。</li>
<li><strong>继续事务日志的记录</strong>：事务继续执行，新的日志事件会再次被记录到现在已经被清空的binlog cache中。</li>
<li><strong>事务提交</strong>：事务如果最终被提交，MySQL会将临时文件中的日志数据以及现在binlog cache中的数据一并写入到全局的binlog文件中。如果事务回滚，则临时文件和binlog cache中的数据都将被丢弃。</li>
</ol>
<h2 id="13-xid"><a href="#1-3-xid" class="headerlink" title="1.3  xid"></a>1.3  xid</h2><p>XID（Transaction Identifier） 可以理解成时MySQL server 层的事务唯一标识。</p>
<ul>
<li>MySQL服务器内部维护一个全局事务ID计数器，每个新事务都会分配一个唯一的ID。该计数器在内存中递增，保证每个事务ID在实例中是唯一的。</li>
<li>当一个新事务开始时，MySQL服务器层会从全局计数器中获取一个新的事务ID，将其赋予该事务，并存储在该事务的上下文中。</li>
</ul>
<h1 id="2-redo-log"><a href="#2-redo-log" class="headerlink" title="2  redo log"></a>2  redo log</h1><p>redo log是 InnoDB 存储引擎特有的日志文件，用于记录对数据库做出的更改前的数据页状态,也被称作物理日志，确保在数据库系统发生崩溃后能够恢复这些更改。<br><strong>记录内容</strong>：Redo log 记录的是数据页修改的物理操作，而非具体的 SQL 语句。</p>
<ul>
<li><strong>循环使用</strong>：Redo log 是固定大小的，通常配置为一组文件，工作在循环写入的方式。</li>
<li><strong>崩溃恢复</strong>：系统重启后，InnoDB 通过回放 redo log 来恢复未完成的事务，确保数据的完整性和一致性。</li>
<li><strong>提高性能</strong>：Redo log 允许 InnoDB 在事务提交时不必将所有数据页写回磁盘，只需确保 redo log 已被写入磁盘。</li>
<li>记录的是数据页的物理修改。 不论数据页是否在buffer pool 中， redo log 都要记录修改， 因为不记不能保证crash safe.</li>
<li>保存自增值</li>
</ul>
<h2 id="21-为什么要记录redo-log"><a href="#2-1-为什么要记录redo-log" class="headerlink" title="2.1 为什么要记录redo log"></a>2.1 为什么要记录redo log</h2><h3 id="211-buffer-pool"><a href="#2-1-1-buffer-pool" class="headerlink" title="2.1.1 buffer pool"></a>2.1.1 buffer pool</h3><p>MySQL 为了实现高性能，是不可能每次都从磁盘读数据或者把对数据的修改持久化到磁盘上的,所以 InnoDB 申请了一块连续的内存，用于存储从磁盘上读取的pages, 这个内存就是buffer pool。</p>
<p>buffer pool 有一块内存叫做，change buffer 用于暂存对数据的修改</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/6cb5dc64/3.png" class>
<p>那么在修改数据时，就会遇到两种情况</p>
<ol>
<li>数据所在的page 在buffer pool 中， 就会直接更新page</li>
<li>数据所在的page 不在buffer pool 中， 如果不需要加载对应page, 就会先把对数据的修改先记在change buffer 中</li>
</ol>
<p>不论是buffer pool, 还是 buffer pool 中的change buffer, 都是内存，一旦发生宕机，那就数据的修改的修改就会丢失，此时就违背了事务的持久性。</p>
<p>为了能把修改过的数据持久化又不影响性能，InnoDB 给出的方案是优先把修改操作记下来并持久化， 事务提交后，万一宕机丢失了buffer pool 中已修改但是未持久化的内容，就可以根据持久化的修改操作重新得到修改后数据。</p>
<p>这里记录下来的修改操作就是redo log,  而这种先记录修改操作，再记录修改后的技术叫做WAL。</p>
<h3 id="212-wal"><a href="#2-1-2-WAL" class="headerlink" title="2.1.2 WAL"></a>2.1.2 WAL</h3><p>WAL（Write-Ahead Logging）是一种在数据库系统中广泛采用的日志管理技术，用于保证数据库的事务持久性和恢复能力。</p>
<p>它的关键点就是先写日志，再写真正的数据。</p>
<p>redo log 直接应用了 WAL 技术，确保在任何数据被写入数据库页之前，相应的日志信息（如数据页的修改）先被写入到 redo log 中。</p>
<p>总的来说WAL 技术的优势有以下3项，</p>
<ol>
<li><strong>恢复能力</strong>：WAL 提供了强大的数据恢复能力。在发生系统故障后，可以利用日志文件中的记录来重做或撤销事务，恢复到最后一致的状态。</li>
<li><strong>性能优化</strong>：通过将对磁盘数据的随机写转换为<code>顺序写</code> ， 同时利用 <code>组提交</code> ，WAL 可以显著提高数据库的写性能。</li>
<li><strong>事务原子性和持久性</strong>：WAL 通过确保所有日志记录在实际数据写入前被提交到磁盘，从而支持数据库事务的原子性和持久性。</li>
</ol>
<h2 id="22-redo-log-记录的内容"><a href="#2-2-redo-log-记录的内容" class="headerlink" title="2.2 redo log 记录的内容"></a>2.2 redo log 记录的内容</h2><p>之所以说redo log 是物理日志， 是因为其记录了对特定数据page 数据的修改。<br>该例子来自极客专栏《MySQL 实战45讲》</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table t(ID int primary key, c int);</span><br><span class="line">mysql&gt; insert into t(id,k) values(id1,k1),(id2,k2);</span><br></pre></td></tr></table></figure>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/6cb5dc64/4.png" class>
<p>这条更新语句做了如下的操作（按照图中的数字顺序）：</p>
<ol>
<li>Page 1 在内存中，直接更新内存；</li>
<li>Page 2 没有在内存中，就在内存的 change buffer 区域，记录下“我要往 Page 2 插入一行”这个信息</li>
<li>将上述两个动作记入 redo log 中（图中 3 和 4）。</li>
</ol>
<p>Redo log不是记录数据页“更新之后的状态”，而是记录这个页 “做了什么改动”。</p>
<h2 id="23-redo-log-写入过程"><a href="#2-3-redo-log-写入过程" class="headerlink" title="2.3 redo log 写入过程"></a>2.3 redo log 写入过程</h2><p><a target="_blank" rel="noopener" href="https://time.geekbang.org/column/article/76161"># 23 | MySQL是怎么保证数据不丢的？ redo log 的写入机制-redo log buffer </a></p>
<p>redo log 的写入机制和 binlog 类型， 需要经历</p>
<ol>
<li>MySQL 系统内存cache ， redo lo buffer</li>
<li>文件系统page cache</li>
<li>刷新持久化到磁盘<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/6cb5dc64/5.png" class>
</li>
</ol>
<h3 id="231-redo-log-buffer"><a href="#2-3-1-redo-log-buffer" class="headerlink" title="2.3.1 redo log buffer"></a>2.3.1 redo log buffer</h3><p>add(id1,k1) to page1, new change buffer item add(id2,k2) to page2 都是先写入redo log buffer 中</p>
<p>相比较 每个线程都拥有自己一块独立的 binlog cache ， 而 redo log buffer 是全局共用的。</p>
<h3 id="232-redo-log持久化到磁盘"><a href="#2-3-2-redo-log持久化到磁盘" class="headerlink" title="2.3.2 redo log持久化到磁盘"></a>2.3.2 redo log持久化到磁盘</h3><p>事务提交，执行commit redo log 后，会触发redo log buffer 中内容写入到redo log 中。</p>
<p>为了控制 redo log 的写入策略，InnoDB 提供了 innodb_flush_log_at_trx_commit 参数，它有三种可能取值：</p>
<ol>
<li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
<li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ol>
<p>所以想要确保MySQL异常重启之后redo log 数据不丢失，innodb_flush_log_at_trx_commit 这个参数 建议设置成1.</p>
<p>前面在binlog部分说到， 在事务提交前，事务binlog 是不会被写入到真正的binlog 文件中的。 redo log 不一样，在事务提交前，redo log 有可能备持久化磁盘。有以下3种情况</p>
<ol>
<li>后台线程,每隔 1 秒，就会把 redo log buffer 中的日志，调用 write 写到文件系统的 page cache，然后调用 fsync 持久化到磁盘。，</li>
<li>redo log buffer 占用的空间即将达到 innodb_log_buffer_size 一半的时候，后台线程会主动写盘。注意，由于这个事务并没有提交，所以这个写盘动作只是 write，而没有调用 fsync，也就是只留在了文件系统的 page cache。</li>
<li>并行的事务提交的时候，顺带将这个事务的 redo log buffer 持久化到磁盘。如果 innodb_flush_log_at_trx_commit 设置的是 1，那么按照这个参数的逻辑， 要把 redo log buffer 里的日志全部持久化到磁盘。这时候，就会带上未提交事务 在 redo log buffer 里的日志一起持久化到磁盘。<h3 id="233-2pc的细化过程"><a href="#2-3-3-2PC的细化过程" class="headerlink" title="2.3.3 2PC的细化过程"></a>2.3.3 2PC的细化过程</h3></li>
</ol>
<h2 id="24-日志文件组"><a href="#2-4-日志文件组" class="headerlink" title="2.4  日志文件组"></a>2.4  日志文件组</h2><p>InnoDB 的 redo log 是以日志文件组的形式组织的。一个日志文件组通常包含两个或更多的日志文件，这些文件在物理上是连续的，并且循环使用。当一个日志文件写满后，InnoDB 会自动切换到下一个日志文件继续写入。当最后一个文件写满后，它会回到第一个文件并开始覆盖旧的日志记录，这就是所谓的“环形写入”。</p>
<h2 id="25-lsn"><a href="#2-5-LSN" class="headerlink" title="2.5 LSN"></a>2.5 LSN</h2><p>LSN（Log Sequence Number）,日志序列号,是一个不断增长的全局变量， 用来记录当前redo log 文件中 已经写入的日志量， 单位是字节。</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/6cb5dc64/6.png" class>
<p>图片中的write pos LSN 指当前已经产生的的日志量，随着更多的事务数据被写入，write pos LSN 会不断增加</p>
<p>checkpoint LSN 是redo log 中的一个位置，表示所有之前的日志记录都已经被应用（或说是“刷新”）到了磁盘的数据页上，因此，从这个位置以前的日志数据可以安全地被覆写， 不会出现数据丢失的情况。 redo log 会有多个检查点</p>
<p>write pos LSN 和 checkpoint LSN之间空着的部分，可以用来记录新的操作。</p>
<p>如果 write pos LSN  赶上了最一个checkpoint  LSN 位置，这意味着 redo log 的空间不足，可能会导致数据库操作停顿，因为系统需要等待足够的日志空间来记录新的事务数据。</p>
<h2 id="26-组提交"><a href="#2-6-组提交" class="headerlink" title="2.6  组提交"></a>2.6  组提交</h2><p>前面提过，redo log 提升性能，一个是把对磁盘的随机写转换成了顺序写，一个是组提交机制。</p>
<p>组提交机制（Group Commit）是一种通过合并多个事务的日志提交操作来提高I/O效率的策略。这一机制基于LSN（Log Sequence Number，日志序列号）来追踪和管理日志提交。</p>
<p>以下图为例解释<br><img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/6cb5dc64/8.png" class></p>
<ol>
<li><strong>事务<code>trx1</code>开始</strong>：<ul>
<li><code>trx1</code>进入事务队列并被选为组的领导者，日志记录的LSN开始增加。</li>
</ul>
</li>
<li><strong>事务<code>trx2</code>和<code>trx3</code>加入</strong><ul>
<li>在<code>trx1</code>进入队列之后，<code>trx2</code>和<code>trx3</code>紧随其后进入提交队列。</li>
</ul>
</li>
<li><strong>LSN更新到160</strong>：<ul>
<li>随着<code>trx2</code>和<code>trx3</code>的日志写入缓冲区，整个组的最后一个日志序列号<code>LSN</code>变为160。</li>
</ul>
</li>
<li><strong>领导者<code>trx1</code>执行写盘</strong>：<ul>
<li><code>trx1</code>作为组的领导者，携带<code>LSN=160</code>去执行一次性日志写盘（fsync）操作。</li>
</ul>
</li>
<li><strong>写盘完成</strong>：<ul>
<li><code>trx1</code>的fsync操作完成后，所有<code>LSN &lt;= 160</code>的日志记录都被持久化到磁盘。</li>
</ul>
</li>
<li><strong>事务返回提交成功</strong>：<ul>
<li><code>trx1</code>、<code>trx2</code>和<code>trx3</code>都标记为提交成功并从提交队列中移除。</li>
</ul>
</li>
</ol>
<h1 id="3-事务执行过程中的binlog-和redolog-和undo-log"><a href="#3-事务执行过程中的binlog-和redolog-和undo-log" class="headerlink" title="3 事务执行过程中的binlog 和redolog 和undo log"></a>3 事务执行过程中的binlog 和redolog 和undo log</h1><p>下面将结合MySQL 的逻辑架构 和具体SQL , 来具体地看一下binlog 和redo log 的写入</p>
<img class="lazy" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAABGdBTUEAALGPC/xhBQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAAAaADAAQAAAABAAAAAQAAAADa6r/EAAAAC0lEQVQIHWNgAAIAAAUAAY27m/MAAAAASUVORK5CYII=" data-src="/6cb5dc64/9.png" class>
<p>SQL<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T(ID int primary key, c int);</span><br><span class="line">mysql&gt; update T set c=c+1 where ID=2;</span><br></pre></td></tr></table></figure></p>
<p>结果MySQL 的逻辑架构， 该update sql的执行过程如下</p>
<ol>
<li>执行器先找InnoDB取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在buffer pool 中，就直接返回给执行器；否则，需要先从磁盘读入buffer pool，然后再返回。</li>
<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>
<li>InnoDB引擎记录该行数据的undo log, 然后新数据更新到内存中，如果数据本来就在内存中，则直接修改数据页，如果不再内存中，则将修改记录在change buffer  中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。</li>
<li>然后告知执行器执行完成了，随时可以提交事务。执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>
<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。根据 innodb_flush_log_at_trx_commit 决定redo log 是否持久化到磁盘</li>
<li>buffer pool 中对数据页的更新 ,等待脏页刷线操作持久化到磁盘</li>
</ol>
<p>14.prepare阶段,将事务的xid写入，将binlog_cache里的进行flush以及sync操作(大事务的话这步非常耗时)<br>15.commit阶段，由于之前该事务产生的redo log已经sync到磁盘了。所以这步只是在redo log里标记commit</p>
<h1 id="4-崩溃恢复的逻辑"><a href="#4-崩溃恢复的逻辑" class="headerlink" title="4 崩溃恢复的逻辑"></a>4 崩溃恢复的逻辑</h1><p>崩溃恢复过程中，InnoDB 会从最近的 checkpoint LSN开始，应用 redo log 中的更改，直到达到崩溃时的 write pos LSN，以此来恢复数据库到最后一次提交的状态。</p>
<p>看一下崩溃恢复时的判断规则</p>
<ol>
<li>如果 redo log 里面的事务是完整的，则直接提交；</li>
<li>如果 redo log 里面的事务只有完整的 prepare，则判断对应的事务 binlog 是否存在并完整：<ol>
<li>如果完整，则提交事务；</li>
<li>否则，回滚事务。==此处事务回滚基于undo log ==</li>
</ol>
</li>
<li>如果redo log 没有完整的prepare, 则事务基于undo log 回滚</li>
</ol>
<p>⚠️说明一下，innodb_flush_log_at_trx_commit  实际上控制了redo prepare 和commit 两个阶段的刷盘策略，比如innodb_flush_log_at_trx_commit  =1 时在 <code>prepare</code> 阶段和 <code>commit</code> 阶段，<code>redo log</code> 都会持久化写入磁盘。所以才会出现第二种磁盘有且只有完整prepare 的情况。</p>
<p>接下来根据一些具体的问题来详细说明崩溃恢复时的细节</p>
<h2 id="41-如何判断-redo-log-是完整的"><a href="#4-1-如何判断-redo-log-是完整的" class="headerlink" title="4.1  如何判断 redo log 是完整的"></a>4.1  如何判断 redo log 是完整的</h2><p>redo log commit 阶段会有commit 标识</p>
<h2 id="42-如果判断binlog-完整性"><a href="#4-2-如果判断binlog-完整性" class="headerlink" title="4.2. 如果判断binlog 完整性"></a>4.2. 如果判断binlog 完整性</h2><p>一个事务的 binlog 是有完整格式的：<br>statement 格式的 binlog，最后会有 COMMIT；<br>row 格式的 binlog，最后会有一个 XID event。</p>
<h2 id="43-redo-log-和-binlog-是怎么关联起来的"><a href="#4-3-redo-log-和-binlog-是怎么关联起来的" class="headerlink" title="4.3. redo log 和 binlog 是怎么关联起来的"></a>4.3. redo log 和 binlog 是怎么关联起来的</h2><p>在崩溃恢复时，通过读取Redo Log中的Xid，能够将其与Binlog中的Xid进行匹配。</p>
<p>XID（Transaction Identifier） 可以理解成时MySQL server 层的事务唯一标识。<br>redo log  中会记录XID</p>
<p>如果碰到只有 parepare、而没有 commit 的 redo log，就拿着 XID 去 binlog 找对应的事务。</p>
<h2 id="44-为什么要用2pc-协调binlog和redo-log"><a href="#4-4-为什么要用2PC-协调binlog和redo-log" class="headerlink" title="4.4. 为什么要用2PC 协调binlog和redo log"></a>4.4. 为什么要用2PC 协调binlog和redo log</h2><p>类似的问题还有，为什么处于 prepare 阶段的 redo log 加上完整 binlog 就可以提交事务。</p>
<p>这两个问题本质上都是数据一致性的问题。</p>
<p>binlog 是server 层日志， 是MySQL 一开始就有的功能，被用在了很多地方，比如备份、主备同步复制。redo log 是InnoDB 层日志，是InnoDB 为了实现事务功能新增的。使用2PC可以维护两份之间的逻辑一致。</p>
<p>那么，为什么要维护两份日志间的逻辑一致呢。</p>
<p>binlog 是server 层日志， 是MySQL 一开始就有的功能，被用在了很多地方，比如备份、主备同步复制。redo log 是InnoDB 层日志，是InnoDB 为了实现事务功能新增的。如果两份日志逻辑或者说数据不一致， 那么用日志恢复出来的数据库状态就有可能和它本来应该的状态不一致。</p>
<p>具体举例来讲，如果不用2PC，两种日志要么是先写 redo log 再写 binlog，或者先写binlog 再写redo log 。<br>仍然用前面的 update 语句来做例子。假设当前 ID=2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p>
<ol>
<li><p>先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。</p>
</li>
<li><p>先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>
</li>
</ol>
<p>同理，为什么处于 prepare 阶段的 redo log 加上完整 binlog 就可以提交事务。因为如果binlog 写完以后 MySQL 发生崩溃，这时候 binlog 已经写入了，之后就会被从库（或者用这个 binlog 恢复出来的库）使用。如果redo log 事务不提交的话，就会发生数据不一致的情况</p>
<h2 id="45-不要binlog-可以吗"><a href="#4-5-不要binlog-可以吗" class="headerlink" title="4.5. 不要binlog 可以吗"></a>4.5. 不要binlog 可以吗</h2><p>仅从事务持久化/崩溃恢复这个功能来讲， 只要redo log  是可以完成的。<br>但是binlog 作为 MySQL 一开始就有的功能，被用在了很多地方，有redo log 无法替代的功能 。</p>
<ol>
<li>归档。redo log 是循环写，写到末尾是要回到开头继续写的。这样历史日志没法保留，redo log 也就起不到归档的作用。</li>
<li>主从复制同步</li>
<li>MySQL 高可用</li>
<li>在一些业务场景中， 也会使用binlog做数据同步，比如使用canal 同步binlog数据 到ES<h2 id="46-数据一定不会丢失吗-双1-设置"><a href="#4-6-数据一定不会丢失吗-双1-设置" class="headerlink" title="4.6 数据一定不会丢失吗-双1 设置"></a>4.6 数据一定不会丢失吗-双1 设置</h2></li>
</ol>
<p>在介绍binlog和redo log 写入过程的时候，有两个参数<br>sync_binlog  控制binlog 持久化到磁盘的频率</p>
<ol>
<li>sync_binlog=0 的时候，表示每次提交事务都不主动刷新磁盘，由文件系统自己控制刷盘频率</li>
<li>sync_binlog=1 的时候，表示每次提交事务都会将 binlog cache 中的内容刷新到磁盘</li>
<li>sync_binlog=N(N&gt;1) 的时候，表示累积 N 个提交事务后才将多个binlog cache中的内容刷新到磁盘。</li>
</ol>
<p>innodb_flush_log_at_trx_commit  控制redo log 持久化到磁盘的频率</p>
<ol>
<li>设置为 0 的时候，表示每次事务提交时都只是把 redo log 留在 redo log buffer 中 ;</li>
<li>设置为 1 的时候，表示每次事务提交时都将 redo log 直接持久化到磁盘；</li>
<li>设置为 2 的时候，表示每次事务提交时都只是把 redo log 写到 page cache。</li>
</ol>
<p>可以看到吗，只有在双1设置的时候，sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1， 才能确保一定不会丢数据</p>
<p>通常我们说 MySQL 的“双 1”配置，指的就是 sync_binlog 和 innodb_flush_log_at_trx_commit 都设置成 1。也就是说，一个事务完整提交前，需要等待两次刷盘，一次是 redo log（prepare 阶段），一次是 binlog。</p>
<p>如果不设置成双1， 有助于提高性能。</p>
<h1 id="5-binlog-vs-redo-log"><a href="#5-binlog-vs-redo-log" class="headerlink" title="5. binlog vs redo log"></a>5. binlog vs redo log</h1><h4 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h4><ul>
<li><strong>层级差异</strong>：Binlog 工作在 MySQL 服务器层，所有引擎都可以使用；而 redo log 是 InnoDB 存储引擎层特有的。</li>
<li><strong>记录形式</strong>：Binlog 可以记录 SQL 语句或行变更，redo log 记录的是数据页的物理变化，即“在某个数据页上做了什么修改”</li>
<li><strong>目的和用途</strong>：Binlog 主要用于数据复制和崩溃恢复，而 redo log 主要用于事务的持久性和崩溃恢复。</li>
<li><strong>大小管理</strong>：Redo log 的大小是固定的，循环使用循环写；binlog 是追加写，可以不断增长，需要定期进行清理。</li>
<li><strong>日志写入</strong>：每个线程都拥有自己一块独立的 binlog cache ， 而 redo log buffer 是全局共用的</li>
</ul>
<h4 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h4><ul>
<li><strong>事务安全</strong>：两者都是为了保证事务的持久性和原子性。</li>
<li><strong>恢复支持</strong>：在系统或硬件故障后，两者都能被用来恢复数据。</li>
<li><strong>写前日志</strong>：都采用了写前日志（write-ahead logging, WAL）的技术，即在实际修改数据库内容前先记录日志。</li>
<li>从生产到写入磁盘均有内存page - 到page cache - 磁盘，刷新到磁盘的时机均有参数控制</li>
</ul>
<h1 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h1><p><a target="_blank" rel="noopener" href="https://sunyan.xyz/5b064db6/">Intro to 事务</a><br><a target="_blank" rel="noopener" href="https://sunyan.xyz/9cd551f5/">Intro to InnoDB 事务</a><br><a target="_blank" rel="noopener" href="https://sunyan.xyz/b36b0ce9/">InnoDB事务-原子性的实现,undo log</a><br><a target="_blank" rel="noopener" href="https://sunyan.xyz/9faedfe0/">InnoDB事务-隔离性的实现,MVCC &amp; 锁</a></p>

<div class="article-footer fs14">
    <section id="license">
      <div class="header"><span>许可协议</span></div>
      <div class="body"><p>本文采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">署名-非商业性使用-相同方式共享 4.0 国际</a> 许可协议，转载请注明出处。</p>
</div>
    </section>
    </div>
</article>
<div class="related-wrap" id="read-next"><section class="body"><div class="item" id="prev"><div class="note">较新文章</div><a href="/e15dc0/">饮料分级助手-糖脂ABCD分级计算器</a></div><div class="item" id="next"><div class="note">较早文章</div><a href="/9faedfe0/">InnoDB事务-隔离性的实现, MVCC & 锁</a></div></section></div>






<footer class="page-footer footnote"><hr><div class="text"><p>本站由 <a href="/">Sun Yan</a> 使用 <a target="_blank" rel="noopener" href="https://github.com/xaoxuu/hexo-theme-stellar/tree/1.28.1">Stellar 1.28.1</a> 主题创建。<br>本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议，转载请注明出处。</p>
</div></footer>
<div class="main-mask" onclick="sidebar.dismiss()"></div></div><aside class="l_right">
<div class="widgets">



<widget class="widget-wrapper toc" id="data-toc" collapse="false"><div class="widget-header dis-select"><span class="name">本文目录</span><a class="cap-action" onclick="sidebar.toggleTOC()" ><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg></a></div><div class="widget-body"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-xa-%E4%BA%8B%E5%8A%A1binlog-%E5%92%8Credo-log-%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-text">0 XA 事务：binlog 和redo log 的两阶段提交</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-binlog"><span class="toc-text">1 binlog</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-binlog-%E7%9A%84%E4%B8%89%E7%A7%8D%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-text">1.1 binlog 的三种日志格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-binlog%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">1.2 binlog写入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#121-binlog-cache"><span class="toc-text">1.2.1 binlog  cache</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122-page-cache-%E4%B8%8E-%E7%A3%81%E7%9B%98%E5%88%B7%E6%96%B0%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-text">1.2.2  page cache 与 磁盘刷新持久化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#123-binlog-cache-%E4%B8%8D%E5%A4%9F%E7%94%A8%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-text">1.2.3  binlog cache 不够用怎么办</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-xid"><span class="toc-text">1.3  xid</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-redo-log"><span class="toc-text">2  redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%AE%B0%E5%BD%95redo-log"><span class="toc-text">2.1 为什么要记录redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#211-buffer-pool"><span class="toc-text">2.1.1 buffer pool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#212-wal"><span class="toc-text">2.1.2 WAL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-redo-log-%E8%AE%B0%E5%BD%95%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-text">2.2 redo log 记录的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-redo-log-%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B"><span class="toc-text">2.3 redo log 写入过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#231-redo-log-buffer"><span class="toc-text">2.3.1 redo log buffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#232-redo-log%E6%8C%81%E4%B9%85%E5%8C%96%E5%88%B0%E7%A3%81%E7%9B%98"><span class="toc-text">2.3.2 redo log持久化到磁盘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#233-2pc%E7%9A%84%E7%BB%86%E5%8C%96%E8%BF%87%E7%A8%8B"><span class="toc-text">2.3.3 2PC的细化过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%BB%84"><span class="toc-text">2.4  日志文件组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-lsn"><span class="toc-text">2.5 LSN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E7%BB%84%E6%8F%90%E4%BA%A4"><span class="toc-text">2.6  组提交</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84binlog-%E5%92%8Credolog-%E5%92%8Cundo-log"><span class="toc-text">3 事务执行过程中的binlog 和redolog 和undo log</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D%E7%9A%84%E9%80%BB%E8%BE%91"><span class="toc-text">4 崩溃恢复的逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD-redo-log-%E6%98%AF%E5%AE%8C%E6%95%B4%E7%9A%84"><span class="toc-text">4.1  如何判断 redo log 是完整的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%A6%82%E6%9E%9C%E5%88%A4%E6%96%ADbinlog-%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-text">4.2. 如果判断binlog 完整性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-redo-log-%E5%92%8C-binlog-%E6%98%AF%E6%80%8E%E4%B9%88%E5%85%B3%E8%81%94%E8%B5%B7%E6%9D%A5%E7%9A%84"><span class="toc-text">4.3. redo log 和 binlog 是怎么关联起来的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A82pc-%E5%8D%8F%E8%B0%83binlog%E5%92%8Credo-log"><span class="toc-text">4.4. 为什么要用2PC 协调binlog和redo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E4%B8%8D%E8%A6%81binlog-%E5%8F%AF%E4%BB%A5%E5%90%97"><span class="toc-text">4.5. 不要binlog 可以吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E6%95%B0%E6%8D%AE%E4%B8%80%E5%AE%9A%E4%B8%8D%E4%BC%9A%E4%B8%A2%E5%A4%B1%E5%90%97-%E5%8F%8C1-%E8%AE%BE%E7%BD%AE"><span class="toc-text">4.6 数据一定不会丢失吗-双1 设置</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-binlog-vs-redo-log"><span class="toc-text">5. binlog vs redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%AE%E5%BC%82"><span class="toc-text">差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-text">共同点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E6%96%87%E7%AB%A0"><span class="toc-text">相关文章</span></a></li></ol></div><div class="widget-footer">

<a class="top" onclick="util.scrollTop()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 12c0-4.714 0-7.071 1.464-8.536C4.93 2 7.286 2 12 2c4.714 0 7.071 0 8.535 1.464C22 4.93 22 7.286 22 12c0 4.714 0 7.071-1.465 8.535C19.072 22 16.714 22 12 22s-7.071 0-8.536-1.465C2 19.072 2 16.714 2 12Z"/><path stroke-linecap="round" stroke-linejoin="round" d="m9 15.5l3-3l3 3m-6-4l3-3l3 3"/></g></svg><span>回到顶部</span></a><a class="buttom" onclick="util.scrollComment()"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="currentColor" fill-rule="evenodd" d="M10.46 1.25h3.08c1.603 0 2.86 0 3.864.095c1.023.098 1.861.3 2.6.752a5.75 5.75 0 0 1 1.899 1.899c.452.738.654 1.577.752 2.6c.095 1.004.095 2.261.095 3.865v1.067c0 1.141 0 2.036-.05 2.759c-.05.735-.153 1.347-.388 1.913a5.75 5.75 0 0 1-3.112 3.112c-.805.334-1.721.408-2.977.43a10.81 10.81 0 0 0-.929.036c-.198.022-.275.054-.32.08c-.047.028-.112.078-.224.232c-.121.166-.258.396-.476.764l-.542.916c-.773 1.307-2.69 1.307-3.464 0l-.542-.916a10.605 10.605 0 0 0-.476-.764c-.112-.154-.177-.204-.224-.232c-.045-.026-.122-.058-.32-.08c-.212-.023-.49-.03-.93-.037c-1.255-.021-2.171-.095-2.976-.429A5.75 5.75 0 0 1 1.688 16.2c-.235-.566-.338-1.178-.389-1.913c-.049-.723-.049-1.618-.049-2.76v-1.066c0-1.604 0-2.86.095-3.865c.098-1.023.3-1.862.752-2.6a5.75 5.75 0 0 1 1.899-1.899c.738-.452 1.577-.654 2.6-.752C7.6 1.25 8.857 1.25 10.461 1.25M6.739 2.839c-.914.087-1.495.253-1.959.537A4.25 4.25 0 0 0 3.376 4.78c-.284.464-.45 1.045-.537 1.96c-.088.924-.089 2.11-.089 3.761v1c0 1.175 0 2.019.046 2.685c.045.659.131 1.089.278 1.441a4.25 4.25 0 0 0 2.3 2.3c.515.214 1.173.294 2.429.316h.031c.398.007.747.013 1.037.045c.311.035.616.104.909.274c.29.17.5.395.682.645c.169.232.342.525.538.856l.559.944a.52.52 0 0 0 .882 0l.559-.944c.196-.331.37-.624.538-.856c.182-.25.392-.476.682-.645c.293-.17.598-.24.909-.274c.29-.032.639-.038 1.037-.045h.032c1.255-.022 1.913-.102 2.428-.316a4.25 4.25 0 0 0 2.3-2.3c.147-.352.233-.782.278-1.441c.046-.666.046-1.51.046-2.685v-1c0-1.651 0-2.837-.089-3.762c-.087-.914-.253-1.495-.537-1.959a4.25 4.25 0 0 0-1.403-1.403c-.464-.284-1.045-.45-1.96-.537c-.924-.088-2.11-.089-3.761-.089h-3c-1.651 0-2.837 0-3.762.089" clip-rule="evenodd"/><path fill="currentColor" d="M9 11a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0m4 0a1 1 0 1 1-2 0a1 1 0 0 1 2 0"/></svg><span>参与讨论</span></a></div></widget>
</div></aside><div class='float-panel blur'>
  <button type='button' style='display:none' class='laptop-only rightbar-toggle mobile' onclick='sidebar.rightbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6h11m-11 6h11m-11 6h11M4 6h1v4m-1 0h2m0 8H4c0-1 2-2 2-3s-1-1.5-2-1"/></svg>
  </button>
  <button type='button' style='display:none' class='mobile-only leftbar-toggle mobile' onclick='sidebar.leftbar()'>
    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-width="1.5"><path d="M2 11c0-3.771 0-5.657 1.172-6.828C4.343 3 6.229 3 10 3h4c3.771 0 5.657 0 6.828 1.172C22 5.343 22 7.229 22 11v2c0 3.771 0 5.657-1.172 6.828C19.657 21 17.771 21 14 21h-4c-3.771 0-5.657 0-6.828-1.172C2 18.657 2 16.771 2 13z"/><path id="sep" stroke-linecap="round" d="M5.5 10h6m-5 4h4m4.5 7V3"/></g></svg>
  </button>
</div>
</div><div class="scripts">
<script type="text/javascript">
  const ctx = {
    date_suffix: {
      just: `刚刚`,
      min: `分钟前`,
      hour: `小时前`,
      day: `天前`,
    },
    root : `/`,
  };

  // required plugins (only load if needs)
  if (`local_search`) {
    ctx.search = {};
    ctx.search.service = `local_search`;
    if (ctx.search.service == 'local_search') {
      let service_obj = Object.assign({}, `{"field":"all","path":"/search.json","content":true,"sort":"-date"}`);
      ctx.search[ctx.search.service] = service_obj;
    }
  }
  const def = {
    avatar: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/avatar/round/3442075.svg`,
    cover: `https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.12/cover/76b86c0226ffd.svg`,
  };
  const deps = {
    jquery: `https://cdn.bootcdn.net/ajax/libs/jquery/3.7.1/jquery.min.js`,
    marked: `https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js`
  }
  

</script>

<script type="text/javascript">
  const utils = {
    // 懒加载 css https://github.com/filamentgroup/loadCSS
    css: (href, before, media, attributes) => {
      var doc = window.document;
      var ss = doc.createElement("link");
      var ref;
      if (before) {
        ref = before;
      } else {
        var refs = (doc.body || doc.getElementsByTagName("head")[0]).childNodes;
        ref = refs[refs.length - 1];
      }
      var sheets = doc.styleSheets;
      if (attributes) {
        for (var attributeName in attributes) {
          if (attributes.hasOwnProperty(attributeName)) {
            ss.setAttribute(attributeName, attributes[attributeName]);
          }
        }
      }
      ss.rel = "stylesheet";
      ss.href = href;
      ss.media = "only x";
      function ready(cb) {
        if (doc.body) {
          return cb();
        }
        setTimeout(function () {
          ready(cb);
        });
      }
      ready(function () {
        ref.parentNode.insertBefore(ss, before ? ref : ref.nextSibling);
      });
      var onloadcssdefined = function (cb) {
        var resolvedHref = ss.href;
        var i = sheets.length;
        while (i--) {
          if (sheets[i].href === resolvedHref) {
            return cb();
          }
        }
        setTimeout(function () {
          onloadcssdefined(cb);
        });
      };
      function loadCB() {
        if (ss.addEventListener) {
          ss.removeEventListener("load", loadCB);
        }
        ss.media = media || "all";
      }
      if (ss.addEventListener) {
        ss.addEventListener("load", loadCB);
      }
      ss.onloadcssdefined = onloadcssdefined;
      onloadcssdefined(loadCB);
      return ss;
    },

    js: (src, opt) => new Promise((resolve, reject) => {
      var script = document.createElement('script');
      if (src.startsWith('/')){
        src = ctx.root + src.substring(1);
      }
      script.src = src;
      if (opt) {
        for (let key of Object.keys(opt)) {
          script[key] = opt[key]
        }
      } else {
        // 默认异步，如果需要同步，第二个参数传入 {} 即可
        script.async = true
      }
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    }),

    jq: (fn) => {
      if (typeof jQuery === 'undefined') {
        utils.js(deps.jquery).then(fn)
      } else {
        fn()
      }
    },
    
    onLoading: (el) => {
      if (el) {
        $(el).append('<div class="loading-wrap"><svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" stroke-opacity=".3" d="M12 3C16.9706 3 21 7.02944 21 12C21 16.9706 16.9706 21 12 21C7.02944 21 3 16.9706 3 12C3 7.02944 7.02944 3 12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="1.3s" values="60;0"/></path><path stroke-dasharray="15" stroke-dashoffset="15" d="M12 3C16.9706 3 21 7.02944 21 12"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.3s" values="15;0"/><animateTransform attributeName="transform" dur="1.5s" repeatCount="indefinite" type="rotate" values="0 12 12;360 12 12"/></path></g></svg></div>');
      }
    },
    onLoadSuccess: (el) => {
      if (el) {
        $(el).find('.loading-wrap').remove();
      }
    },
    onLoadFailure: (el) => {
      if (el) {
        $(el).find('.loading-wrap svg').remove();
        $(el).find('.loading-wrap').append('<svg xmlns="http://www.w3.org/2000/svg" width="2em" height="2em" preserveAspectRatio="xMidYMid meet" viewBox="0 0 24 24"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path stroke-dasharray="60" stroke-dashoffset="60" d="M12 3L21 20H3L12 3Z"><animate fill="freeze" attributeName="stroke-dashoffset" dur="0.5s" values="60;0"/></path><path stroke-dasharray="6" stroke-dashoffset="6" d="M12 10V14"><animate fill="freeze" attributeName="stroke-dashoffset" begin="0.6s" dur="0.2s" values="6;0"/></path></g><circle cx="12" cy="17" r="1" fill="currentColor" fill-opacity="0"><animate fill="freeze" attributeName="fill-opacity" begin="0.8s" dur="0.4s" values="0;1"/></circle></svg>');
        $(el).find('.loading-wrap').addClass('error');
      }
    },
    request: (el, url, callback, onFailure) => {
      let retryTimes = 3;
      utils.onLoading(el);
      function req() {
        return new Promise((resolve, reject) => {
          let status = 0; // 0 等待 1 完成 2 超时
          let timer = setTimeout(() => {
            if (status === 0) {
              status = 2;
              timer = null;
              reject('请求超时');
              if (retryTimes == 0) {
                onFailure();
              }
            }
          }, 5000);
          fetch(url).then(function(response) {
            if (status !== 2) {
              clearTimeout(timer);
              resolve(response);
              timer = null;
              status = 1;
            }
            if (response.ok) {
              return response.json();
            }
            throw new Error('Network response was not ok.');
          }).then(function(data) {
            retryTimes = 0;
            utils.onLoadSuccess(el);
            callback(data);
          }).catch(function(error) {
            if (retryTimes > 0) {
              retryTimes -= 1;
              setTimeout(() => {
                req();
              }, 5000);
            } else {
              utils.onLoadFailure(el);
              onFailure();
            }
          });
        });
      }
      req();
    },
  };
</script>

<script>
  const sidebar = {
    leftbar: () => {
      if (l_body) {
        l_body.toggleAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    rightbar: () => {
      if (l_body) {
        l_body.toggleAttribute('rightbar');
        l_body.removeAttribute('leftbar');
      }
    },
    dismiss: () => {
      if (l_body) {
        l_body.removeAttribute('leftbar');
        l_body.removeAttribute('rightbar');
      }
    },
    toggleTOC: () => {
      document.querySelector('#data-toc').classList.toggle('collapse');
    }
  }
</script>

<!-- required -->
<script src="/js/main.js?v=1.28.1" async></script>

<!-- optional -->



<script defer>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.services = Object.assign({}, JSON.parse(`{"mdrender":{"js":"/js/services/mdrender.js"},"siteinfo":{"js":"/js/services/siteinfo.js","api":null},"ghinfo":{"js":"/js/services/ghinfo.js"},"sites":{"js":"/js/services/sites.js"},"friends":{"js":"/js/services/friends.js"},"timeline":{"js":"/js/services/timeline.js"},"fcircle":{"js":"/js/services/fcircle.js"},"weibo":{"js":"/js/services/weibo.js"},"memos":{"js":"/js/services/memos.js"}}`));
    for (let id of Object.keys(ctx.services)) {
      const js = ctx.services[id].js;
      if (id == 'siteinfo') {
        ctx.cardlinks = document.querySelectorAll('a.link-card[cardlink]');
        if (ctx.cardlinks?.length > 0) {
          utils.js(js, { defer: true }).then(function () {
            setCardLink(ctx.cardlinks);
          });
        }
      } else {
        const els = document.getElementsByClassName(`ds-${id}`);
        if (els?.length > 0) {
          utils.jq(() => {
            if (id == 'timeline' || 'memos' || 'marked') {
              utils.js(deps.marked).then(function () {
                utils.js(js, { defer: true });
              });
            } else {
              utils.js(js, { defer: true });
            }
          });
        }
      }
    }
  });
</script>

<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    ctx.search = {
      path: `/search.json`,
    }
    utils.js('/js/search/local-search.js', { defer: true });
  });
</script><script>
  window.FPConfig = {
    delay: 0,
    ignoreKeywords: [],
    maxRPS: 5,
    hoverDelay: 25
  };
</script>
<script defer src="https://cdn.bootcdn.net/ajax/libs/flying-pages/2.1.2/flying-pages.min.js"></script><script defer src="https://cdn.bootcdn.net/ajax/libs/vanilla-lazyload/17.8.4/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazy",
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    window.lazyLoadInstance?.update();
  });
</script><script>
  ctx.fancybox = {
    selector: `.timenode p>img`,
    css: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.min.css`,
    js: `https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.22/fancybox/fancybox.umd.min.js`
  };
  var selector = '[data-fancybox]:not(.error)';
  if (ctx.fancybox.selector) {
    selector += `, ${ctx.fancybox.selector}`
  }
  var needFancybox = document.querySelectorAll(selector).length !== 0;
  if (!needFancybox) {
    const els = document.getElementsByClassName('ds-memos');
    if (els != undefined && els.length > 0) {
      needFancybox = true;
    }
  }
  if (needFancybox) {
    utils.css(ctx.fancybox.css);
    utils.js(ctx.fancybox.js, { defer: true }).then(function () {
      Fancybox.bind(selector, {
        hideScrollbar: false,
        Thumbs: {
          autoStart: false,
        },
        caption: (fancybox, slide) => {
          return slide.triggerEl.alt || slide.triggerEl.dataset.caption || null
        }
      });
    })
  }
</script>
<script>
  window.addEventListener('DOMContentLoaded', (event) => {
    const swiper_api = document.getElementById('swiper-api');
    if (swiper_api != undefined) {
      utils.css(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.css`);
      utils.js(`https://unpkg.com/swiper@10.3.1/swiper-bundle.min.js`, { defer: true }).then(function () {
        const effect = swiper_api.getAttribute('effect') || '';
        var swiper = new Swiper('.swiper#swiper-api', {
          slidesPerView: 'auto',
          spaceBetween: 8,
          centeredSlides: true,
          effect: effect,
          rewind: true,
          pagination: {
            el: '.swiper-pagination',
            clickable: true,
          },
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
        });
      })
    }
  });
</script>
<script>
  document.addEventListener('DOMContentLoaded', function () {
    window.codeElements = document.querySelectorAll('.code');
    if (window.codeElements.length > 0) {
      ctx.copycode = {
        default_text: `Copy`,
        success_text: `Copied`,
        toast: `复制成功`,
      };
      utils.js('/js/plugins/copycode.js');
    }
  });
</script>


<!-- inject -->

</div><script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\(","\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="//cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body></html>
